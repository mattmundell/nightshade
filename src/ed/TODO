-*- Mode: Text; Package: ed -*-

revert rest of sys to public domain  ../etc/TODO
create online release plan (quick, for better direction)  ../etc/TODO
c-o  w 1 win  mv pnt to same posn in new that was display on line in old
  ie screen shows same text, split in two windows
reeval defvar on Ed Ev Defun (c-x e)
   warn if keep same val?
.db saving
locate  c-g before cmd finishes
hyper
flush-t-w option buffer,mode
dired versions  eg :src/mh/mh-6.8.3
revert always revert to orig
rename font vars *xx*
mail
	split
	complet
		with pnt directly after "To:"
		hard to just write a space, maybe tab / alt-spce / alt-enter to complet
	o on head open other win  instd of changing layout
    base64 text attachments
    when refresh and empty must clear old msgs (~?  eg send last draft)
		could rotate buffers or show empty buf
    list of mail folders
		count of new msgs
    some way to handle mail check hanging
		check for new mail in slave/thread/bg?
        	maybe also auto set pop-server (eg set if on net)
    edit draft, open another, edits gone
		ok if save, buffer still gone (~reused?) save save (?)
			prompt to save old one?
    c-g during send  draft gone
Auto Inflate Files
	similar Content-Type: text/enriched
		eg /home/matt/doc/retrospect/year-level-overview
	maybe read,write filters according to content type
		File Type Handlers  (where the translation is before read and after write)
			;; similar list already in dired bound to z
			(("Z" compress-read compress-write)
			 ("gz" gz-read gz-write))
		Content Handlers  (where the translation is after read and before write)
			(("text/enriched"  ;; mime name, as in mh attach handling
			  . convert-enriched))
www
    forms
info readers
    err when call next ref in leaf node buffer
    index, goto node, searching, menu
    clean and speed up scribe parsing  maybe save to lisp (~fasl?) instd
many lang modes  asm (src/lisp/linux-stubs.S), forth, shell, sg,x,html
    indent
    context highlighting
	fill
backup to isp  prhps tramp-like
    pd ftp info/sw
    ftp://user@x.domain/
    (pathname "user@localhost:/")
    (read-file (pathname "localhost:/") (current-point))
vc
	very slow eg dir of many files
	err on entering subdir
	or  under vc   stay in dir list

=================== ok for everyday work  (nightshade 2)

set b pkg  completion
Search Buffers
(setq *error-output*
      (make-hemlock-output-stream (buffer-end-mark edi::*message-buffer*)))
naming
	edit sys procs
	edit dir
	find file		   edit file
	edit packages
	find-object        edit-value?
	browse folders
consider optnl generic cmd complete msg
spell  i insert into personal dict permanently
c-uc-f /home/matt/src/nightshade/build/lisp/lisp:
dired +  sometimes makes dir elsewhere
rotate buffers  sometimes seems to rotate forward when should be back
					maybe after find file
sometimes "bad address" on build
isearch
	history
	c-l during stays in search
~ Copy Remote File   dir, recurse    ftp, http
	Copy File [Recursively]       ftp://..  http://..
bufed  flag if process
       ~ improve layout ~ long lines
       keep posn on refresh
cmp  finish dir cmp
	 show line numbers
	 highlight
	 enter go to source
	 n,p mv across compared sections
	 slow for big file
	 split into function
	 add tests, styles
font  keep underlining when next font (how to end?)
m-q  (fill para)
	string indenting
	respect open lines (when in string)
list processes  enter goes to process (ie proced)
+ interface to vm:memory-interface  (crashes on :dynamic)
m-/ complete from all buffers (at least all visible)
c-g in  macro def
		?-invoked ~inspection  eg backtrace
cmp defparse "algo" w byacc
c-h k c-c s s  should find in .hem
    rompsite fun-defined-from-pathname get pn from %function-self
      which is a function like make-interpreted-function
multiple revert  buffer history
    similar  cvs, sys trace tool that goes backwards
archive viewing,editing mode  part of dired
auto save directly to file  related files as vars
Describe Variable c-h g (g for global)
goto var def  meta-g v
dired  mv,cp adjust existing buffers, offer to mv,cp bak,ckp
       slow  eg /home/matt/Mail/archive/misc/  anything w many files
       recursive D
Convert Spaces To Tabs   (long name  cf End of Buffer (vs Go To End of..))
--
correct :line,% redisplay
    prhps redispl should check if modeline has changed?
recursive extended cmd
repeat last cmd  C-z z*
vc interface
	darcs, subversion, trac, git, hg... as required
    retrieve prompted versions
    annotate
    dired  show only  files under cvs, ~ files w status
www
    fetch,render in bg
dired  keep point on file column
       Dired Search could be Group Search
	   	   maybe dired buffers could define a group
       [Dired] Search/Find [Recurs]    + with Pattern
lisp find expressions like mh pick exps
   ;(or (name ".*\.lisp") (search "foo"))
   (or (name (many :char) ".lisp") (search "foo"))
   (or (name (* :c) ".lisp") (search "foo"))
   ;(or (name ".abc") (search "foo"))
   (or (name :c "abc") (search "foo"))
mail  replace external program w lisp
          split mail slow   calls mh ~scan for every rule
      better multipart handling
          nested parts
	  other types of attachment encoding
	  attach file  suggest type, type completion
      auto address to .db
integrate public domain ~database
    distributed
    nuttal encyclopedia, infoanarchy wiki, 1911 encycl
    dict
        copyright on original source of gcide?
	pd french dict, pd lojban words
native web browser
    need frames?  maybe like generaliz of emacs header lines
    generate parser defn from dtd,schema?

clear out FIXes

introduce single window, stick echo area prompt to bottom of window,
  always prompting, prompt with current directory like shell,
  brighten prompt when in echo area, mv echo area to top, move modelines to
  top, rename echo area (prompts and echoes, "area" ~redundant)

	Welcome to Nightshade.  This is the Echo Area window.  The last line in
	the window is prompting for a command.  All system messages appear in
	this window.

	The command Help (bound to C-h) switches to the help prompt.  Entering
	t at the help prompt enters a short tutorial.

	When the screen is split, for example when visiting the first file, the
	Echo Area window is set to a fixed size.  The command Extended Command
	(bound to M-x) switches to the Echo Area Window and moves point to the
	prompt.

	Arbitrary Lisp expressions can be entered at the prompt instead of
	extended commands, by preceding the expression with a `*'.


;;;; Bill and/or Rob.

Make editor-error messages; that is just make many of the (editor-error)
forms have some string to be printed.
   Importance: often beeps and don't know why.
   Difficulty: pervasive search for EDITOR-ERROR.

Probably the ERROR for trying to modify a read-only buffer could/should be
an EDITOR-ERROR.  Maybe the error message should be an editor variable that
can be set for certain buffers or modes.

Make definition editing different.  Maybe only one command that offers some
appropriate default, requiring confirmation.  Maybe some way to rightly know to
edit the function named under a #'name instead of the function name in a
function position.  Think about whizzy, general definition location logging and
finding mechanism that is user extensible.

Think about regular expression searching.
   Importance: it would be used weekly by some and daily by others.

Make illegal setting window width and height, (or support this).

Think about example init file for randoms.  It should show most of the simple
through intermediate customizations one would want to do starting to use the
editor.
  setting variables
  file type hooks
  hooks
  transposing two keys
  changing modifiers

DEFMODE should take a keyword argument for the modeline name, so "Fill"
could be named "Auto Fill" but show "Fill" in the modeline (similarly with
"Spell" and "Save").
   Importance: low.
   Difficulty: low.

Optional doc strings for commands?
   Importance: suggested by a couple people.
   Difficulty: ???

Get a real italic comment mode.
   Importance: some people want it, like Scott.
   Difficulty: hard to do right.

Line-wrap-character a user feature?  Per device?  Per device set from Hvar?
   Importance: a few people set this already for bitmap devices.
   Difficulty: low.
   Bill should just throw this in.

When MESSAGE'ing the line of a matching open paren, can something be done to
make the exact open paren more pronounced -- SUBSEQ'ing the line string?
   Importance: low
   Difficulty: one line frob to major echo area changes.

Do something about active region highlighting and blank lines.  Consider
changing redisplay to be able to hack some glyph onto the line, a virtual
newline or something.
   Importance: blank lines at the ends of the active region can be confusing.
   Difficulty: unknown difficult changes to redisplay.

Change redisplay on bitmaps to draw top down?  Currently line writes are queued
going down the window image but the queue is written backwards.
   Importance: low, two people commented on how it looks funny.
   Difficulty: unknown, but probably little.

Disallow tty I/O when the tty is in a bad state.  Since editor is sharing
Unix standard input with *terminal-io*, doing reads on this is bad among
other problems.
   Importance: necessary or non-experienced users.
   Difficulty: slight.  Error system wants to use *terminal-io* if you go
               into a break loop from the editor.
   Bill.

Make Lisp indentation respect user indentation even when in a form with known
special arguments?
   Importance: noticeable correctness.
   Difficulty: Lucid wrote this already with LOOP macro.
   Rob.
Make Lisp motion that exceeds the parsed region lose more gracefully by
informing the user, possibly offering to enlarge the parsing parameters.
   Importance: very deceptive as it is currently.
   Difficulty: ???
   Rob.
Lisp motion fails to handle correctly vertical bar syntax; for example,
      package:|foo|
   Importance: correctness, not too necessary
   Difficulty: ???
"Editor Evaluate Defun" does not handle multiple value returns correctly
... if we admit that this is often used to evaluate non-DEFUN top-level
forms.
   Importance: user convenience.
   Difficulty: low.

Super-confirm select buffer.  Super confirm means "make this be a legal
input".  Has no interaction with prompting function interface.  More
generally, make a *super-confirm-parse-function* that can be bound around
prompters.  One suggestion when prompting for a buffer is to make it, but
another suggestion is to find file some appropriate file.
   Importance: multiple people requested.
   Difficulty: low.
   Bill.
A super-confirm for a more facist "Find File" that disallowed creating buffers
when the file didn't exist could tell the command to really create the buffer.

Displayed-p shouldn't directly call update-window-image, or perhaps uwi should
be changed to check if the ticks and whatnot indicate recomputation is needed.
   Importance: minor efficiency hack and maybe a little cleaner.
   Difficulty: low.
   Bill.

Fix line-length for editor output streams.  The following example causes lines
to break incorrectly in "Eval" mode but not in "Typescript" mode:
   (defun dup (x n &aux r) (dolist (i n r) (push x r)))
   (dup 'a 100)     ;lines wrap due to faulty line breaking
   (dup 'aa 100)    ;lines wrap due to faulty line breaking
   (dup 'aaa 100)   ;now lines break correctly
   Importance: correctness.  It's not screwing anyone.
   Difficulty: depends on what the right thing is.

Termcap bug:
   setenv TERMCAP "foobar:li#65:tc=vt102:"
   set term = foobar
This causes an EOF unexpectedly on the string stream.  This is because the
the termcap parsing stuff wasn't written to go all the way back to the top
entry point to determine what file to use when the TERMCAP variable had an
indirection.  The code currently just goes to the beginning of the stream
and looks for the new tty name.

Make prompt text not part of input buffer.  Do some magical thing to solve
the problem of having special echo area commands that simply get around the
prompt text in the echo are buffer.
   Importance: low since problem is currently somewhat taken care of.
	       Possibly resolve problem when new editor environment stuff
	       goes in.
   Difficulty: Magical in origin.
   Rob.

Commonify everything.  Make everything portable that could be made so (file
system extensions, character att. finding, string ops, etc.) and document
our expectations of the non-portable stuff we lean on.  Provide portable
code for stuff done in assembler.
   Some known problems:
      %sp- functions aren't documented and don't have portable code for
         them.
      semantics of initial values versus declared type.
      :error-file to COMPILE-FILE calls.

   Importance: cleanliness and portability ease for those who want our
	       code.
   Difficulty: identify the problems and alter some code.
   Bill and Rob.

Fix things that keep text from getting gc'ed.  Buffer local things keep
pointer to buffer.
   Importance: could be important, maybe nothing is wrong.
   Difficulty: identifying problems.
   Bill or Rob.

Two reproducible window image builder bugs:
THIS IS NUMBER ONE:
I wrote this command:
   (defcommand "Fetch Input" (p)
     "Does \"Point to Here\" followed by \"Reenter Interactive Input\"."
     "Does \"Point to Here\" followed by \"Reenter Interactive Input\"."
     (declare (ignore p))
     (point-to-here-command nil)
     (reenter-interactive-input-command nil))
I made the following bindings:
   (bind-key "Fetch Input" #\hyper-leftdown :mode "Eval")
   (bind-key "Fetch Input" #\hyper-leftdown :mode "Typescript")
   (bind-key "Do Nothing" #\hyper-leftup :mode "Eval")
   (bind-key "Do Nothing" #\hyper-leftup :mode "Typescript")
In an interactive buffer I typed hyper-leftdown twice on the same line and
got the following error:
   Error in function HEMLOCK-INTERNALS::CACHED-REAL-LINE-LENGTH.
   Vector index, 14700, out of bounds.
This index is always the one you get no matter what line of input you try to
enter twice.
;;;
THIS IS NUMBER TWO:
Put point at the beginning of a small defun that has at least some interior
lines in addition to the "(defun ..." line and the last line of the routine.
Mark the defun and save the region.  Now, yank the defun, and note that the
beginning of the second instance starts at the end of the line the yanked copy
ends on.  Now type c-w.  You'll delete the yanked copy, and the lines that
should not have been touched at all end up with font marks.  Interestingly the
first line of the defun and the last don't get any font marks.
   Importance: well, they are reproducible, and they're pretty ugly.  No one
   	       has noticed these yet though.
   Difficulty: Rob and I didn't conjure up the bugs after a casual inspection.
   Bill AND Rob

Consider a GNU-style undo where action is undo-able.
   Importance: low, but people point it out as an inadequacy of the editor.
   Difficulty: possibly very hard.  Have to figure out what's necessary first.
   Bill and Rob


;;;; Mailer stuff.

Find all message-info-msgs sets and refs, changing them from possible list
values to always be a simple-string value.  Maybe must leave a list (or make
another slot) if I need to indicate that I can't use the value as a msg-id.
The only problem is coming through SHOW-PROMPTED-MESSAGE.  This could pick or
something to really know if there were more than one message or not.

Write "Refile Message and Show Next".

Add more folder support and possibly something specific for Bovik groveling.
For example, rehashing the cached folder names and/or adding new ones from a
folder spec or root directory (allows adding the bovik folders).

Consistency problems:
   Expunging message should not JUST delete headers buffers and their
   associated message buffers.  There could be independent message buffers with
   invalid message id's.  Since these are independent, though, we might not
   want to gratuitously delete them.

   "Headers Delete Message" should check for message buffers when virtual
   message deletion is not used, deleting them I suppose.  Instead of just
   making headers buffers consistent.



;;;; Spelling stuff.

This stuff is probably for Rob or Bill, but think about undergrad
dispatching before actually implementing it.

Two apostrophes precede a punctuation character, as in:
	``This is a very common occurrence in TeX.''
"Correct Buffer Spelling" complains that '' is an unknown word.  The problem
doesn't show up if the character preceding the apostrophes is alphabetic.

"Correct Last Misspelled Word" should try to transpose the space on the
ends of a word if there are more than one misspelling (adjacent?).  This
would have to be done at the command level trying to correct different
words formed from the buffer.

Fahlman would like to see a list of words that are treated as errors, even
though they may be in the dictionary.  These are considered common typos made
that actually are rarely-used words.  These would be flagged as errors for the
user to do a conscious double check on.

When the spelling correction stuff cannot find any possible corrections, it
could try inserting a space between letters that still form legal words,
checking the two new words are in the dictionary.
   Importance: possibly pretty useful, especially with "Spell" mode.
   Difficulty: low to medium.
   Bill, possibly undergrad after I looked at it.

Fix "Undo Last Spelling" correction interaction with auto-fill.  When this
command is invoked on a word that made auto-fill break the line, shit
happens.
   Importance: Rob noticed it.
   Difficulty: unknown.
   Bill or Rob.



;;;; User and Implementors Manuals

User Manual wall chart appendix based on systems (e.g., dired, mailer, Lisp
editing, spelling, etc.), then modes (e.g., "Headers", "Message", and "Draft"),
then whatever seems appropriate.

Point out that "Make Buffer Hook" runs after mode setup.



;;;; Things for undergrads.

Create "Remote Load File" and make "Load File" use it the way "Compile File"
uses "Remote Compile File".

Make "Insert Scribe Directive" undo-able, and make the "command" insertion
stuff use the active region.  Also, clean up terminology with respect to using
command and environment.
   Importance: it would be nice.
   Difficulty: little

Add a feature that notes modified or new lines, probably down in
HI::MODIFYING-BUFFER.  Then add interfaces for moving over these lines, moving
over text structures with these lines such as DEFUN's, paragraphs, etc.  Write
commands that display these in some way, compile them, etc.

Look at open paren highlighting and the Scribe bracket table stuff to make a
general bracket highlighter.  Possibly have to call function based on mode or
something since Lisp parens are found differently than Scribe brackets (Lisp
parse groveling versus counting open and close brackets).

Make hooks that are lists of function have list in the name, so users can know
easily whether to set this to a list or function.
   Importance: low.
   Difficulty: low, but pervasive.  must be careful.

Make FILTER-REGION not move all marks in the buffer to the end.  It should
affect each line, letting marks stay on a line, instead of deleting the whole
region and inserting a new one.
   Importance: low, but described behaviour is better than current behaviour.
   Difficulty: low.

Make some "Auto Save Access" variable, so users don't have to write fully
protected auto save files.  Possibly there could be some variable to that
represents default file writing protection.
   Importance: one person requested.
   Difficulty: easy.

Make "Save" mode on a first write or on startup check for a .CKP file.  If it
is there and has a later write date than the file, warn the user before a save
could overwrite this file that potentially has good stuff in it from a previous
Lisp crash.
   Importance: good idea, though people should know to check.
   Difficulty: easier if done on start up.
   FIX: warn-if-checkpoint-newer prints msg on file read if ckp newer

We need Lisp-like movement in Text mode -- skipping parenthetic and quoted
expressions while ignoring some Lisp syntax stuff.  Either can write a few
commands that do what we expect, or we can get really clever with the
pre-command parse checking and bounds rules for Text mode.  May even be able to
get the right thing to happen with code fragments in documents.
   Importance: would be pretty convenient to have it work right all the time.
   Difficulty: will take some thinking and playing around.  Rob or Bill guidance.

Make "Extended Command" offer a default of the last command entered.

Make "Select Group" command take an optional argument for the group
pathname and group name.
   Importance: convenience for init files.
   Difficulty: low.

Make "Unexpand Abbrev" work when no expansion had been done -- test for
error condition was backwards.

Add modeline display of current eval server and current compile server, when
appropriate.
   Importance: suggested by a couple people.  Low.
   Difficulty: none.
   	       Basically, just have to change string and function.

Make "Corrected xxx to yyy" messages use actual case of yyy that was
inserted into the buffer.
   Importance: more user friendly.
   Difficult: low.
   Anyone could do this, but it wouldn't be very educational for an
      undergrad.

"Find all Symbols" does a FIND-ALL-SYMBOLS on previous or current form if
it is a symbol.  See code for "Where is Symbol" in Scott's
Hemlock-Init.Lisp file.
   Importance: probably quite useful.
   Difficulty: none.
   Anyone could grab Scott's code.

Make buffer read-only when visiting unwritable file?  Bill and Scott
vehemently disagreed with this, but thought a variable would make everyone
happy.
   Importance: one person suggested.
   Difficulty: low.
   Anyone could do this, but it wouldn't be very educational for an
      undergrad.

Modify MAKE-BUFFER to error when buffer exists?
   Importance: more user friendly.
   Difficulty: none.
   Anybody could do this, but it wouldn't be very educational for an
      undergrad.

Warn when unable to rename a buffer according to its file.  This occurs
when writing files.
   Importance: more user friendly.
   Difficulty: none.
   Anyone could do this.
Uniquify buffer names by tacking a roman numeral on the end?
   Importance: I don't know why this is here.
   Difficulty: low.
   Anyone could do this.

Automatically save word abbrevs?
   Importance: low.
   Difficulty: low.
   Some undergrad could do this.

Automatically save named keyboard macros?  Maybe on request?
   Importance: other editors can do it.
   Difficulty: this is non-trivial since our kbmacs are based on their own
	       little interpreter.
   Medium undergrad task.

Make nested prompts work.
   Importance: some day this might be useful.
   Difficulty: medium.
   Upper level undergrad could do this.

Make character searches deal with newlines.
   Importance: correctness.
   Difficulty: medium.
   Upper level undergrad.

Put argument type checks in the editor primitives.
   Importance: low, the compiler should do this from type declaration
	       (cool?!).
   Difficulty: work in a lot of places.
   Undergrad could do the things Rob or Bill say.

Add a "Preferred File Types" to work in coordination with "Ignore File Types".
   Importance: low, suggested by one user.
   Difficulty: minimal.

Write separate search and i-search commands that do case-sensitive searches, so
user's don't have to set the Hvar for one search.
   Importance: low.
   Difficulty: low.

Add a write-region function which writes to a stream.
   Importance: low.
   Difficulty: medium.
   Undergrad.



;;;; The great rewrite and cleanup.

Compilation order.  Cleanup up defvars, defhvars, proclaims, etc. for clean
compilation of the editor in a Lisp without one.  Rename ED and HI packages
and start cleaning up compilation.  Defvars should go near pertinent code,
and proclaims should do the rest.  Do something about macros, rompsite, and
main.
   Importance: necessary for those taking our code and sets better example.
   Difficulty: few days of work.
   Bill.

Ed package cleanup -- exporting editor stuff, so users don't live in
ED package.
 Find primitives to export and describe in Command Implementor's Manual.
 Export existing command names in a separate file.
 DEFCOMMAND always interns in current package.
 Variables
  One global table.
  DEFHVAR only at top level.  Interns into current package.  WHAT ABOUT SITE-INIT?
  BIND-VARIABLE, a new form, will be used at top level or in setup
   functions to establish default values.
 Find all uses of FIND-PACKAGE etc. since these are
  suspect in the new package regime.
 Put DEFVAR's (esp. from Main.Lisp) in appropriate files, putting PROCLAIM's
   in a single file or in files with compiler warnings.
      Importance: really needs to be done along with environment stuff.
      Difficulty: pervasive changes to get right.
      Bill!

    eg account.lisp has to (in-package "ED") instd of (use-package "ED")

    add funcs,cmds in hi, exporting reqrd funcs,cmds from ed
    eg so in at-point.lisp
	 number-from-point is exported from hi and number-from-mark
           is only used in at-point.lisp
  	 word-at-point is defined in ed and used in hi (at-point.lisp)
	     so must ed::word-at-point (since rplcd use of w-a-p)
	     word-at-point s/b defined in hi
	     (word-at-point-command s/b exported from ed)
	     should word-at-point be exported from ed
		 eg for user init file

Generalized environments:
  Generalize notion of environment to first-class objects.
  can inherit stuff from other environments.  Shadowing for conflict
  resolution.  Transparent key bindings another sort of interaction.
  If we retain modes as a primitive concept, then how do they interact?
  If not, how do we get the effect?  Each buffer has an environment.
  This is normally the composition of the default environment and
  various mode environments.

  Turning modes on and off is simply adding and removing the mode's environment
  from the buffer's environment's inherit list.  The only sticky issue is the
  order of the inheritence.  We could assign each environment a precedence.

  I guess we could punt modes as a primitive concept.  The only thing this
  wouldn't provide that modes do is a namespace and the major/minor
  distinction.  Setting the major mode is just frobbing the lowest precedence
  environment in a buffer.  A major mode is distinct from a minor mode in that
  it inherits the global environment.  An interesting question is at which
  level precedences should be implemented.  We could have it be a property only
  of minor modes, which determines only the order in which a buffer inherits
  its minor modes, or we could make it a property of environments, and have it
  determine the total order of inheritance.  Probably the former is better: it
  simpler, and adequate.  Also, at the environment level, it is more powerful
  to be able to specify inheritance order on a per-case basis.

  Make mode-hooks be a mode-object slot rather than editor variables.  [a
  random cleanup]

  We change the (... &optional kind where) arguments to
  (... &optional where).  Where can be an environment such as
  *global-environment* (the default) or a buffer, or it can be a string, in
  which case it is interpreted as a mode name.

  Instead of having key binding transparentness be a property of modes or of
  commands, we make it a property of binding.  Each environment has separate
  key-tables for transparent and opaque bindings, and there is a
  Transparent-Bind-Key function that is used to make transparent key bindings.
  [... or something.  This would imply a delete-transparent-key-binding and
  prehaps other functions, so we might consider passing a transparent flag to
  the primitives.]

  *current-environment* is the current environment, which is normally eq to the
  current buffer.  Attributes and variables are implemented using deep-binding
  and caching.  Whenever there is any change to the inheritance structure or to
  variable or attribute bindings, then we just totally flush all the caches.
  The most frequent operation that would cause this to happen would be changing
  a mode in a buffer, which is rare enough so that there should be no problem.

  For variables, we just have a symbol-name X environment => binding cache.

  For attributes we have two caches: attribute X environment => value vector
  and attribute X environment X test-function => search vector.  The first
  translates an attribute and environment to a simple-vector that contains the
  current value for each character in that environment.  This is used for
  Character-Attribute and when the Find-Attribute cache misses.  When this
  cache misses, we fill the vector with a magic "unspecified" object, and then
  scan up the inheritance, filling in any bindings that are unspecified.  We
  could optimize this by noting in the character-attribute object when an
  attribute has no shadowings.  character-attribute hooks have to go away,
  since they depends on shallow-binding.

  Make editor variables be typed.  Have a :type defhvar argument,
  variable-type function.  In implementation, create a test function for each
  variable so that we can efficiently check the type of each assigned value.
  This implies defhvar should be a macro.  We could make specifying the test
  function be an explicit feature, but the same effect could always be obtained
  with a Satisfies type specfier.

  Split binding of hvars from definition.
      Bind-Variable Symbol-Name Value &Optional Where
  Creates a binding.  If :Value is specified to defhvar, then it creates a
  global binding of that value.  If no :Value is specified, then there is no
  global binding.  We could flush the :Mode and :Buffer options, and require an
  explicit Bind-Variable to be done in this case, or we could still allow them.
  It would probably be better to flush them, since it would break code that is
  doing run-time defhvars to make buffer-local variables.  Perhaps we would
  flush only :Buffer, since it is clearly useless, while being able to give an
  initial mode binding may be useless.

  All variable attributes except for value are global.  Hooks are global.  The
  concept of a hook is somewhat dubious in the presence of non-global bindings.
  It might be semi-useful to invoke the hook on each new binding in addition to
  on each set.

     Importance: Next big step for the editor.
     Difficulty: Two months.
     Bill will do this.

Multiple font support:
 Figure what kind of multi-font stuff we want to do.
 Bogus to use integer constants for facecodes.  It is reasonable within the
 font mark, but the user interface should be keywords for facecodes.
   Importance: no documented font support currently.  Really need it.
   Difficulty: includes massively reworking redisplay data structures.
   Bill and Rob.



;;;; Things to think about.

;;; These are things that have been thought of, but we don't know much more
;;; about them.

Some general facility for users to associate definition locations with kinds of
things and/or forms.

What's the right way to be in a comment in some Lisp file and have filling,
spelling, and whatever work out just right.  Possibly regions with environment
information.  Maybe with a whole new hierarchical text representation, this
would fall out.

Synchronization/exclusion issues:
    Currently there are non-modification primitives that are looking into a
    buffer assuming it will not change out from under the primitive.  We
    need to identify these places and exactly what the nature of this
    problem is (including whether it exists).  Probably we need to make
    non-trivial text examination primitives use without-interrupts so that
    they see a consistent state.

    Find other places where exclusion is needed:
        Redisplay?
        Typescript code?

Online documentation stuff: What to do and how to do it.  Rob has some
notes on this from a year or two ago.
   Importance: something to do.
   Difficulty: high.
   maybe no one.

Think about general "Save My Editor State".  Can generalize notion of
stateful things? -- Word abbrevs, keyboard macros, defindent, spelling
stuff, etc.  This could be the last thing we ever do to the editor.
   Importance: low.
   Difficulty: very.
   ???



;;;; New Eval Servers

Do something about slaves dieing in init files.  Lisps start up and first load
init.lisp.  When a slave does this, it goes into the debugger before connecting
to the editor.



;;;; X problems.

Compute mininum width of a window group by taking the maximum of all the
windows' font-widths, each multiplied by minimum-window-columns.  Right now it
just uses the default font or current window.

Compute minimum window split correctly: look at current window's font-height
and new window's font-height, extra height pixels, whether each has a modeline,
and minimum-window-lines to determine if we can split the current window.

Server not implementing DRAW-IMAGE-GLYPHS correctly, so we don't have to do our
pixmap hack.




;;;; more

(most recent last)

console right ctrl

random typeout should be at bottom (to be near echo area)
    maybe echo area s/b at top (near top of text, which is read from the top)
        and typeout should follow it

toggle truncate lines  and ~ shift window right,left over text

query replace (m-%) " file)" with ""  (hung)

created struct node  want car to work on node

text/enriched mode

full format func doc

completion for c-h f and similar
    also for c-ce   like adding generic lisp completion
	                ie dabbrev expand should check for lisp function names

dabbrev check other buffers, histories

c-h f go to ed fun too
    ed::word-at-point works
    expect it should already, seems to do w *package* binding

apropos functions

dired  w  copy marked files (if any else current file) to kill ring
	    (as a whitespace seperated string of names)
       y  if any such entry on top of kill ring copy files into current dir
       ~>  copy marked/current file/s to other window (if in dired mode else other of that win...)
	     so open two panes and use a key to copy file b/w them

completion to kill one of these buffers when they all exist
  Objed "#(jef m    (
  Objed "#(jef m    (g
  Objed "#(jef m   (g"...

completion on kill buffer with many spcs in name  eg "a  z"

+ Find Files  (opens all files)

buffer name completion
    z a b
    zz a b
prompt: z a b    ; think after complete field ~popup here point should be after the z

.db partial match when finding name

how to size of object?
    maybe ~ instance-memory  (ref'd in `room' doc)

rub in random typeout go backwards

sort paragraphs, ~fields

mh error -- scan: no new messages in drafts
    when last sent
    also when c-xr folder when folder is empty

err w long lines?  eg open parse-tests/out-long
    saw similar much later due to after-change-hook

reclaiming search pattern functions on arb searches in code
    (added find-character, maybe means add find-string)

consider symbol case sensitivity

regex (or equiv) buffer search
   Regx Isearch: .*a+bc?
   ; o for or; m for many; :c for :char; s should be a for any = (or (many ...) "")
   ~BNF Isearch: :s :c::m a:b:o c "":          ; w symbol reqs as strings/chars (the a in :m a:)
   ~BNF Isearch: :s :c::m a:b:o c:             ; and w single or as optnl
   ~BNF Isearch: (s :c)(m a)b(o c)             ; braces
   ~BNF Isearch: (:c){a}b[c]                   ; (some) {many} [or]
   ~BNF Isearch: :c)a}b[c                      ; (some) {many} [or] w implicit braces
   ~BNF Isearch: :)a}b[c                       ; (some) {many} [or] w implicit braces and : for :char
   Regx Isearch: \(.\|d\)*a+bc
   ~BNF Isearch: :s (or :c d)::m a:b:o c:
   Regx Isearch: \(.d\.\)*\(ab\)+bc
   ~BNF Isearch: :s :c d .::m ab:b:o c:
   Regx Isearch: \(.d\.\)*\(ab f\)+bc
   ~BNF Isearch: :s :c d .::m "ab f":b:o c:
   Regx Isearch: \(.d\.\)*\(ab \\\\f\)+bc?
   ~BNF Isearch: :s :c d .::m "ab \\f":b:o c:
   ~BNF Isearch: (s :c d .)(m "ab \\f")b(o c)  ; braces instead of :
   Regx Isearch: \(.d\.\)*\(ab\\\\f\)+bc?
   ~BNF Isearch: :s :c d .::m ab\\f:b:o c:
   ~BNF Isearch: (a :c d .)(m ab\\f)b(o c)     ; braces instead of :
   ~BNF Isearch: (a :c d .) (m ab\\f) b (o c)     ; readable by lisp reader
   xd.ab\fbc
   Regx Isearch: .
   ~BNF Isearch: :c:
   Regx Isearch: \\
   ~BNF Isearch: \
   Regx Isearch: :
   ~BNF Isearch: ::  (:)
   Regx Isearch: (
   ~BNF Isearch: (
   ~BNF Isearch: (( (:ob) ((( () ()) (:) #\(	  ; braces instd of :
 are there better alternatives to these two?
 adding regexs feels like adding another language

diary movement  next and previous entries
calendar as timeline  (mayb just some way of linking events by time)

pop-up-display when another already up
    eg if many reminders occur in short time

Dired Toggle File Compression  posn fail when run twice in quick succession

multi-let, multilet, mullet, multi-bind, mbind, bind, mvb, mub, mulb,
  let+, let*
  mlet (similar macrolet, mayb too similar to let)
    for multiple-value-bind
    (let (((a b c) (f))) ...)   for   (m-v-b (a b c) (f) ...)
    (let ((x t) ((a b) (f))) ...)
    (let (var (x t) varb ((mula mulb) (func)) varc) ...)
        quite hard to read

lisp build scripts
    show build errors in interactive output

kill builder buffer  ~still linked to slave

c-h as prefix instead of command?
    named prefix ie print "Help (h for help): " instead of c-h
    with ~popup/action (as with h in help) which leaves prefix intact

c-m-\  break on "break" key, or some other, instead
       revert to indent region (now on meta-?)

  "·  ^\ quits.  Same as interrupt.  Also may dump a "core" file (which
     you likely have no use for) into your working directory."

     pdksh man
	 intr and quit
             The interrupt and quit terminal characters cause the current line
             to be deleted and a new prompt to be printed.

		maybe due to shell?

wrap isearch

mail
    nested groups  surname.name

processes are active, exit anyway?
   better: processes are active, ~ exit anyway; kill and exit; cancel?

show point in other windows

resize window
    ~ Shrink Win to Buffer
	call in Next Search Match

C-e eval of large fun fails when Editor Evaluate Buffer works
     eg insert-node in parse-scribe.lisp

auto spell mode
    could intro per-mode extra dict
    maybe also per mode skip words w certain chars eg - for lisp

vc interface
    could round off and test rcs

more,better lang modes
	c++, python, prolog, scheme, forth
