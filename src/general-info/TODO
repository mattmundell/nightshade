;;; towards a public domain computer
full pd
    revert to as far back as possible
	where is the full pd?
    reduce to pd
      src/ldb/egets.c  copyright cmu (so maybe actually pd)
      clean general-info/ and docs/ refs to clx...
    consistent comments,docs,msgs
merge in cl-utilities
   note each licence in html doc, eg split-sequence
	This code was written various people, and the license is unknown. Since
	multiple people worked on it collaboratively and none of them seem interested
	in keeping their intellectual property rights to it, I'll assume that it is in
	the public domain (since the process that produced it seems like the very
	essence of public domain). If this is incorrect, please contact me so we can
	get it straightened out.
	split-sequence.lisp
	;; cl-utilities note: the license of this file is unclear, and I don't
	;; even know whom to contact to clarify it. If anybody objects to my
	;; assumption that it is public domain, please contact me so I can do
	;; something about it. Previously I required the split-sequence
	 ; package as a dependency, but that was so unwieldy that it was *the*
	;; sore spot sticking out in the design of cl-utilities. -Peter Scott
     rest seem ok in code	
replace copyrighted cmucl parts w public domain equivs
    replace dependencies on copyrighted code
	replace external library dependencies
	    maths lib, c lib
        move c into lisp
	    gencgc
		switch to cgc.c? only x86, same as gencgc
	replace unix parts
	    lisp build scripts  (almost done)
	    `make' system  move c into lisp
	    lisp versions of unix tools
		parse
		    speed
		        *marks* optnl
		        create node afterwrds?
       			boyer-moore?
		    backw
		    use in dired search
			Srch [R]  case  c-u? (for hidden files) c-uc-u? then for hidden,case? c-uc-uc-u?
				  what about backup files?
				  maybe c-u results in prompts for all of these
				      fold case, search hidden, search backup
	    	head, tail...
	    	tar, compression
	    dict interface  pd version incl data
		dictd, dict client
    		    pd dicts  moby thes, jargon file, ...
		    orig source of gcide?
    add system services i.e. replace unix kernel
graphics, images
    vector graphics mixed w text
run cmucl/retroforth on a simple public domain architecture
consider lojban
    which spoken langs are verb-first like lisp?
    integrate w :doc/system
    letters ordered  most common first

    The language is a set of descriptions of state.
    The language can describe a state, including all possible changes
    that the state can undergo.
	; dimension for function vibe, needs to think through handling if
    The language can describe the evaluation of objects.  Objects can be
    symbols or structures.  A structure is a grouping of one or more
	; or lists which evaluate as functions, w stack-like arg eval
    optionally named objects.  A symbol is a reference to another object.
    Evaluation of a symbol produces the referred object.  Evaluation of
    a structure produces the structure.

    The integers are structures of two symbols, universe and empty.  For
    example 1 is a structure of a structure of a symbol which is universe,
    and 3 is a structure of a structure of two symbols both universe.

    Sequences of evaluation can be shared in functions.
    Argument evaluation, closures.


    hil is latin for true  false? is false required?
	how bout just n/f? (like t)
	why scheme uses #t #f? easier to spot?
	what does lojban use?
	(~complement (page-large-object-p first-page))
	for
	(if (page-large-object-p first-page) nil t)
	(- all true)?

    always, multi-return-protect, <throw-protect>, always-after
      instead of unwind-protect

    or instd of unless
    if+ instd of when? or+ instd of unless? (like let*) maybe if*,or*
	(when a b)
	(a a b)      ; a for and, maybe and*, an*, a*  ..+ ..1

	(unless a b)
	(o a b)      ; o for or, maybe or*, o*  ..+ ..1
	(cond (a b) ((..) c) (t d))
	(or* (a b) ((..) c) (t d))

	(if a b c)
	(a (o a c f) b)   ; a and, o or, f false
	     ;; FIX how to return the c?
	     (a (o a (values f c)) b)   ; a and, o or
					; f ends a which rets 2nd val (c)
	     (a (eq (o a c) c) b)   ; a for and, o for or  if eq rets val
	(and* (a b) ((..) c) (t d))  ; like cond, tests each case
				     ; rets ~ multiple
	(or* (a b) (t c))

    replace if w cond?
    (if x a b)  (cond (x a) (t b))  (cond (x a) b)  (if (x a) (t b))


    (>< (<>  (greater-than-or-less-than
    epsilon, zero   list terminator, end, false   always, forever, ever

    replace do w loop? (and rename loop do)
    (do ((for x t :then f)        ; (let i 0 f)
	 (for i 0 :to 10 :count)  ; (let i 0 :to 10 :count)
				  ; (let ((i 0 10 :count)))?
	 (while x)
	 (return t))
       body)
    (do (for x 0 10) body)
    dolist?  (do ((for ele :in list)) ...)
	     (do ((list ele list)) ...)
	     (dolist (ele list) ...)
	     (do ((list list)) ...)  elements bound to var $ or $_ $1
	     (do (list list) ...)    elements bound to var $ or $_ $1
from hem macros.lisp
;; FIX structure like do  FIX use (loop while ... do
; (defmacro while (cond &rest body)
;   `(do () ((if ,cond nil t))
;      ,@body))
; (ed::defindent "while" 1)

    add (format nil "x: ~$x")   ; like (format nil "x: ~A" x)
        (format nil "x: ~$S$x") ; how to ~S like above

    keyword as func name?  (:f arg)
	maybe epsilon function name, eg ( arg arg2 :keyword val), (:keyword val)

    ;; FIX logand  bit logic (vs maths logic)  (maybe bitand instead?)

    deflaz  (think lazy may usually mean evaluated, just as late as psbl)
	    (whereas these args are optionally evaluated)
	    deftrans defmacro defun2 defclosure defclos defcl define def
	    defspec defsf defsp
	    defclo

        name all such functions similarly
	at least highlight all same (as special forms currently highltd)

(deflaz when (cond &rest body)
   (if ,cond ,body))

(deflaz eval (form)
   ,form)

(deflaz when (cond &rest body)
   (if (eval cond) (eval (cons 'progn body))))

(defmacro when (cond &rest body)
   `(if ,cond (progn ,@body)))

(defun a (b c d)
   (,b c ,d))       ; evaluates d "twice", evaluates b to produce the function name/symbol

(declaim (inline when))
(deflaz when (cond &rest body)
   (if ,cond ,(cons 'progn body)))    ; evaluate cond "twice", eval result of eval of (cons ...)


handlers

  1 (handler-bind ((editor-top-level-catcher #'identity))
    (catch 'editor-top-level-catcher
    (signal 'editor-top-level-catcher nil))
    (throw 'editor-top-level-catcher nil))

	     (block ed-x
	       (handler-bind
	           ((editor-top-level-catcher #'(lamdba () (return-from ed-x)))))
	         ...
	         (signal 'editor-top-level-catcher nil)...

	      s/b~

	      (catch-condition 'editor-top-level-catcher
		...
		(throw ~(make-condition 'editor-top-level-catcher) nil)...

	should be able to catch,throw conditions?
	and signal symbols?
	    then maybe replc throw w signal
		throw returns the stack to a catcher
	          whereas signal just runs the handler code

  2	(handler-case
	   ((a () ...)
	    (b () ...))
	  form*)

	    so that cases at top like handler-bind
               and can have many forms in case (form*) instd of one

  3  why handler-case handlers form* while handler-bind handlers functions?

~ generalized functions (as in clos)
    (~overloading?)

~run-time modification of structure (ie the definition of the structure)
    eg to change node insert function
    (defstruct (s) a)
    (symbol-function s)
    (symbol-structure s)

files as a type of variable
    so map a var name to memory on disk
    instd of mapping a file name to the set of blocks

tracer, meta, <word for thinking about thinking>, higher-order
   (name for tracing tool)
