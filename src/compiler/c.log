/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval.lisp
05-Feb-90 20:45:20, Edit by Ram.
  Fixed MAKE-INTERPRETED-FUNCTION to specify the LAMBDA slot when creating the
  function so that it is avaliable to INTERPRETED-FUNCTION-LAMBDA-EXPRESSION.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/sset.lisp
05-Feb-90 12:07:12, Edit by Ram.
  Fixed a problem in SSET-UNION-OF-DIFFERENCE.  It was using (>= num2 num3) in
  two places where it should have been using <=.  Probably due to incorrect
  modification of the original SSET-DIFFERENCE code into this function.  The
  original function had the inner loop over the second arg, rather than the
  first.  This effectively resulted in the difference aspect usually not
  happening, so the KILL set in constraint propagation never took effect,
  resulting in some over-zealous type propagation.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
04-Feb-90 10:11:51, Edit by Ram.
  Oops...  Fixed * transform so that multiplication by 8 doesn't really
  multiply by 256, etc.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
04-Feb-90 09:48:09, Edit by Ram.
  Wrote CLOSE-SOURCE-INFO, and made COMPILE-FILE, ADVANCE-SOURCE-FILE and
  COMPILE-FROM-STREAM call it.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/fndb.lisp
04-Feb-90 08:09:06, Edit by Ram.
  Added definition for %SP-STRING-COMPARE.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/seqtran.lisp
04-Feb-90 08:01:21, Edit by Ram.
  Fixed STRING<>=-BODY a bit.  In addition to some query replace lossage, there
  was also a genuine ancestral bug in computation of the result in the = case
  of = ops.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ctype.lisp
03-Feb-90 20:44:39, Edit by Ram.
  Made VALID-FUNCTION-USE and VALID-APPROXIMATE-TYPE return NIL, NIL when
  uncertainty is encountered, rather than T, NIL.  Everybody was expecting this
  to be a conservative test (and only looking at the first value.)  This caused
  spurious transforms to happen.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
02-Feb-90 14:08:09, Edit by Ram.
  Added NTH, NTHCDR transforms for the constant index case.  Added * transform
  for the power-of-2 case.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/seqtran.lisp
02-Feb-90 13:00:15, Edit by Ram.
  Added string transforms, derived from CLC sources.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
02-Feb-90 13:25:40, Edit by Ram.
  Added FORMAT transform derived from CLC sources.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/type.lisp
02-Feb-90 11:23:26, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
02-Feb-90 11:23:15, Edit by Ram.
  Defined TYPE/= and made the "anything changed" tests use it instead of TYPE=
  so as to be conservative in the presence of hairy types.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
02-Feb-90 10:29:54, Edit by Ram.
  Changed REOPTIMIZE-CONTINUATION to set BLOCK-TYPE-CHECK in the use blocks so
  that new derived-type information will also cause type checking to be redone.
  This mainly handles the case where new type information causes us to want to
  negate a check that was previously simple.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
02-Feb-90 10:12:24, Edit by Ram.
  Fixed CONTINUATION-%DERIVED-TYPE to call CONTINUATION-%TYPE-CHECK instead of
  CONTINUATION-TYPE-CHECK so that it won't recurse indefinitely.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/globaldb.lisp
01-Feb-90 14:46:13, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
01-Feb-90 14:43:26, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/knownfun.lisp
01-Feb-90 14:40:22, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
01-Feb-90 14:42:19, Edit by Ram.
  Flushed *FUNCTION-INFO* in favor of (INFO FUNCTION INFO ...).  Added
  FUNCTION-INFO-PREDICATE-TYPE slot.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
01-Feb-90 14:09:42, Edit by Ram.
  Changed ASSERT-CONTINUATION-TYPE to set BLOCK-TYPE-ASSERTED in the use
  blocks.  Also, moved fixed the setting of BLOCK-TYPE-CHECK to be on the use
  blocks rather than the CONTINUATION-BLOCK, since type check generation uses
  DO-NODES, and thus ignores the BLOCK-START.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/node.lisp
01-Feb-90 13:37:14, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/checkgen.lisp
01-Feb-90 13:41:46, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
01-Feb-90 13:41:48, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
01-Feb-90 13:42:05, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
01-Feb-90 13:42:29, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
01-Feb-90 13:43:07, Edit by Ram.
  Renamed the CONTINUATION TYPE-CHECK slot to %TYPE-CHECK, which is filtered by
  the new CONTINUATION-TYPE-CHECK function to make sure that it has been
  computed recently.  Changed setters of TYPE-CHECK to %TYPE-CHECK, and flushed
  the now unnecessary calls to CONTINUATION-DERIVED-TYPE (which explicitly did
  the recomputation.)

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
01-Feb-90 12:56:50, Edit by Ram.
  Changed %CONTINUATION-DERIVED-TYPE to not set TYPE-CHECK when the assertion
  is T or there is no DEST.  In the first case, this just avoids waste motion.
  In the second case, this prevents constraint analysis from being tricked into
  believing such a check will be done, when in fact no checks are done on
  unused values.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
01-Feb-90 12:51:41, Edit by Ram.
  Made DELETE-CONTINUATION, FLUSH-DEST, NODE-ENDS-BLOCK and UNLINK-NODE set the
  BLOCK-TYPE-ASSERTED and BLOCK-TEST-CHANGED flags.  At least for the former,
  this has to be done in more places than I thought, and also must be done for
  correctness, rather than just to ensure new assertions are seen.  This is
  because if a block is split, or code needing an assertion is deleted, then we
  must recompute the block's set of constraints or it will contain incorrect
  constraints.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/sset.lisp
01-Feb-90 11:33:28, Edit by Ram.
  Fixed SSET-INTERSECTION to blow away any extra elements in SET1 that are
  larger than the greatest element in SET2.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/node.lisp
01-Feb-90 10:34:17, Edit by Ram.
  Changed initial values for TYPE-ASSERTED and TEST-MODIFIED to be T rather
  than NIL.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/vop.lisp
30-Jan-90 16:10:06, Edit by Ram.
  Added IR2-ENVIRONMENT-KEEP-AROUND-TNS and IR2-COMPONENT-PRE-PACKED-SAVE-TNS
  so that we won't have to recompile to add these features later on.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval.lisp
30-Jan-90 14:54:58, Edit by Ram.
  Added the MAKE-INTERPRETED-FUNCTION interface which allows lazy conversion of
  functions and features bounded IR1 memory usage through a LRU cache that is
  partially flushed on GC.  Added INTERPRETED-FUNCTION-NAME,
  INTERPRETED-FUNCTION-ARGLIST and setf functions.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
30-Jan-90 10:08:19, Edit by Ram.
  Now that %DEFMACRO is passed #'(lambda ... for benefit for the interpreter,
  we don't want to unquote the definition using EVAL.  Use SECOND instead.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
29-Jan-90 14:17:06, Edit by Ram.
  Changed FIND-COMPONENT-NAME to bind *PRINT-LEVEL* and *PRINT-PRETTY* so as to
  prevent huge component names.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/life.lisp
29-Jan-90 13:43:23, Edit by Ram.
  Fixed CONFLICT-ANALYZE-BLOCK in the dead read case to do FROB-MORE-TNS on
  NOTE-CONFLICTS as well as the addition to the live set.  This was the fix to
  the long-procrastinated-about :MORE TN bug (first noticed in fall 88.)  Also,
  changed FROB-MORE-TNS to return whether it did anything, rather than sleazily
  hacking on the loop variable to get the loop to exit.  I must have been
  having a Pascal flashback when I wrote that code...

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval.lisp
29-Jan-90 13:24:23, Edit by Ram.
  Fixed LEAF-VALUE to use FDEFINITION rather than SYMBOL-FUNCTION when the name
  isn't a symbol.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
29-Jan-90 10:46:23, Edit by Ram.
  Changed COMPILE-FIX-FUNCTION-NAME to substitute for old uses of the name so
  that recursive calls get converted.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
29-Jan-90 10:13:18, Edit by Ram.
  But for the want of a single character...  So that's why no functions were
  being inline expanded!  In %DEFUN the ir1 translator, I was looking at the
  INLINEP value for the NAME in the same LET that was eval'ing the name to
  unquote it.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/debug-dump.lisp
27-Jan-90 18:05:15, Edit by Ram.
  Made DEBUG-SOURCE-FOR-INFO handle the incremental compilation cases.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
27-Jan-90 17:46:09, Edit by Ram.
  Wrote COMPILE and UNCOMPILE.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval.lisp
27-Jan-90 17:07:17, Edit by Ram.
  Added the interfaces INTERPRETED-FUNCTION-LAMBDA-EXPRESSION and
  INTERPRETED-FUNCTION-CLOSURE.  These use the new FIND-IF-IN-CLOSURE operation
  pick apart the closure that is an interpreted function.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
26-Jan-90 16:35:51, Edit by Ram.
  Moved a bunch of stuff from COMPILE-FILE to SUB-COMPILE-FILE.  Wrote
  MAKE-LISP-SOURCE-INFO and MAKE-STREAM-SOURCE-INFO.  Wrote
  COMPILE-FROM-STREAM, and added appropriate uses of the in-core compilation
  interface to various functions.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/globaldb.lisp
26-Jan-90 16:09:30, Edit by Ram.
  Made the CACHE-NAME slot be duplicated in both kinds of environment rather
  than inherited from INFO-ENV so that the inline type checks for the slot
  access will win, allowing bootstrapping to work.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval-comp.lisp
26-Jan-90 13:12:09, Edit by Ram.
  Changed COMPILE-FOR-EVAL to call the new MAKE-LISP-SOURCE-INFO, rather than
  rolling its own.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/globaldb.lisp
26-Jan-90 11:59:58, Edit by Ram.
  Added code to cache the last name looked up, since we commonly consecutively
  look up several types of info for the same name.  [Maybe even some types more
  than once!]

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
26-Jan-90 09:30:59, Edit by Ram.
  Fixed PROCESS-TYPE-PROCLAMATION to not try to call TYPES-INTERSECT on
  function types so that we don't flame out.  This was probably what I was
  really trying to fix in the last change to PROCESS-TYPE-DECLARATION.  Really
  both were broken.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
25-Jan-90 10:58:43, Edit by Ram.
  Added transform for ARRAY-DIMENSION that converts to LENGTH when possible.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/typetran.lisp
25-Jan-90 10:46:00, Edit by Ram.
  Moved array typep code here from vm-type-tran, since it turned out not to be
  VM dependent after all.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/typetran.lisp
23-Jan-90 15:31:32, Edit by Ram.
  Transformed array type tests to %ARRAY-TYPEP so that clever
  implementation-dependent things can be done.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
23-Jan-90 18:45:14, Edit by Ram.
  Fixed up some messed up backquote stuff in DO-MACROLET-STUFF where it was
  trying to coerce the lambda to a function.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/envanal.lisp
23-Jan-90 13:06:41, Edit by Ram.
  Don't annotate as TAIL-P nodes whose DERIVED-TYPE is NIL, so that we don't
  tail-call functions such as ERROR.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
23-Jan-90 12:44:28, Edit by Ram.
  Fixed %DEFUN translator to record an inline expansion when the INLINEP value
  is :MAYBE-INLINE as well as :INLINE.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
23-Jan-90 08:49:50, Edit by Ram.
  Changed PUSH-IN and DELETEF-IN to only call FOO-GET-SETF-METHOD when
  CLC::*IN-THE-COMPILER* is true, so that we can still use these macros in the
  old compiler.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/seqtran.lisp
22-Jan-90 16:11:28, Edit by Ram.
  Added a transform for MEMBER where the list is a constant argument (primarily
  to help MEMBER type tests.)

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval.lisp
22-Jan-90 15:20:27, Edit by Ram.
  Replaced all uses of COMBINATION- accessors with BASIC-COMBINATION- accessors
  so that MV combinations will work.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval.lisp
22-Jan-90 15:08:07, Edit by Ram.
  Put a couple of macros in EVAL-WHEN (COMPILE LOAD EVAL) so that they are
  avaliable to SETF in the bootstrap environment.  Also, changed %SP-[UN]BIND
  to the appropriate %PRIMITIVE calls.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/fndb.lisp
20-Jan-90 20:21:34, Edit by Ram.
  Fixed up FBOUNDP & stuff to correspond to the FUNCTION-NAME cleanup.  Now
  FBOUNDP can take a list as well as a symbol.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
20-Jan-90 09:56:43, Edit by Ram.
  In #+NEW-COMPILER, made DO-MACROLET-STUFF coerce the lambda expression to a
  function.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval-comp.lisp
20-Jan-90 09:52:20, Edit by Ram.
  Added bind of *FENV* to () in COMPILE-FOR-EVAL.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
20-Jan-90 09:50:59, Edit by Ram.
  And made IR1-TOP-LEVEL *not* bind *FENV* to () so that top-level MACROLETs
  will be recognized...

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
20-Jan-90 09:47:19, Edit by Ram.
  Added binding of *FENV* to () in SUB-COMPILE-FILE so that MACROLET processing
  won't flame out.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/macros.lisp
19-Jan-90 22:25:15, Edit by Ram.
  Made WITH-IR1-ENVIRONMENT bind a bunch more variables.  *fenv*, etc.  Wrote
  WITH-IR1-NAMESPACE, which allocates the gloabal namespace hashtables.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval-comp.lisp
19-Jan-90 22:35:44, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
19-Jan-90 22:34:20, Edit by Ram.
  Flushed IR1-TOP-LEVEL-FOR-EVAL and changed IR1-TOP-LEVEL to take a FOR-VALUE
  flag so that it can do the same thing.  Added use of WITH-IR1-NAMESPACE.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
19-Jan-90 21:43:20, Edit by Ram.
  Made SUB-COMPILE-FILE bind *CURRENT-COOKIE* so that people can randomly call
  (POLICY NIL ...) to get at the current policy, and will never see any
  leftover local policy from a dynamically enclosing IR1 conversion.
  ### Maybe this should really be bound somewhere else, like COMPILE-COMPONENT.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
19-Jan-90 22:00:35, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/node.lisp
19-Jan-90 22:01:47, Edit by Ram.
  Added a keyword constructor for CBLOCK, and changed all MAKE-BLOCK calls
  outside of IR1 conversion to use this new constructor, specifying all the
  values that would otherwise be defaulted from specials.  This is necessary to
  make stuff properly reentrant.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
19-Jan-90 17:26:17, Edit by Ram.
  In FIND-FREE-VARIABLE, flushed the assertion that non-constant variables
  never have constant values.  This isn't really right, but it is better.
  ### Really, the implementation of "constant but value unknown" variables
  should be either flushed or redone.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval-comp.lisp
19-Jan-90 15:31:33, Edit by Ram.
  New file from Chiles.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/eval.lisp
19-Jan-90 15:30:03, Edit by Ram.
  New file from chiles.  Changed MY-EVAL to INTERNAL-EVAL and made it frob
  *ALREADY-EVALED-THIS*.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
19-Jan-90 14:53:28, Edit by Ram.
  Made IR1 conversion reentrant by having IR1-TOP-LEVEL bind all of the state
  variables.  Removed DEFVAR initial values for variables that should never be
  referenced outside of IR1 conversion.  Rather than always making four new
  hashtables every time, I kept around the global values, allowing them to be
  used on the outermost call.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
19-Jan-90 11:06:50, Edit by Ram.
  Changed PROPAGATE-TO-REFS to do nothing when the variable type is a function
  type so that we don't lose specific function type information, and also so
  that TYPE-INTERSECTION doesn't gag.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
19-Jan-90 11:24:07, Edit by Ram.
  Changed PROCESS-TYPE-DECLARATION to quietly set the var type when either the
  old or new type is a function type, rather than losing trying to do
  TYPE-INTERSECTION.
  ### Someday when we have a incompatible-redefinition detection capability, we
  might want to hook it in here.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
18-Jan-90 16:45:20, Edit by Ram.
  In %DEFMACRO IR1 convert, when #+NEW-COMPILER, coerce the expander to a
  function before sticking it in the MACRO-FUNCTION.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
18-Jan-90 14:11:44, Edit by Ram.
  Changed %DEFUN translator to dump an inline expanion when appropriate.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/fndb.lisp
18-Jan-90 12:33:17, Edit by Ram.
  Added %STANDARD-CHAR-P and %STRING-CHAR-P to the imports list. 

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/globaldb.lisp
18-Jan-90 12:24:34, Edit by Ram.
  In #+NEW-COMPILER, added info type defaults that get information from the
  environment.  This only affected functions and constant values, since
  everything else is already stored in the global database.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
18-Jan-90 11:51:45, Edit by Ram.
  In COMPILE-FILE, fixed FROB to always pathnamify the thing so that
  OPEN-FASL-FILE won't choke.  Also, this way any syntax error always happens
  in COMPILE-FILE.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/life.lisp
18-Jan-90 10:44:11, Edit by Ram.
  And also in NOTE-CONFLICTS, fixed the declaration for Live-List to be
  (OR TN NULL) rather than TN.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/life.lisp
18-Jan-90 10:39:41, Edit by Ram.
  In NOTE-CONFLICTS, fixed the type for Live-Bits to be LOCAL-TN-BIT-VECTOR,
  not SC-BIT-VECTOR.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
17-Jan-90 20:47:37, Edit by Ram.
  Fixed IR2-CONVERT-NORMAL-LOCAL-CALL to set up the argument pointer.  It
  seems this was only happening in tail calls, so stack arguments did not in
  general work in local calls.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
17-Jan-90 16:20:28, Edit by Ram.
  Changed FIND-TEMPLATE to guard the unsafe policy "trusting" result test by a
  check for any non-null value of TYPE-CHECK, rather than just T or :ERROR.
  This since the value might have also been :NO-CHECK, this was usually
  preventing us from believing the assertion.

  This was resulting in the rather baffling efficiency note that output type
  assertions can't be trusted in a safe policy, when the policy wasn't safe...
  I added an assertion that the policy really is safe when we emit that note.
  Although it should always be the case, lossage in either VALID-FUNCTION-USE
  or template selection could cause us to end up in that branch.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/globaldb.lisp
16-Jan-90 21:25:42, Edit by Ram.
  Renamed the types ENTRY-INFO and ENTRIES-INDEX to be COMPACT-INFO-ENTRY and
  COMPACT-INFO-ENTRIES-INDEX.  We already had a structure called ENTRY-INFO.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/proclaim.lisp
16-Jan-90 11:23:51, Edit by Ram.
  Set the symbol-function of PROCLAIM to the definition of %PROCLAIM.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
16-Jan-90 11:15:56, Edit by Ram.
  Fixed DEFMACRO ir1 convert to unquote the original arglist before setting the
  FUNCTIONAL-ARG-DOCUMENTATION.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/codegen.lisp
15-Jan-90 13:04:59, Edit by Ram.
  Oops...  I seem to have broken codegen when I changed to it give each block a
  label, sometimes emitting a label more than once.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
13-Jan-90 13:09:05, Edit by Ram.
  Changed DELETEF-IN and PUSH-IN to use FOO-GET-SETF-METHOD rather than
  GET-SETF-METHOD so that they will expand correctly in the bootstrapping
  environment.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
13-Jan-90 12:27:12, Edit by Ram.
  Fixed a CDR circularity detection in FIND-SOURCE-PATHS a bit.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/globaldb.lisp
13-Jan-90 11:49:48, Edit by Ram.
  In addition to initializing *INFO-CLASSES* in GLOBALDB-INIT for benefit of
  bootstrapping, we must also init *TYPE-COUNTER* and *TYPE-NUMBERS*.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/globaldb.lisp
12-Jan-90 16:15:25, Edit by Ram.
  Changed to use a special FIND-TYPE-INFO function instead of FIND, since the
  slot accessor TYPE-INFO-NAME isn't avaliable for use as a funarg before
  top-level forms run.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/globaldb.lisp
11-Jan-90 11:14:44, Edit by Ram.
  I'm sooo embarrassed...  I got the rehashing algorithm wrong in compact
  environments.  The second hash could be 0, resulting in infinite looping.
  [b.t.w., this is a new largely rewritten version of globaldb that uses
  special hashtables instead of standard hashtables.  There are two kinds of
  environments: volatile and compact.  Volatile environments can be modified,
  but are not especially compact (comparable to the old hashtable
  implementation, but faster.)  Compact environments are not modifiable, but
  reduce memory usage by at least half.]

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
10-Jan-90 12:04:33, Edit by Ram.
  Rather than asserting that (INFO FUNCTION WHERE-FROM <name>) is :ASSUMED
  whenever the LEAF-WHERE-FROM is assumed, we just quietly skip the unknown
  function warning code when the name no longer names an assumed function.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
10-Jan-90 11:27:03, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
10-Jan-90 11:24:07, Edit by Ram.
  Added special-case top-level form processing of EVAL-WHEN, PROGN and MACROLET
  so that we don't get huge compilations when these forms enclose lots of code
  at top-level.  To do this, I split off the environment manipulation code in
  EVAL-WHEN and MACROLET.
  ### Probably should expand macros to see if they turn into a magic form
  ### before just compiling the thing.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
09-Jan-90 13:23:41, Edit by Ram.
  Wrote a version of PROGV.  This IR1 translator is in IR2tran because it goes
  directly from syntax to shallow-binding primitives.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
08-Jan-90 14:39:46, Edit by Ram.
  Made FIND-SOURCE-PATHS hack circular source code.  CAR circularities are
  detected by noticing that the cons is already in the source paths hashtable.
  CDR circularities are detected using the two-phase trailing pointer hack.
  This support is necessary as long as circular constants are allowed (which is
  strongly implied by the presence of the #=/## read syntax.)  Of course if
  there is circular evaluated code, bad things will still happen...

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
08-Jan-90 13:36:03, Edit by Ram.
  Made PRINT-SUMMARY print information about compilation units that were
  aborted, and inhibited printing of unknown function warnings when the warning
  compilation unit is unwound.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
08-Jan-90 10:58:02, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
08-Jan-90 10:49:04, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/node.lisp
08-Jan-90 10:28:23, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1final.lisp
08-Jan-90 10:40:20, Edit by Ram.
  Changed *UNKNOWN-FUNCTIONS* a bit.  Now it is a list of UNKNOWN-FUNCTION
  structures.  This was done primarily to allow the number of warnings to be
  limited in IR1-CONVERT-OK-COMBINATION-FER-SHER rather than in PRINT-SUMMARY.
  It turns out that recording hundreds of error locations for tents of
  functions can suck down a large amount of memory.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
05-Jan-90 16:24:40, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
05-Jan-90 15:58:34, Edit by Ram.
  Changed *UNKNOWN-FUNCTIONS* to be an alist with one entry for each name, with
  the value being a list of all the error contexts for the calls.  Made
  PRINT-SUMMARY print the undefined function warnings sorted by name, limiting
  the number of warnings per function to *UNKNOWN-FUNCTION-WARNING-LIMIT*.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
05-Jan-90 15:51:31, Edit by Ram.
  Changed PRINT-SUMMARY to print a warning for each unknown function.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
05-Jan-90 15:46:02, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1final.lisp
05-Jan-90 15:45:49, Edit by Ram.
  Moved detection of unknown function calls to
  IR1-CONVERT-OK-COMBINATION-FER-SHER so that we can conveniently note the
  error context each time around.  *UNKNOWN-FUNCTIONS* is now a list of conses
  (Name . Compiler-Error-Context), with entries for each call to an unknown
  function.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
05-Jan-90 15:22:04, Edit by Ram.
  Split off error context determination from error printing by introducing the
  COMPILER-ERROR-CONTEXT structure.  The current error context can now be saved
  for future use by calling FIND-ERROR-CONTEXT.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/debug-dump.lisp
04-Jan-90 10:56:42, Edit by Ram.
  New file.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
04-Jan-90 10:39:31, Edit by Ram.
  Put in hooks for dumping debug info.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/entry.lisp
03-Jan-90 15:04:07, Edit by Ram.
  Added code to dump the arg documentation.  For now, we do pretty much what
  the old compiler did, i.e. printing it to a string.
  ### Eventually, we may want to put in code to flush package qualifiers on the
  variable names and omit complex default forms.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/node.lisp
03-Jan-90 14:44:54, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
03-Jan-90 14:50:15, Edit by Ram.
  Added FUNCTIONAL-ARG-DOCUMENTATION slot and made IR1 conversion set it.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/node.lisp
03-Jan-90 14:34:44, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
03-Jan-90 14:34:27, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/debug.lisp
03-Jan-90 14:40:06, Edit by Ram.
  Added LAMBDA-OPTIONAL-DISPATCH and made IR1 conversion set it in :OPTIONAL
  lambdas.  Made consistency checker allow this.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
03-Jan-90 14:07:30, Edit by Ram.
  In DELETE-OPTIONAL-DISPATCH, don't clear the ENTRY-FUNCTION in the :OPTIONAL
  lambdas.  This info is now kept in the LAMBDA-OPTIONAL-DISPATCH slot, and is
  not cleared when the lambda stops being an entry point.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/dfo.lisp
03-Jan-90 10:35:50, Edit by Ram.
  But we still want to compute the component name in such components...

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/dfo.lisp
03-Jan-90 09:27:51, Edit by Ram.
  Changed FIND-INITIAL-DFO to move all components containing a top-level lambda
  to the end of the compilation order, even if there are XEPs.  This does a
  better job of ensuring that environment analysis is done before we compile
  the top-level component which does cross-component references.
  ### This probably still loses in some pathological case.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
02-Jan-90 17:01:46, Edit by Ram.
  Fixed CLEAR-IR2-INFO to check whether there is a tail set before attempting
  to clear its INFO.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
02-Jan-90 14:51:46, Edit by Ram.
  Changed IR2-CONVERT-CLOSURE to not use the IR2-ENVIRONMENT-ENVIRONMENT, since
  this is now blown away after the component is compiled.  Instead we use the
  ENVIRONMENT-CLOSURE, which is just as good.  Actually, this should only
  happen with references in XEPs, since that is the only kind of function that
  can reference functions across component boundaries.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
17-Dec-89 15:30:10, Edit by Ram.
  Wrote CLEAR-IR2-INFO and made COMPILE-TOP-LEVEL call it after it was done
  with the IR2 for each component.  This should allow the IR2 data structures
  to be reclaimed after each component is compiled, even in a multi-component
  compilation.

  ### Eventually it should be possible for the IR1 to be reclaimed after the
  component is compiled, but there currently cross-component links that inhibit
  this.  It would also cause problems with IR1 consistency checking, since we
  currently need to check all components together.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
15-Dec-89 13:33:44, Edit by Ram.
  In IR1-CONVERT-VARIABLE, when we find a CT-A-VAL, we convert an ALIEN-VALUE
  form rather than referencing the CT-A-VAL as a leaf.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1final.lisp
13-Dec-89 13:38:51, Edit by Ram.
  In NOTE-FAILED-OPTIMIZATION, also inhibit any attempt to give a note if the
  combination is no longer a known call.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/gtn.lisp
12-Dec-89 12:25:57, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
12-Dec-89 12:36:38, Edit by Ram.
  To avoid having to fix this right right now, changed all passing locations to
  be *ANY-PRIMITIVE-TYPE* and added code to do necessary coercions to/from the
  actual variable representation.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/type.lisp
12-Dec-89 10:21:15, Edit by Ram.
  Fixed a bunch of declarations that were calling things TYPEs instead of
  CTYPEs.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
11-Dec-89 10:11:31, Edit by Ram.
  Changed default fasl file extension from "fasl" to "nfasl", at least for now.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/fndb.lisp
11-Dec-89 08:15:47, Edit by Ram.
  Changed most uses of the FUNCTION type to CALLABLE, now that FUNCTION doesn't
  encompass SYMBOL but we can still call them.  Also fixed some lossage where
  someone believed that the SUBSTITUTE/NSUBSTITUTE family of functions had the
  same arguments as the DELETE/REMOVE family.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
10-Dec-89 20:33:05, Edit by Ram.
  Oops...  (fifth x) /==> (nth 5 x), is really (nth 4 x).  So that's why
  PACKAGE-INIT was losing...

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/macros.lisp
10-Dec-89 09:23:47, Edit by Ram.
  Fixed DO-NODES-BACKWARDS to work when the current node is deleted now that
  UNLINK-NODE blasts the PREV.  Also fixed two bugs in this macro that seem not
  to have affected the sole use in FLUSH-DEAD-CODE.  One was that it randomly
  referenced the variable CONT in one place, rather than commaing in the
  appropriate argument.  The other was that it did an extra iteration binding
  CONT to the block start and NODE to whatever its USE was (often NIL.)

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
09-Dec-89 13:31:24, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1final.lisp
09-Dec-89 13:30:52, Edit by Ram.
  Wrote NODE-DELETED and made NOTE-FAILED-OPTIMIZATION call it so that we won't
  gag trying to look at deleted code.  This also prevents bogus efficiency
  notes about code that was actually optimized away.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
09-Dec-89 13:22:39, Edit by Ram.
  Made UNLINK-NODE set the NODE-PREV of the deleted node to NIL so that we can
  recognize deleted nodes.  Also, fixed the degenerate exit branch to add a use
  by EXIT rather than NODE.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/checkgen.lisp
08-Dec-89 11:28:54, Edit by Ram.
  Changed CONVERT-TYPE-CHECK to call LOCAL-CALL-ANALYZE now that this is not
  being done in COMPILE-COMPONENT.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
08-Dec-89 11:24:13, Edit by Ram.
  Fixed PROPAGATE-FUNCTION-CHANGE to call MAYBE-LET-CONVERT in addition to
  COMVERT-CALL-IF-POSSIBLE so that IR1 optimize will let convert calls that it
  discovers can be local.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/vop.lisp
08-Dec-89 10:58:23, Edit by Ram.
  Looks like when I made OLD-CONT and RETURN-PC environment TNs (and requiring
  the IR2-ENVIRONMENT-SLOTS to be initialized after the environment was
  created), I modified the wrong slots to allow NIL.  Only detected now because
  I was running with safe defstruct accessors.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/debug.lisp
08-Dec-89 09:58:33, Edit by Ram.
  IR1 invariants now a bit different: :DELETED continuations can only be
  received by blocks with DELETE-P set, and blocks with DELETE-P set can have
  no successors. 

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/locall.lisp
08-Dec-89 09:51:24, Edit by Ram.
  Don't attempt to let-convert when the REF is in a block with DELETE-P set

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
08-Dec-89 09:50:13, Edit by Ram.
  Don't attempt to do IR1 optimizations when the block has DELETE-P set, just
  delete it instead.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
08-Dec-89 09:46:20, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/node.lisp
08-Dec-89 09:51:26, Edit by Ram.
  Added BLOCK-DELETE-P and made DELETE-CONTINUATION set it in the DEST block
  and its predecessors.  Changed most uses of DELETE-CONTINUATION to assert
  that there isn't a DEST.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
07-Dec-89 22:08:35, Edit by Ram.
  In IR1-OPTIMIZE-IF, set COMPONENT-REANALYZE before UNLINK-NODE so that there
  is still a component in the block.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
07-Dec-89 21:17:43, Edit by Ram.
  In IR1-CONVERT-OK-COMBINATION-FER-SHER, set the CONTINUATION-%DERIVED-TYPE
  and CONTINUATION-TYPE-CHECK of the fun cont in addition to setting
  CONTINUATION-REOPTIMIZE.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
07-Dec-89 21:08:09, Edit by Ram.
  Moved definitions of the arithmetic & logic functions %LDB et al. here from
  eval.lisp, since we need them in the bootstrapping environment.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
07-Dec-89 19:17:48, Edit by Ram.
  Changed USE-CONTINUATION not to set the CONTINUATION-%DERIVED-TYPE, as this
  inhibits CONTINUATION-DERIVED-TYPE from seeing whether the assertion needs to
  be intersected, etc.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
07-Dec-89 18:55:32, Edit by Ram.
  Changed IR1-OPTIMIZE to more explicitly ignore a block when it is directly
  deleted due to :DELETED kind or no predecessors.  The old code should have
  realized not to optimize a deleted block, but in a rather obscure way.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
07-Dec-89 13:25:38, Edit by Ram.
  Changed IR1-OPTIMIZE-UNTIL-DONE to count the number of iterations that didn't
  introduce any new code (set COMPONENT-REANALYZE) rather than just the total
  number of iterations.  Reduced MAX-OPTIMIZE-ITERATIONS to 3, since we now
  don't have to worry so much about the results of transforms being adequately
  optimized.  Changed IR1-PHASES to call GENERATE-TYPE-CHECKS where it was
  calling CHECK-TYPES.  Flushed old call to GENERATE-TYPE-CHECKS in
  COMPILE-COMPONENT.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
07-Dec-89 13:24:20, Edit by Ram.
  Changed IR1-OPTIMIZE-IF to set COMPONENT-REANALYZE if it does anything.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/checkgen.lisp
07-Dec-89 12:56:18, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
07-Dec-89 12:28:19, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
07-Dec-89 13:01:31, Edit by Ram.
  Changed type checking around a bunch, fixing some bugs and inefficiencies.
  The old CHECK-TYPES phase is gone.  The determination of
  CONTINUATION-TYPE-CHECK is now done on the fly by CONTINUATION-DERIVED-TYPE.
  The compile-time type error detection has been moved into type check
  generation.  Type check generation is now driven by BLOCK-TYPE-CHECK, so it
  doesn't have to look at everything on repeat iterations.  Made
  ASSERT-CONTINUATION-TYPE set BLOCK-TYPE-CHECK when there is a new assertion.

  There are two new values of TYPE-CHECK: :ERROR and :NO-CHECK.  These are used
  by check generation to comminicate with itself and the back end.  :ERROR
  indicates a compile-time type error, which always causes a type check to be
  emitted, regardless of policy.  :NO-CHECK indicates that a check is needed,
  but expected not to be generated due to policy or a safe implementation.
  This inhibits LTN from choosing an unsafe implementation based on results of
  new type information from the post-type-check optimization pass.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/type.lisp
07-Dec-89 10:01:23, Edit by Ram.
  Yep, that combined with a bug in how I hooked CTYPEP into TYPES-INTERSECT.
  That function should return (VALUES T NIL) in the uncertain case, not
  (VALUES NIL NIL).

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/type.lisp
07-Dec-89 09:54:44, Edit by Ram.
  Fixed CTYPEP to return the second value T when it calls TYPEP.  Is this what
  is causing all hell to break loose?  It shouldn't, since it should just
  result in increased type uncertainty.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/proclaim.lisp
06-Dec-89 21:24:00, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/macros.lisp
06-Dec-89 21:26:24, Edit by Ram.
  Added support for the DEBUG-INFO optimization quality (DEBUG for short).

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/type.lisp
06-Dec-89 11:25:36, Edit by Ram.
  Made CTYPEP return a second value indicating whether it was able to determine
  the relationship.  Made all callers look at the second value and propagate
  the uncertainty.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/proclaim.lisp
06-Dec-89 11:11:06, Edit by Ram.
  Moved the actual establishing of the type definition to %%COMPILER-DEFSTRUCT
  from %DEFSTRUCT.  Part of this was actually duplicated both places.  Now it
  is only here.  Hopefully this won't cause any initialization problems.  Also,
  made structure redefinition preserve the INCLUDED-BY list so that existing
  structures won't suddenly be broken when the supertype is compiled.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
06-Dec-89 10:43:21, Edit by Ram.
  Changed PROCESS-TYPE-PROCLAMATION to call SINGLE-VALUE-TYPE so that we don't
  try to call TYPE-INTERSECTION on a hairy function type (or make the type of a
  variable, for all that matter.)

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
05-Dec-89 13:42:19, Edit by Ram.
  Made NCOMPILE-FILE frob *DEFAULT-COOKIE* so as to make optimize proclamations
  affect only the file that they appear in (and any compilations dynamically
  enclosed in that file.)

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
04-Dec-89 09:38:18, Edit by Ram.
  Flushed :SEMI-INLINE and :ALWAYS-INLINE values for INLINEP.  Added
  :MAYBE-INLINE, which is interpreted in a more advisory manner.  Changed 
  IR1-CONVERT-GLOBAL-INLINE so that it does something like the old
  :SEMI-INLINE case for all inline calls so that recursive functions can be
  INLINE.

  Fixed this code so that you really can have recursive inline functions.  This
  was supposedly supported for :SEMI-INLINE functions, but did not in fact
  work.  We do a hack similar to LABELS: we enter a dummy FUNCTIONAL in the
  *FREE-FUNCTIONS* to prevent repeated attempts to convert the expansion.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
03-Dec-89 15:03:48, Edit by Ram.
  Defined SAME-LEAF-REF-P and made transforms for EQ, EQL, < and > use it to
  see if both args are references to the same variable or functional or
  whatever.  Also use the EQ transform for CHAR= and EQUAL.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
02-Dec-89 09:26:12, Edit by Ram.
  Made MAX-OPTIMIZE-ITERATIONS be a ceiling on the number of times that
  IR1-OPTIMIZE-UNTIL-DONE will iterate.  If exceeded, we clear a bunch of
  REOPTIMIZE flags and punt.  This was made necessary by the addition of type
  inference on set variables, which may take arbitrarily long to converge.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
01-Dec-89 14:05:10, Edit by Ram.
  Added code to compute the type of set LET variables as the union of the types
  of the initial value and the set values.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/checkgen.lisp
01-Dec-89 12:11:57, Edit by Ram.
  Added code to check to see if it is cheaper to check against the difference
  between the proven type and the assertion.  If so, emit a check against the
  negation of this difference.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
01-Dec-89 09:04:37, Edit by Ram.
  Wrote IR1 transforms for < and > that attempt to statically determine the
  relationship using type information.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/type.lisp
01-Dec-89 10:06:56, Edit by Ram.
  Wrote TYPE-DIFFERENCE.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
30-Nov-89 12:04:24, Edit by Ram.
  Marked the error signalling funny functions as not returning by using
  TRULY-THE NIL.  Formerly this was subverting type inference, since the
  primitive was considered to return *.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
30-Nov-89 11:52:27, Edit by Ram.
  Made SUBSTITUTE-CONTINUATION-USES do a REOPTIMIZE-CONTINUATION on the New
  continuation so that we realize we need to recompute its type, etc.  This was
  seriously crippling type inference.  It probably came unglued in let
  conversion when we changed over to using the general substitute function.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
30-Nov-89 11:31:00, Edit by Ram.
  Changed FIND-FREE-VARIABLE to find the type of constants having values with
  CTYPE-OF, rather than using INFO VARIABLE TYPE.  This way we find a good type
  for all constants, without interacting with the vagaries of environment query.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
30-Nov-89 10:50:37, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/locall.lisp
29-Nov-89 13:14:40, Edit by Ram.
  Moved merging of tail sets from CONVERT-CALL to IR1-OPTIMIZE-RETURN.  The old
  code wasn't working because IR1 optimizations (such as deleting local EXITs)
  could cause a local call to be tail-recursive yet the function would never
  get added to the tail set because it had already been converted.

  Inaccurate computation of the tail sets resulted in bad code problems, since
  functions were returning in ways not expected by their callers.

  ### This code still isn't quite right, since IR1 optimization is supposed to
  be optional.  One possible fix would be to do tail annotation in IR1
  optimization, but then you would have to run IR1 optimize to get proper tail
  recursion.  This might not be much of an issue, since we will probably always
  want to do at least some IR1 optimization. 

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
27-Nov-89 12:35:17, Edit by Ram.
  Fixed a braino in mask computation in the %DPB, %MASK-FIELD and
  %DEPOSIT-FIELD transforms.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/fndb.lisp
26-Nov-89 15:28:27, Edit by Ram.
  Fixed MACRO-FUNCTION def to specify a result type of (OR FUNCTION NULL),
  rather than just FUNCTION.  This was disabling the use of this function as a
  predicate to test whether a symbol names a macro.  Also fixed the argument
  order to REPLACE.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
25-Nov-89 22:44:32, Edit by Ram.
  Fixed RPLACx transforms to return the right value.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/type.lisp
22-Nov-89 19:27:58, Edit by Ram.
  Fixed the definition of STRING-CHAR so that it wouldn't seem to be a subtype
  of STANDARD-CHAR.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/seqtran.lisp
22-Nov-89 14:31:40, Edit by Ram.
  In MAPPER-TRANSFORM, I seem to have inverted the sense of the exit test when
  converting from CONSP to ENDP.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
21-Nov-89 16:51:31, Edit by Ram.
  Moved GTN before control analysis so that the IR2-Environment is allocated by
  the time that control analysis runs.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/control.lisp
21-Nov-89 16:38:24, Edit by Ram.
  Moved to ADD-TO-EMIT-ORDER the adding of IR2-Blocks to the
  IR2-ENVIRONMENT-BLOCKS.  This way, overflow blocks created by conflict
  analysis will appear in this list.  TNs only live in overflow blocks were
  being considered not to conflict with :ENVIRONMENT TNs.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/stack.lisp
21-Nov-89 16:34:05, Edit by Ram.
  Made DISCARD-UNUSED-VALUES make an IR2 block for the cleanup block and call
  ADD-TO-EMIT-ORDER on it.  I think that if this code ever ran, it would have
  died.  This code was tested at one point, so it was probably broken by the
  move of control analysis to before all the other IR2 pre-passes.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/tn.lisp
21-Nov-89 14:43:29, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/gtn.lisp
21-Nov-89 14:51:36, Edit by Ram.
  Wrote MAKE-WIRED-ENVIRONMENT-TN so that the save TNs for old-cont and
  return-pc could be made environment-live.  Made ASSIGN-IR2-ENVIRONMENT pass
  the environment to MAKE-xxx-SAVE-TN so that they could make environment-live
  TNs.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/assembler.lisp
20-Nov-89 08:58:31, Edit by Ram.
  In NEW-LOGIOR-ARGUMENT, added code to check that the SB for :REGISTER
  operands is really REGISTERS.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
20-Nov-89 08:29:42, Edit by Ram.
  In EMIT-MOVE, added code to emit a type error when moving between
  incompatible TNs.  It seems that this can happen with functions (especially
  funny functions) that don't return.  This seems like a good fix until we can
  figure out how to hack the flow graph when there is a non-returning function.
  [Incompatible moves may also happen if there is a compile-time type error and
  the check is deleted due to unsafe policy, etc.]

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/fndb.lisp
17-Nov-89 15:06:51, Edit by Ram.
  Changed %PUT's IR1 attributes from (FLUSHABLE) to (UNSAFE).

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
17-Nov-89 10:12:48, Edit by Ram.
  Fixed some missing commas in SOURCE-TRANSFORM-TRANSITIVE that only affected
  LOGEQV.  Good thing nobody uses it...

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/vmdef.lisp
16-Nov-89 09:42:37, Edit by Ram.
  Fixed previous fix to work when there is a more result.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/vmdef.lisp
15-Nov-89 13:57:36, Edit by Ram.
  In TEMPLATE-TYPE-SPECIFIER, if we use a values type for the result, make it
  &REST T to represent the vagueness of values count matching.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
15-Nov-89 09:57:48, Edit by Ram.
  Added missing source transform for LOGEQV, which was missed in the previous
  pass.  This required changing SOURCE-TRANSFORM-TRANSTIVE, since that was
  already a source transform for LOGEQV.  It's a good thing I left in *both*
  checks for broken interpreter stubs.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
14-Nov-89 10:41:51, Edit by Ram.
  Added source transforms for zillions of trivial logic operations that were
  missing.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
14-Nov-89 10:43:24, Edit by Ram.
  In %DEFUN, added the presence of an IR2-CONVERT methods to the list of things
  that inhibits substitution of the actual definition for existing references.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/srctran.lisp
13-Nov-89 12:21:52, Edit by Ram.
  Added source transforms for RPLACA, RPLACD.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
13-Nov-89 12:17:32, Edit by Ram.
  Moved the test of NODE-REOPTIMIZE out of FIND-RESULT-TYPE and into
  IR1-OPTIMIZE-RETURN.  This fixes a bug that was introduced when the clearing
  of NODE-REOPTIMIZE was moved to the start of the loop in IR1-OPTIMIZE-BLOCK.
  We were never recomputing the RETURN-RESULT-TYPE, since REOPTIMIZE was never
  set when we got to IR1-OPTIMIZE-RETURN.  With this fix, the previous change
  should detect broken interpreter stubs.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1final.lisp
12-Nov-89 13:05:49, Edit by Ram.
  Made CHECK-FREE-FUNCTION give a note when it sees a function that doesn't
  return (return type is NIL.)  I thought that this would detect broken
  interpreter stubs.  It turns out not to, but still seems like a useful
  feature.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
13-Nov-89 11:47:30, Edit by Ram.
  Made LTN-ANALYZE-KNOWN-CALL give a warning when we are unable to find a
  template for a known call where there call is to the current function.  This
  should tell result in a warning when we compile an interpreter stub for a
  function that the code sources assume is implemented primitively, but the
  compiler doesn't recognize.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
12-Nov-89 10:54:25, Edit by Ram.
  Oops...  When doing unsafe global function references, use
  FAST-SYMBOL-FUNCTION, not FAST-SYMBOL-VALUE.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/main.lisp
10-Nov-89 13:37:15, Edit by Ram.
  Oops...  Have to dump package frobbing forms specially for cold load.  This
  might want to be on a switch someday.  Instead of actually compiling them, we
  dump them as lists so that Genesis can eval them.  The normal top-level form
  compilation must be suppressed, since the package system isn't initialized at
  the time that top-level forms run.
  
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/dfo.lisp
05-Nov-89 13:45:11, Edit by Ram.
  Changed FIND-INITIAL-DFO to return top-level components at the end of the
  list so that in a block compilation all the functions will be compiled before
  we compile any of the top-level references to them.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/envanal.lisp
01-Nov-89 11:57:58, Edit by Ram.
  Changed Find-Non-Local-Exits back to a loop over all the blocks in the
  component, rather than trying to find the exits from the Lambda-Entries.
  Unfortunately, the latter is not possible, since the exit continuation may
  become deleted if it isn't used.  A possible way to avoid this search would
  be to make the Entry node have a list of all the Exit nodes, rather than the
  continuations.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/vop.lisp
31-Oct-89 12:45:20, Edit by Ram.
  Allow (SETF xxx) for the Entry-Info-Name, in addition to strings and symbols.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
31-Oct-89 12:53:37, Edit by Ram.
  In Find-Source-Context, only take the car of list first args to DEFxxx forms
  when the form name is in a special list.  This list initially only contains
  DEFSTRUCT.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
31-Oct-89 12:23:57, Edit by Ram.
  In Convert-More-Entry, made the temporaries for the keyword and value
  ignorable so that we don't get "defined but never read" warnings when there
  aren't any keywords specified.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
31-Oct-89 12:11:24, Edit by Ram.
  Fixed Process-Declarations to correctly deal with pervasive special
  declarations.  Previously, a warning would be given if the varible was only
  locally declared, and not globally known.  Also an assertion failure would
  have resulted (rather than a Compiler-Error) when a constant was declared
  pervasively special.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
31-Oct-89 11:39:54, Edit by Ram.
  Changed Reference-Constant so that it doesn't call Reference-Leaf anymore,
  and made the source be an explicit argument.  Changed Reference-Leaf to just
  use the Leaf-Name as source, rather than (sometime incorrectly) inferring the
  source for constants.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
20-Oct-89 15:56:56, Edit by Ram.
  In the :UNKNOWN and :UNUSED cases of CONTINUATION-RESULT-TNS, always return
  TNs of the specified result types, rather than sometimes returing T TNs.
  This is some sort of compensation for our new belief that VOPS returining
  non-T results need not be prepared to accept T TNs.  How many other places
  does this need to be fixed?

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/stack.lisp
17-Oct-89 12:36:38, Edit by Ram.
  In FIND-PUSHED-CONTINUATIONS, fix the check for pushes coming before pops.
  You can compare nodes and continuations all day without finding any that are
  EQ.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/macros.lisp
17-Oct-89 11:44:40, Edit by Ram.
  Flushed the code in DEFTRANSFORM that was creating a THE out of the CONT's
  asserted type.  This should be unnecessary, and was made incorrect by the
  continuation representation change.  If the node was the last in a block and
  the value wasn't used, then the value would be asserted to be of the NIL
  type, resulting in a warning. 

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
17-Oct-89 10:51:27, Edit by Ram.
  Changed Compiler-Mumble to tell whether an error message precedes from
  *last-format-string*, rather than *last-source-context*, since the last
  message might not have had a source context.  Made *compiler-error-output* be
  globally bound to a synonym stream for *error-output* so that calls to
  Compiler-Error outside of the compiler will more or less work.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/checkgen.lisp
16-Oct-89 15:23:13, Edit by Ram.
  In Convert-Type-Check, set the start & end cleanups of the new block to the
  *start* cleanup of the Dest's block, and not the end cleanup.  Not sure this
  is really more correct, but it fixes one case.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/pack.lisp
12-Oct-89 14:05:43, Edit by Ram.
  Added a before-GC hook that flushes the per-SB conflict data structure
  whenever they aren't being used.  This should prevent megabyte-plus conflicts
  information from persisting after it is needed, and also reduce the cost of
  Init-SB-Vectors, since the vectors will stay smaller.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
11-Oct-89 11:37:16, Edit by Ram.
  Made Propagate-Function-Change ignore references that are :Notinline.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
10-Oct-89 23:28:33, Edit by Ram.
  In Print-Error-Message, use the *Current-Form* as the source form whenever if
  is non-NIL, even if there is a node in *Compiler-Error-Context*.  This way,
  messages during IR1 conversion of a transform will be more useful.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
10-Oct-89 22:47:56, Edit by Ram.
  Now Delete-Optional-Dispatch must be prepared for the main entry to be a let
  rather than just being deleted or a normal function, since let conversion is
  being triggered here.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/locall.lisp
09-Oct-89 17:56:35, Edit by Ram.
  Fixed Convert-Call to change the combination kind before changing the ref
  leaf so that the call will appear local at that time.  This allows let
  conversion to happen when we replace a optional dispatch with one of its EPs.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
09-Oct-89 17:34:42, Edit by Ram.
  Fixed Delete-Optional-Dispatch to call Maybe-Let-Convert if we notice that a
  former EP lambda has exactly one reference.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
04-Oct-89 19:05:16, Edit by Ram.
  In IR1-Optimize-Combination, we must be prepared for the derive-type method
  to return NIL.  This will happen if the arglist is incompatible with the
  call (and if the optimizer explicitly returns NIL.)

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/macros.lisp
04-Oct-89 19:22:17, Edit by Ram.
  Check-Transform-Keys and Check-Keywords-Constant were checking the second
  (value) part of the key/value pair, so optimizers would never run if any
  keywords were supplied.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
04-Oct-89 15:39:27, Edit by Ram.
  When I changed Propagate-Local-Call-Args to clear the Continuation-Reoptimize
  flags, I forgot that a local call continuation can be NIL (for an unused
  argument.) 

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
04-Oct-89 11:05:48, Edit by Ram.
  Oops...  In Propagate-Function-Change, we have to use
  Continuation-Derived-Type rather than Continuation-Type now that the latter
  changes function types to FUNCTION.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/globaldb.lisp
27-Sep-89 14:24:04, Edit by Ram.
  Exported basic interface (but not environment vars, pending some abstract
  interface to environment manipulation.)  Changed class and type names to be
  represented as strings at run time to avoid package lossage.  Changed names
  to be arbitrary equal objects (to allow setf functions).

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
21-Sep-89 10:12:38, Edit by Ram.
  Changed OK-Result-TN to indicate need for a coercion if the result is unboxed
  and the TN is boxed.  This prevents load-TN packing from getting confused due
  to there being no intersection between the SC restriction and the types
  allowed by the SC.  This would happen when the result was restricted to a
  non-descriptor SC.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
21-Sep-89 10:39:04, Edit by Ram.
  Changed Restrict-Descriptor-Args to restrict the argument only when a
  coercion was required.  This allows immediate objects to be passed to
  templates in unboxed registers.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
30-Aug-89 14:37:36, Edit by Ram.
  Changed Change-Leaf-Ref (and hence Substitute-Leaf) to use Derive-Node-Type
  on the Ref with the Leaf-Type so that substituting a variable causes the new
  type to be noticed. 

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
30-Aug-89 14:30:44, Edit by Ram.
  Changed IR1-Optimize-Block and all the combination optimization code to clear
  optimize flags *before* optimizing rather than after, so that a node will be
  reoptimized if necessary.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/vmdef.lisp
29-Aug-89 09:20:18, Edit by Ram.
  Made Template-Type-Specifier hack *'s in operand type restrictions.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
24-Aug-89 13:55:04, Edit by Ram.
  In LTN-Analyze-MV-Call, have to annotate the continuations in reverse order,
  now that the IR2-Block-Popped isn't built in reverse order.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
24-Aug-89 13:25:14, Edit by Ram.
  In LTN-Analyze, eliminated assertion that the block containing the use of a
  unknown-values continuation is not already in the
  IR2-Component-Values-Generators.  It is possible for a single block to
  contain uses of several MV continuations that have their DEST in a different
  block.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/dfo.lisp
22-Aug-89 12:12:49, Edit by Ram.
  Made Find-Initial-DFO-Aux call Walk-Home-Call-Graph on each block before
  walking the successors.  Walk-Home-Call-Graph is a new function that looks at
  the current block's home lambda's bind block to see if it is in a different
  component.  We need to do this to ensure that all code in a given environment
  ends up in the same component, since any successor might be a non-local exit
  (into a different environment.)  

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
18-Aug-89 15:46:51, Edit by Ram.
  Flushed the (locally (declare (optimize (safety 0))) ...) around the body of
  Unwind-Protect's expansion.  I think that this was trying to suppress some
  type checking of the MV-Bind, but it was also causing unsafe compilation of
  the protected form.  If we really need this, it must be but back some other
  way.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
18-Aug-89 15:11:13, Edit by Ram.
  Oops...  We can't use Label-Offset in the generators for Make-Catch-Block,
  &c.  Instead, we use a :Label load-time constant.  The target argument to the
  VOPs is now a normal integer argument, rather than a label in the
  codegen-info.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
18-Aug-89 14:13:51, Edit by Ram.
  In LTN-Analyze-Return, don't annotate NLX continuations as :Unused so that
  the NLX entry code doesn't have to worry about this case.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
18-Aug-89 13:45:19, Edit by Ram.
  In Reoptimize-Continuation, don't do anything if the continuation is deleted.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1util.lisp
17-Aug-89 11:17:13, Edit by Ram.
  Oops...  In Node-Ends-Block, have to set the Block-Start-Uses, now that it is
  always supposed to hold the uses of block starts.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
10-Aug-89 10:49:01, Edit by Ram.
  Changed Find-Template to intersect the Node-Derived-Type with the
  Continuation-Asserted-Type rather than using the Continuation-Derived-Type in
  the case where we are allowed to use the result type assertion.  This works
  better when the continuation has multiple uses. 

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/typetran.lisp
24-Jul-89 14:25:09, Edit by Ram.
  Fixed Source-Transform-Union-Typep to check that there really is a MEMBER
  type in the union, instead of assuming there is whenever LIST is a subtype.
  This was losing on (OR SYMBOL CONS).

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/assembler.lisp
19-Jul-89 14:36:10, Edit by Ram.
  Made Init-Assembler nil out the Info slots in all the fixups so that the
  fixup freelist doesn't hold onto the entire IR.  More storage allocation
  lossage has been caused by the explicit freelists in the assembler than
  anything else.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/macros.lisp
12-Jul-89 15:34:09, Edit by Ram.
  Changed defining macros to stick the actual function object into the
  Function-Info &c to be compatible with the new definition of the Function
  type.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
12-Jul-89 12:57:24, Edit by Ram.
  Fixed goof in IR2-Convert-Local-Unknown call, where it was converting the
  result TN list to TN-refs twice.  For some reason, this was dying with a
  highly mysterious error in Reference-TN-List.  Perhaps this file was last
  compiled with an unsafe policy? 

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/life.lisp
11-Jul-89 19:29:05, Edit by Ram.
  In Propagate-Live-TNs, when we convert a :Read-Only conflict to :Live, we
  null the entry in the local TNs to represent the elimination of local
  conflict information.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
11-Jul-89 18:46:17, Edit by Ram.
  Changed %Defun to only substitute the functional when it isn't notinline and
  isn't known to have any templates or transforms.  The latter constraint fixes
  big problems with interpreter stubs.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1tran.lisp
05-Jul-89 22:11:10, Edit by Ram.
  In Return-From, put back code that made Cont start a block so that Cont will
  have a block assigned before IR1-Convert.  So that's why that was there.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
05-Jul-89 18:07:48, Edit by Ram.
  In Annotate-Unknown-Values-Continuation, make a safety note when we delete a
  check and the policy is safe.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir1opt.lisp
05-Jul-89 17:43:18, Edit by Ram.
  In IR1-Optimize-Exit, don't propagate Cont's type to the Value, since this
  moves checking of the assertion to the Exit, which is a bad place.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
05-Jul-89 15:10:34, Edit by Ram.
  In Emit-Return-For-Locs, changed the test for when to use known return
  convention from External-Entry-Point-P to *not* External-Entry-Point-P.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ir2tran.lisp
05-Jul-89 14:41:55, Edit by Ram.
  Oops...  We need a UWP-Entry VOP for Unwind-Protect entries to force random
  live TNs onto the stack.  It doesn't actually do anything, but specifies the
  passing locations as results so that they aren't forced to the stack.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/ltn.lisp
03-Jul-89 16:46:09, Edit by Ram.
/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/stack.lisp
03-Jul-89 16:39:53, Edit by Ram.
  Changed unknown values hackery to ignore non-local exits.  We don't record
  NLX uses of unknown-values continuations as generators, and we stop
  our graph walk when we hit the component root.  These changes were
  necessitated by the decision to make %NLX-Entry no longer use the values
  continuation. 

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/pack.lisp
03-Jul-89 11:31:36, Edit by Ram.
  Fixed one-off error in Pack-Wired-TN's determination of when we have to grow
  the SB, and fixed it to handle SC-Element-Size /= 1 while I was at it.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/locall.lisp
29-Jun-89 12:02:16, Edit by Ram.
  In Local-Call-Analyze-1, moved the test for the reference being by the
  Basic-Combination-Fun to around the entire branch that attempts to convert,
  rather than immediately around the call to Convert-Call-If-Possible.  Before,
  a closure arg to a local function wouldn't get an XEP.

  Also, changed Reference-Entry-Point to ignore references to :Cleanup and
  :Escape functions.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/envanal.lisp
28-Jun-89 16:57:12, Edit by Ram.
  In Emit-Cleanups, if we find there is no cleanup code, then do nothing,
  instead of inserting a cleanup block holding NIL.  This was causing blocks
  with no non-local uses to inhibit tail-recursion.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/checkgen.lisp
28-Jun-89 14:03:45, Edit by Ram.
  It finally happened.  A paren error that resulted in mysterious lossage.  In
  this case, the body of the loop in Make-Type-Check-Form was moved out of the
  loop, and always executed once.  The meant that only one value would ever be
  checked or propagated on to the original receiver.

/afs/cs.cmu.edu/project/clisp/new-compiler/compiler/pack.lisp
28-Jun-89 13:20:59, Edit by Ram.
  Oops...  I introduced a bug in the previously correct argument case of
  Load-TN-Conflicts-In-SB.  We terminate the loop when we reach the first
  reference, not the first argument.  This caused conflicts with temporaries
  with lives beginning at :Load to be ignored.

/usr1/lisp/compiler/pack.lisp, 23-Jun-89 15:54:32, Edit by Ram.
  Fixed logic in Load-TN-Conflicts-In-SB.  We weren't recognizing conflicts
  with other argument/result TNs that had already been packed.  This bug would
  only show up with multiple result load TNs.  The argument case was actually
  correct, but was asymmetrical with the result case, and only worked becase
  argument load TNs were packed in evaluation order.

/usr1/lisp/compiler/locall.lisp, 20-Jun-89 14:53:51, Edit by Ram.
  In Merge-Tail-Sets, quietly do nothing if the called function has no tail set
  (doesn't return), rather than dying.

/usr1/lisp/compiler/globaldb.lisp, 14-Jun-89 10:14:04, Edit by Ram.
  Flushed Top-Level-P attribute.

/usr1/lisp/compiler/macros.lisp, 14-Jun-89 10:14:03, Edit by Ram.
  Allow a doc string in Def-IR1-Translator (made the FUNCTION documentation).
  Removed support for Top-Level-P attribute.

/usr1/lisp/compiler/ir1opt.lisp, 22-May-89 15:30:59, Edit by Ram.
/usr1/lisp/compiler/ir1util.lisp, 22-May-89 15:22:17, Edit by Ram.
  Undid last change to Node-Ends-Block and Join-Blocks.  This was fucking up
  big time, since it messed with the continuation even when it was a block
  start.

/usr1/lisp/compiler/locall.lisp, 22-May-89 13:24:48, Edit by Ram.
  Changed Local-Call-Analyze to maintain the Component-New-Functions exactly up
  to date, only popping a function off exactly as it analyzes it.  This way, a
  lambda is always referenced either in the Lambdas or New-Functions (except
  during a brief window), so we can do consistency checking during local call
  analysis.

/usr1/lisp/compiler/ir1util.lisp, 19-May-89 10:05:28, Edit by Ram.
/usr1/lisp/compiler/ir1opt.lisp, 19-May-89 10:05:27, Edit by Ram.
  In Flush-Dest and Reoptimize-Continuation, take care not to assume that the
  Continuation-Block is an undeleted block.  Instead, we pick up the component
  to reoptimize from the uses or Dest.
  
/usr1/lisp/compiler/ir2tran.lisp, 17-May-89 12:48:35, Edit by Ram.
  In Move-Results-Coerced and Move-Results-Checked, subtract Nsrc from Ndest,
  rather than the other way around.

/usr1/lisp/compiler/control.lisp, 15-May-89 11:53:36, Edit by Ram.
  Made Control-Analyze walk XEPs first to eliminate the idiocy of never getting
  the drop-through in components with only one EP.

/usr1/lisp/compiler/ir1util.lisp, 13-May-89 15:23:28, Edit by Ram.
  And similarly, in Node-Ends-Block, move the last continuation to the new
  block when its block is the old block.

/usr1/lisp/compiler/ir1opt.lisp, 13-May-89 15:02:31, Edit by Ram.
  In Join-Blocks, move the Cont of the Last to Block1 when it's block is
  currently Block2.  This way, the continuation isn't left pointing at some
  random deleted block.

/usr1/lisp/compiler/ir1util.lisp, 14-Mar-89 10:12:04, Edit by Ram.
  Also, in Delete-Block, when we delete a bind, call Delete-Lambda, rather
  than trying to roll our own.

/usr1/lisp/compiler/ir1util.lisp, 14-Mar-89 10:07:01, Edit by Ram.
  In Delete-Lambda, we must remove a let from its home's lets.

/usr1/lisp/compiler/ir1util.lisp, 14-Mar-89 09:34:54, Edit by Ram.
  In Unlink-Node, the assertion that the start and end cleanups are the same
  must use Find-Enclosing-Cleanup, rather than just comparing the values
  directly.

/usr1/lisp/compiler/ir2tran.lisp, 14-Mar-89 08:26:04, Edit by Ram.
  Wrote Flush-Tail-Transfer and made people who do TR stuff use it.  This
  function deletes the link between the blocks for a TR node and the block
  containing the return node.  We have to do this so that lifetime analysis
  doesn't get confused when there are TNs live at the return node, but some
  predecessors of the return don't write the TNs because the return some other
  way.

/usr1/lisp/compiler/srctran.lisp, 10-Mar-89 19:11:51, Edit by Ram.
  Made the transforms into %typep always pass until we do type predicates for
  real.

/usr1/lisp/compiler/assembler.lisp, 10-Mar-89 18:56:45, Edit by Ram.
  Fixed Macrolet of Emit-Label in Def-Branch to have a paren in the right
  place.  As written, it expanded into its argument, and didn't enclose any
  code anyway.  But I think this would only affect instructions that both were
  a branch and had a load-time fixup.

/usr1/lisp/compiler/assembler.lisp, 10-Mar-89 18:47:50, Edit by Ram.
  Added code to Def-Branch in the choose function that calls
  Undefined-Label-Error when the the label isn't defined.  This function uses
  the *assembler-nodes* source info and the branch instruction location to
  print the source node responsible for generating the bogus branch.

/usr1/lisp/compiler/assembler.lisp, 10-Mar-89 17:59:51, Edit by Ram.
  Made Gen-Label initalize the Elsewhere-P slot to :Undecided.  Also made
  Merge-Code-Vectors ignore labels whose Elsewhere-P is undecided.  The theory
  is that it should be o.k. to make labels that aren't emitted as long as you
  don't reference them.  Of course, I will probably find that the losing labels
  are referenced.  Renamed the Location slot in Label to %Location, and defined
  Label-Location to filter out undefined labels.

/usr1/lisp/compiler/ltn.lisp, 10-Mar-89 17:43:39, Edit by Ram.
  In LTN-Analyze-Return, we must check for the Return-Info-Count being :Unknown
  rather than null when we want to know if a fixed number of values are
  returned.

/usr1/lisp/compiler/ir2tran.lisp, 07-Mar-89 18:13:12, Edit by Ram.
  In the Values-List IR2 convert method, we must also handle :Unused
  continuations, only punting when the continuation is :Fixed.  When called
  with a TR result continuation, we have to emit the unknown-values return
  ourself.  Otherwise, there isn't any way to write the Values-List function.

/usr1/lisp/compiler/ir2tran.lisp, 06-Mar-89 21:25:12, Edit by Ram.
  Make-Closure takes the number of closure vars and the function-entry, rather
  than the other way around.

/usr1/lisp/compiler/ir2tran.lisp, 06-Mar-89 20:48:29, Edit by Ram.
  And always pass 1 as the number of symbols to Unbind, rather than 0.

/usr1/lisp/compiler/ir2tran.lisp, 06-Mar-89 20:43:47, Edit by Ram.
  Args to the Bind miscop are (Value, Symbol), and not the other way around.

/usr1/lisp/compiler/ir2tran.lisp, 06-Mar-89 19:09:16, Edit by Ram.
  In IR2-Convert-IF, we have to negate the sense of the test when using an EQ
  NIL check.  Made IR2-Convert-Conditional take an additional not-p argument.

/usr1/lisp/compiler/ctype.lisp, 06-Mar-89 17:22:40, Edit by Ram.
  In Definition-Type, when we make the Function-Type, include the list of
  keyword info that we have built.

/usr1/lisp/compiler/ir2tran.lisp, 02-Mar-89 18:16:40, Edit by Ram.
  In Init-XEP-Environment, when we are checking for whether there is a more
  arg, look at the entry-function rather than the XEP.

/usr1/lisp/compiler/main.lisp, 01-Mar-89 15:58:32, Edit by Ram.
  Made Clear-Stuff clear the Finite-SB-Live-TNs in all SBs.  Maybe this will
  nuke some garbage.

/usr1/lisp/compiler/pack.lisp, 01-Mar-89 15:50:41, Edit by Ram.
  In Grow-SC, fill the Finite-SB-Live-TNs vector with NILs before we lose it so
  that if it is statically allocated, it won't hold onto garbage.  But this
  shouldn't make any difference, since we never use the Live-TNs in unbounded
  SBs.

/usr1/lisp/compiler/locall.lisp, 01-Mar-89 01:15:22, Edit by Ram.
  In Make-XEP-Lambda, in the lambda case, we now include an ignore declaration
  for the nargs var when policy suppresses the argument count check.

/usr1/lisp/compiler/ir1util.lisp, 28-Feb-89 19:39:56, Edit by Ram.
  Also clear :Optional kind for the Main-Entry in Delete-Optional-Dispatch.

/usr1/lisp/compiler/locall.lisp, 28-Feb-89 19:31:07, Edit by Ram.
  Changed Local-Call-Analyze so that it pushes new lambdas on the
  Component-Lambdas before it does any call analysis or let conversion.  This
  gets the normal consistency maintenance code to handle removal of deleted
  and let lambdas.  Before, there was a local list of new lambdas that could
  become inconsistent.

/usr1/lisp/compiler/ir1tran.lisp, 28-Feb-89 18:12:15, Edit by Ram.
  Instead of trying to set the :Optional kind everywhere that hairy lambda
  conversion creates a lambda, we wait until we are done and set the kind only
  the lambdas that are actually e-ps.  This was causing internal lambdas that
  weren't e-ps to be marked as optional.  The fix is also clearer, and causes
  less complication in the already-hairy code.

/usr1/lisp/compiler/ir1tran.lisp, 24-Feb-89 15:26:29, Edit by Ram.
  Changed Optional-Dispatch stuff to set the Functional-Entry-Function of the
  :Optional lambdas to the result Optional-Dispatch structure.

/usr1/lisp/compiler/ir1opt.lisp, 24-Feb-89 14:46:57, Edit by Ram.
  In IR1-Optimize, changed test for being in a deleted lambda to just look at
  the block-lambda, rather than at it's home.  The result should be the same.

/usr1/lisp/compiler/entry.lisp, 24-Feb-89 14:30:37, Edit by Ram.
  Changed Compute-Entry-Info to use the XEP's environment to determine whether
  the function is a closure.  The result should be the same, but is more easily
  obtained.

/usr1/lisp/compiler/ir1util.lisp, 24-Feb-89 14:26:58, Edit by Ram.
  Deleted definition of Find-XEP-Call, since this doesn't make sense anymore.

/usr1/lisp/compiler/debug.lisp, 24-Feb-89 14:21:09, Edit by Ram.
  Flushed permission of random wired live TNs at the start of an XEP.

/usr1/lisp/compiler/debug.lisp, 24-Feb-89 14:18:01, Edit by Ram.
  In Check-Block-Successors, flushed permission of random successor count in
  XEPs.

/usr1/lisp/compiler/ir2tran.lisp, 24-Feb-89 14:14:12, Edit by Ram.
  Flushed check for being the bind block for an XEP that inhibited emission of
  a block-finishing branch in Finish-IR2-Block.  Control flow is now normal in
  XEPs, so we don't want to randomly flush branches.

/usr1/lisp/compiler/ir1opt.lisp, 24-Feb-89 14:07:52, Edit by Ram.
  Flushed check for being in an XEP in Join-Successor-If-Possible.  Now that
  argument count dispatching is done explicitly, there is no need to force the
  call to a block boundry (for easy location).  Also, we are getting more
  complex code in the XEP, making block merging a desirable optimization.

/usr1/lisp/compiler/ir1util.lisp, 24-Feb-89 14:03:35, Edit by Ram.
  Fixed code in Delete-Lambda that was trying to notice when we are deleting
  the the XEP for an optional dispatch.  The test was right, but the action was
  wrong: it was setting the Functional-Entry-Function for all the e-p's to NIL,
  yet they were already NIL.  Instead, we call Delete-Optional-Dispatch, which
  deletes the unreferenced e-p's.

/usr1/lisp/compiler/ir1tran.lisp, 23-Feb-89 20:17:21, Edit by Ram.
  Wrapped a (locally (declare (optimize (safety 0))) ...) around the body of
  the loop created in Convert-More-Entry so that no type checking is done on
  the fixnum arithmetic.

/usr1/lisp/compiler/ir2tran.lisp, 23-Feb-89 14:34:49, Edit by Ram.
  Flushed most of the hair associated with the %Function-Entry funny function.
  What remains is now in Init-XEP-Environment, which is called by
  IR2-Convert-Bind when the lambda is an XEP.

/usr1/lisp/compiler/gtn.lisp, 23-Feb-89 14:24:20, Edit by Ram.
  Flushed some special-casing of XEPs that is no longer needed now that XEP's
  have args.  Also, allocation of argument passing locations in XEPs is now
  more similar to the non-XEP case: we don't allocate passing locations for
  unused arguments.

/usr1/lisp/compiler/locall.lisp, 22-Feb-89 15:26:50, Edit by Ram.
  Change handling of XEPs.  Most of the action in XEPs is now represented by
  explicit IR1 in the XEP: argument dispatching is done by a COND, etc.
  Instead of using funny functions such as %XEP-ARG to access the passed
  arguments, NARGS and all the positional arguments are passed as arguments to
  the XEP (with garbage defaults for unsupplied args).  The code in the XEP
  just references these variables.

  This simplifies creation of the XEP, since we can just cons up a lambda form
  and convert it, instead of creating each XEP call by hand.  It also moves
  complexity out of IR2 conversion, since argument dispatching has already been
  implemented.

/usr1/lisp/compiler/ir2tran.lisp, 16-Feb-89 15:12:17, Edit by Ram.
  Fixed %XEP-Arg to use Move-Argument rather than just Move.

/usr1/lisp/compiler/node.lisp, 15-Feb-89 00:36:30, Edit by Ram.
  Made Functional specify :Defined and Function as the defaults for the
  Where-From and Type slots so that we know defined functions are in fact
  functions.

/usr1/lisp/compiler/ir1tran.lisp, 14-Feb-89 23:48:37, Edit by Ram.
  In %Defun translator, fixed the test for being at top level (and thus o.k. to
  substitute).  The sense was negated, but it was also broken so that it was
  always false, so the normal top-level thing happened anyway.

/usr1/lisp/compiler/ir1tran.lisp, 14-Feb-89 15:02:14, Edit by Ram.
  Wrote Leaf-Inlinep and changed uses to (cdr (assoc leaf *inlines*)) with the
  new function.  This means that global declarations will now affect function
  references.

/usr1/lisp/compiler/main.lisp, 13-Feb-89 12:19:39, Edit by Ram.
  Call Init-Assembler *before* Entry-Analyze so that we don't emit labels when
  the assembler isn't initialized.

/usr1/lisp/compiler/ltn.lisp, 02-Feb-89 15:41:40, Edit by Ram.
  Changed Annotate-Function-Continuation not to clear Type-Check unless the
  policy is unsafe.  Changed LTN-Default-Call to take a policy argument and
  pass it through.

/usr1/lisp/compiler/ir1tran.lisp, 02-Feb-89 15:16:32, Edit by Ram.
  Changed IR1-Convert-Combination-Args and the translator for
  Multiple-Value-Call to assert that the function continuation yeilds a value
  of type Function.

/usr1/lisp/compiler/assembler.lisp, 31-Jan-89 14:13:54, Edit by Ram.
/usr1/lisp/compiler/codegen.lisp, 31-Jan-89 14:13:53, Edit by Ram.
  Added a function version of Emit-Label that can be called outside of
  Assemble.  Used this in Generate-Code so that we don't have to worry about
  faking the current node for Assemble, when we aren't emitting any code
  anyway.

/usr1/lisp/compiler/assembler.lisp, 31-Jan-89 13:56:08, Edit by Ram.
  In Init-Assembler, Null out the Assembler-Node-Names in *Assembler-Nodes* so
  that we don't hold onto old garbage.  Also zero the code vectors so that
  unitialized bytes always come up zero.

/usr1/lisp/compiler/ir2tran.lisp, 31-Jan-89 12:37:21, Edit by Ram.
  Fixed IR2-Convert-Local-Unknown-Call to use Standard-Value-TNs to get the
  result TNs, rather than calling incorrectly calling Make-Standard-Value-TNs
  on a continuation.

/usr1/lisp/compiler/ir1opt.lisp, 30-Jan-89 23:28:08, Edit by Ram.
  Changed Check-Types to not set Type-Check when the asserted type is T and the
  derived type is *.

/usr1/lisp/compiler/ir1util.lisp, 30-Jan-89 19:36:09, Edit by Ram.
  Changed Delete-Ref not to call Delete-Lambda or Delete-Optional-Dispatch when
  the functional is already deleted.

/usr1/lisp/compiler/locall.lisp, 30-Jan-89 19:23:26, Edit by Ram.
  Convert-MV-Call must add the ep to the Lambda-Calls for the home lambda (as
  in Convert-Call) so that DFO can detect the control transfer implicit in
  local call.

/usr1/lisp/compiler/ir1util.lisp, 30-Jan-89 18:30:27, Edit by Ram.
  Changed Delete-Optional-Dispatch to call Delete-Lambda on all entry points
  with no references.

/usr1/lisp/compiler/ir1util.lisp, 30-Jan-89 17:04:33, Edit by Ram.
  Changed Delete-Lambda to mark the Lambda's lets as :Deleted as well,
  guaranteeing that all code in the environment of a deleted lambda is deleted
  (without having to do flow analysis).

/usr1/lisp/compiler/locall.lisp, 30-Jan-89 16:37:31, Edit by Ram.
  Changed Convert-MV-Call not to call Let-Convert, since the last entry may
  have spurious references due to optional defaulting code that hasn't been
  deleted yet.  Changed Maybe-Let-Convert to set the Functional-Kind of the
  lambda to :Let or :MV-Let, depending on the combination type.

/usr1/lisp/compiler/locall.lisp, 30-Jan-89 15:35:52, Edit by Ram.
  Changed Merge-Cleanups-And-Lets to use Find-Enclosing-Cleanup to determine
  whether there is any cleanup in effect at the call site, rather than directly
  using the Block-End-Cleanup.

/usr1/lisp/compiler/ir1util.lisp, 30-Jan-89 15:12:51, Edit by Ram.
  Changed Node-Ends-Block to set the start and end cleanups of the *new* block
  (not the old) to the ending cleanup of the old block.  This is clearly more
  right, but may not be totally right.
 
/usr1/lisp/compiler/life.lisp, 27-Jan-89 17:09:01, Edit by Ram.
  Make Clear-Lifetime-Info always set the TN-Local slot for local TNs, using
  some other referencing block when there there are global conflicts.

/usr1/lisp/compiler/pack.lisp, 10-Jan-89 15:27:21, Edit by Ram.
  Fixed Select-Location not to infinite loop when Finite-Sb-Last-Offset is 0.

/usr0/ram/compiler/ir2tran.lisp, 30-Jun-88 13:57:12, Edit by Ram.
  Fixed IR2-Convert-Bind to ignore vars with no Refs.

/usr0/ram/compiler/gtn.lisp, 30-Jun-88 13:54:51, Edit by Ram.
  Fixed Assign-Lambda-Var-TNs and Assign-IR2-Environment to ignore vars with no
  Refs.

/usr0/ram/compiler/life.lisp, 02-Mar-88 17:06:18, Edit by Ram.
  Aaaargh!  When clearing the Packed-TN-Local in Clear-Lifetime-Info, iterate
  up to Local-TN-Limit, not SC-Number-Limit.

/usr0/ram/compiler/ir1util.lisp, 20-Feb-88 22:00:37, Edit by Ram.
  Made Substitute-Leaf and Change-Ref-Leaf do an Up-Tick-Node on the changed
  Refs.

/usr0/ram/compiler/ltn.lisp, 20-Feb-88 16:25:11, Edit by Ram.
  Changed Find-Template to deal with output assertions correctly once again.
  Instead of assuming that the Node-Derived-Type is true, we look at the
  Type-Check flag in the continuation.  If the continuation type is being
  checked, then we only use a template when it doesn't have an output
  restriction.

  In Find-Template-For-Policy, use safe templates as a last resort, even when
  policy is :Small or :Fast.  A safe template is surely faster and smaller than
  a full call.

  In Ltn-Analyze, clear the Type-Check flags on all continuations when our
  policy is unsafe.

/usr0/ram/compiler/debug.lisp, 18-Feb-88 17:17:19, Edit by Ram.
  And fixed Check-VOP-Refs to ensure that the temporary write comes before
  (which is after in the reversed VOP-Refs) the read, rather than vice-versa...

/usr0/ram/compiler/vmdef.lisp, 18-Feb-88 17:10:35, Edit by Ram.
  Fixed Compute-Reference-Order to begin temporary lifetimes with the write
  rather than the read.

/usr0/ram/compiler/gtn.lisp, 18-Feb-88 16:06:41, Edit by Ram.
  Have to fetch the Equated-Returns inside the loop in Find-Equivalence
  classes, since Equate-Return-Info will change the returns for the current
  environment.  This used to work, since Equate-Return-Info used to be
  destructive.

/usr0/ram/compiler/ir1opt.lisp, 14-Feb-88 14:30:47, Edit by Ram.
  Oops.  Fixed the test in Propagate-From-Calls for being a call to the
  function concerned.  Now that this optimization can actually happen, who
  knows?

/usr0/ram/compiler/ltn.lisp, 11-Feb-88 18:01:38, Edit by Ram.
  Made Annotate-1-Value-Continuation delay global function references to
  functions that aren't notinline.  Made LTN-Default-Call,
  LTN-Analyze-Full-Call and LTN-Analyze-MV-Call annotate their function
  continuation. 

/usr0/ram/compiler/flowsimp.lisp, 11-Feb-88 16:44:48, Edit by Ram.
  Now that returns aren't being picked off in flow-graph-simplify, we have to
  fix join-block-if-possible not to attempt to join the XEP return to the
  component tail...

/usr0/ram/compiler/ir1util.lisp, 11-Feb-88 16:14:52, Edit by Ram.
  Made Delete-Ref call Maybe-Let-Convert when deleting the second-to-last
  reference to a lambda.

/usr0/ram/compiler/flowsimp.lisp, 10-Feb-88 16:46:56, Edit by Ram.
/usr0/ram/compiler/locall.lisp, 11-Feb-88 13:24:04, Edit by Ram.
  Moved let-conversion to locall from flowsimp, and made it be triggered by
  Maybe-Let-Convert.  This is called on each new lambda after local call
  analysis, and can also be called whenever there is some reason to believe
  that a lambda might be eligible for let-conversion.  We clear any :Optional
  function kinds since the entry functions can be treated as normal functions
  after local call analysis.

  This change was made to solve problems with lambdas not being let-converted
  when the return node was deleted due to being unreachable.  This is important
  now that being a let has major environment significance.  Originally let
  conversion was regarded as a way to delete a return, and thus made some kind
  of sense to have it be a flow graph optimization.  Now that a let can have
  only one reference, we can trigger let conversion by noticing when references
  are deleted.

/usr0/ram/compiler/node.lisp, 11-Feb-88 13:12:38, Edit by Ram.
/usr0/ram/compiler/ir1tran.lisp, 11-Feb-88 13:12:47, Edit by Ram.
  Added :Optional Functional-Kind that is initially specified for the
  entry-point lambdas in optional-dispatches so that we know there may be
  references to the function through the optional dispatch. 

/usr0/ram/compiler/ir1util.lisp, 11-Feb-88 12:23:11, Edit by Ram.
  Changed assertion in Control-Equate to allow an existing value-equate to the
  same continuation.

/usr0/ram/compiler/ir1tran.lisp, 25-Jan-88 19:27:57, Edit by Ram.
  Changed the default policy to be all 1's, and modified calls to Policy in all
  files so that they do "the right thing" when compared qualities are equal.
  The default action should be chosen so as to minimize mystification and
  annoyance to non-wizards.  In general, the default should be chosen according
  to the ordering: safety > brevity > speed > space > cspeed.  Checks for 0 and
  3 meaning "totally unimportant" and "ultimately important" are also o.k.

/usr0/ram/compiler/gtn.lisp, 24-Jan-88 11:20:37, Edit by Ram.
  Changed Equate-Return-Info so that it effectively ignores the Count and Types
  in :Unused continuations, yet still combines the Entry-P and Tail-P values.

/usr0/ram/compiler/locall.lisp, 23-Jan-88 21:41:28, Edit by Ram.
  Make Convert-XEP-Call set the Return-Point too...

/usr0/ram/compiler/ir1util.lisp, 22-Jan-88 16:17:38, Edit by Ram.
  Made Immediately-Used-P special-case local calls by using
  Basic-Combination-Return-Point.

/usr0/ram/compiler/locall.lisp, 22-Jan-88 16:13:32, Edit by Ram.
/usr0/ram/compiler/node.lisp, 22-Jan-88 16:12:03, Edit by Ram.
  Added a Basic-Combination-Return-Point slot so that local calls can rebember
  where they are supposed to return to.

/usr0/ram/compiler/gtn.lisp, 22-Jan-88 10:03:37, Edit by Ram.
  Fixed Assign-Lambda-Vars to set the TN-Leaf.

/usr0/ram/compiler/flowsimp.lisp, 22-Jan-88 10:22:53, Edit by Ram.
  Made Convert-To-Let do an Intersect-Continuation-Asserted-Type on the actual
  continuation with the dummy's assertion when the let call is the only use of
  the actual continuation.

/usr0/ram/compiler/ir1tran.lisp, 22-Jan-88 09:42:49, Edit by Ram.
  Tack NIL on the end of the forms that we convert so that no top-level form is
  in a for-value context.

/usr0/ram/compiler/ir1opt.lisp, 21-Jan-88 17:50:52, Edit by Ram.
  Made Check-Types intersect the new type with the Node-Derived-Type for all
  the continuation uses so that IR1Opt doesn't go and change the type right
  back. 

/usr0/ram/compiler/main.lisp, 21-Jan-88 17:31:57, Edit by Ram.
/usr0/ram/compiler/ir1opt.lisp, 21-Jan-88 17:30:31, Edit by Ram.
  Type checking was being done wrong.  We need to check types even if IR1Opt
  doesn't do anything, and we need to give IR1Opt a second chance if type check
  does anything.  Made Check-Types return whether it did anything.

/usr0/ram/compiler/ir1tran.lisp, 21-Jan-88 17:14:13, Edit by Ram.
  Fixed IR1 translator for THE to use Find-Uses to find whether the
  continuation is used, rather than incorrectly doing it itself (using an old
  interpretation of Continuation-Use).

/usr0/ram/compiler/ir1tran.lisp, 16-Nov-87 15:58:39, Edit by Ram.
  Made %proclaim (and hence proclaim) return (undefined-value) rather than
  arbitrary randomness.

/usr1/ram/compiler/flowsimp.lisp, 23-Aug-87 22:00:39, Edit by Ram
  Changed Flow-Graph-Simplify not to merge blocks unless the cleanups for the
  two blocks are identical.  The is a sub-optimal (but conservative) way to
  ensure that cleanups are only done on block boundaries.

/usr1/ram/compiler/ir1opt.lisp, 23-Aug-87 21:26:53, Edit by Ram
  Just look for the :Let functional kind in Top-Down-Optimize, instead of
  figuring out from first principles.

/usr1/ram/compiler/ir1util.lisp, 20-Aug-87 22:12:45, Edit by Ram
  The only worthwhile use for the functional nesting was in Delete-Ref, where
  it would walk all the inferiors, marking them as deleted as well.  But I
  think that just marking the outer function as deleted will eventually cause
  all the inner functions to be deleted.  As it stands, Delete-Ref is a lot
  simpler.  If there are problems with deleted-but-somehow-undeletable
  references holding onto functions, we may want to look at all references in
  Delete-Ref and see if some enclosing function is deleted.

/usr1/ram/compiler/ir1tran.lisp, 22-Aug-87 15:38:50, Edit by Ram
  Changed stuff to use the new Functional and Cleanup structures.  Mostly
  involves flushing stuff.

/usr1/ram/compiler/locall.lisp, 21-Aug-87 14:24:32, Edit by Ram
/usr1/ram/compiler/ir1opt.lisp, 20-Aug-87 22:05:33, Edit by Ram
  Changed Local-Call-Analyze to just take a component and analyze the
  New-Functions.  This simplifies (and optimizes) the late uses in IR1
  optimize.  Also changed convert-call-if-possible to know to try to convert
  the call to the real function rather than the XEP.

/usr1/ram/compiler/node.lisp, 23-Aug-87 20:12:58, Edit by Ram
  Flushed bogus hierarchical information in the Functional, Environment and
  Cleanup structures.  Now that I've taken a stab at implementing the IR2
  conversion passes, it is obvious that this information is useless and
  difficult to maintain.

  We do need a way to iterate over all the functions in a component, but doing
  a tree walk is bogus.  Instead, we have a list of all the lambdas in each
  component.  When functions are initially converted, they are placed on the
  component New-Functions list.  Local call analysis moves analyzed lambdas
  into the Lambdas list.  We don't bother to remove lambdas from this list when
  they are deleted.

  A change needed in the cleanup stuff to make it work is to have continuations
  with no immediately enclosing cleanup point have their lambda as the cleanup.
  Then when we convert the lambda to a let, we set the Cleanup slot in the
  lambda to any cleanup enclosing the call so that we realize stuff needs to be
  cleaned up.

/usr1/ram/compiler/flowsimp.lisp, 23-Aug-87 20:49:36, Edit by Ram
  Changed Find-Initial-DFO to build the Lambdas lists for the components.  At
  the same time, we also use XEP references to (correctly) merge components
  with potential environment inter-dependencies, rather than attempting to use
  the lambda nesting.  Changed Join-Components to combine the Lambdas and
  New-Functions lists.

  Changed Delete-Return to convert to a let only when there is a single call,
  and also to mark the lambda with the :Let functional kind.  This makes
  let-calls exactly correspond to the functions that IR1 optimize can
  substitute for.  This also solves problems with cleanups, since it is
  trivially true that all calls are in the same dynamic environment.

/usr1/ram/compiler/ir1tran.lisp, 18-Aug-87 15:25:18, Edit by Ram
  In IR1-Convert, if the function is not a symbol, but doesn't look even
  vaguely like a lambda, then complain about an illegal function call,
  rather than having IR1-Convert-Lambda say it is an illegal lambda.

/usr1/ram/compiler/numacs.lisp, 16-Aug-87 13:48:11, Edit by Ram
  Added a Defvar that doesn't use OR (and create a LET and freak out IR1
  conversion.)

/usr1/ram/compiler/ir1util.lisp, 16-Aug-87 18:14:10, Edit by Ram
/usr1/ram/compiler/debug.lisp, 16-Aug-87 15:19:47, Edit by Ram
/usr1/ram/compiler/flowsimp.lisp, 16-Aug-87 15:19:13, Edit by Ram
/usr1/ram/compiler/ir1opt.lisp, 16-Aug-87 15:18:47, Edit by Ram
/usr1/ram/compiler/node.lisp, 16-Aug-87 19:58:30, Edit by Ram
/usr1/ram/compiler/ir1tran.lisp, 16-Aug-87 20:29:36, Edit by Ram
/usr1/ram/compiler/locall.lisp, 16-Aug-87 20:22:28, Edit by Ram
  Changed stuff for new explicit external entry point concept.  The external
  entry point is now a real function containing local calls to the entry
  points.  This represents reality better, making lots of things previously
  special-cased automatically happen in our favor.  We really needed this for
  environment analysis and IR2 conversion to work.
  
  Functional-Entry-Kind is replaced by Functional-Kind and
  Functional-Entry-Function.  The Kind is kind of like the old Entry-Kind.  The
  Entry-Function is the XEP (or a back-pointer in an XEP).  Uses of Entry-Kind
  were replaced with Kind or Entry-Function or flushed, as appropriate.

  Note-Entry-Point has been flushed.  %Defun doesn't need to do anything to
  cause the function to be an entry point.  The top-level lambda is no longer
  a real entry-point: instead we just directly link it to the component head
  and tail.

  The more-arg XEP creates a more-arg cleanup.  The local-call case still needs
  to be fixed.

/usr1/ram/compiler/fndb.lisp, 16-Aug-87 20:37:28, Edit by Ram
  Added some definitions for %mumble magic compiler functions.

/usr1/ram/compiler/ir1tran.lisp, 16-Aug-87 20:29:36, Edit by Ram
  Changed uses of the two-arg Arg for more-arg hackery into %More-Arg, since
  this isn't the user-level functionality we will ultimately want for
  more-args.

/usr1/ram/compiler/main.lisp, 16-Aug-87 18:35:29, Edit by Ram
  Changed Compile-Component not to do any IR1 passes on the top-level component
  except for Type-Check.  These optimizations are unlikely to have any useful
  effect on top-level code, and they might want to inject illegal stuff into
  the top-level component.

/usr1/ram/compiler/macros.lisp, 16-Aug-87 18:26:19, Edit by Ram
  Changed With-IR1-Environment to bind *Converting-Top-Level*.  Currently you'd
  better not use this on top-level code unless you are sure you won't emit
  anything that can't go in top-level, since IR1-Convert-Lambda will bogue out
  because there is no *Initial-Component* to switch to.

/usr1/ram/compiler/macros.lisp, 13-Aug-87 20:16:47, Edit by Ram
/usr1/ram/compiler/node.lisp, 13-Aug-87 22:24:30, Edit by Ram
/usr1/ram/compiler/main.lisp, 13-Aug-87 22:35:11, Edit by Ram
/usr1/ram/compiler/globaldb.lisp, 13-Aug-87 20:21:12, Edit by Ram
/usr1/ram/compiler/locall.lisp, 13-Aug-87 22:57:54, Edit by Ram
/usr1/ram/compiler/flowsimp.lisp, 13-Aug-87 22:52:01, Edit by Ram
/usr1/ram/compiler/ir1opt.lisp, 13-Aug-87 22:59:11, Edit by Ram
/usr1/ram/compiler/ir1tran.lisp, 13-Aug-87 23:06:03, Edit by Ram
  Changed stuff to support having separate top-level and initial components.
  Whenver we see a lambda or anything hairy, we switch over to the initial
  component.  Hairyness of special-forms is determined by the :Top-Level-P
  keyword to Def-IR1-Translator.

  We make appropriate special forms hairy to guarantee that the top-level
  component doesn't contain any stuff that would make life hard for IR2
  conversion.  In particular, it contains no variables, no functions other than
  the top-level lambda and no non-local exit targets.

  Local call analysis refuses to convert calls appearing in the top-level
  component.  In other files, stuff related to Functional-Top-Level-P was
  ripped out.

/usr1/ram/compiler/ir1opt.lisp, 13-Aug-87 17:58:37, Edit by Ram
  Changed propagate-from-calls to punt if any use is a mv-combination.  Changed
  Top-Down-Optimize not to Substitute-Let-Vars unless the only use is not a
  MV-Combination.  Un-commented-out the substituion of functionals for non-set
  let vars. 

/usr1/ram/compiler/locall.lisp, 13-Aug-87 18:31:24, Edit by Ram
  Frobbed Find-Top-Level-Code to recognize DEFUNs with no calls as
  non-top-level.  The entire concept is probably wrong, though.

/usr1/ram/compiler/ir1tran.lisp, 13-Aug-87 19:07:22, Edit by Ram
  Changed IR1-Convert-OK-Combination to look at the leaf-type of the leaf
  rather than the derived type for the function continuation.  This allows
  known calls to be recognized again (I'm sure that worked at one point.
  Perhaps before they were becoming known later on somehow?).  This is all not
  really right anyway, given the broken interpretation of function types
  currently used in IR1. 

/usr/ram/compiler/ir1tran.slisp, 12-Jan-87 11:48:32, Edit by Ram
  Fixed Find-Source-Paths to use a DO with ATOM test rather than a dolist, so
  that it won't blow up on dotted lists.

/usr/ram/compiler/ir1util.slisp, 12-Jan-87 10:28:07, Edit by Ram
  Fixed Delete-Block to null out the DEST for the continuations belonging to
  each node as we delete the node, so we don't try to deliver a result to a
  node that doesn't exist anymore.
