;;; src/code/filesys.lisp.orig (ie 18c)  vs  cmucl-2002-08-23-19h00-clean/src/code/filesys.lisp
Comparison of filesys.lisp-G76 and filesys-G77.

**** Buffer filesys.lisp-G76:
  "$Header: /home/CVS-cmucl/src/code/filesys.lisp,v 1.43.2.5 2000/08/24 14:24:01 dtc Exp $")
**** Buffer filesys-G77:
  "$Header: /project/cmucl/cvsroot/src/code/filesys.lisp,v 1.67 2002/07/10 16:15:58 toy Exp $")
***************

**** Buffer filesys.lisp-G76:
;;; version := "." ([0-9]+ | "*")
;;;
;;; Note: this grammer is ambiguous.  The string foo.bar.5 can be parsed
**** Buffer filesys-G77:
;;; version := ".*" | ".~" ([0-9]+ | "*") "~"
;;;
;;; Note: this grammer is ambiguous.  The string foo.bar.~5~ can be parsed
***************

**** Buffer filesys.lisp-G76:
**** Buffer filesys-G77:
;;; extract-name-type-and-version  --  Internal.
;;;
***************

**** Buffer filesys.lisp-G76:
  (let* ((last-dot (position #\. namestr :start (1+ start) :end end
			     :from-end t))
	 (second-to-last-dot (and last-dot
				  (position #\. namestr :start (1+ start)
					    :end last-dot :from-end t)))
	 (version :newest))
    ;; If there is a second-to-last dot, check to see if there is a valid
    ;; version after the last dot.
    (when second-to-last-dot
      (cond ((and (= (+ last-dot 2) end)
		  (char= (schar namestr (1+ last-dot)) #\*))
	     (setf version :wild))
	    ((and (< (1+ last-dot) end)
		  (do ((index (1+ last-dot) (1+ index)))
		      ((= index end) t)
		    (unless (char<= #\0 (schar namestr index) #\9)
		      (return nil))))
	     (setf version
		   (parse-integer namestr :start (1+ last-dot) :end end)))
	    (t
	     (setf second-to-last-dot nil))))
    (cond (second-to-last-dot
	   (values (maybe-make-pattern namestr start second-to-last-dot)
		   (maybe-make-pattern namestr
				       (1+ second-to-last-dot)
				       last-dot)
		   version))
	  (last-dot
	   (values (maybe-make-pattern namestr start last-dot)
		   (maybe-make-pattern namestr (1+ last-dot) end)
		   version))
	  (t
	   (values (maybe-make-pattern namestr start end)
		   nil
		   version)))))

**** Buffer filesys-G77:
  (labels
      ((explicit-version (namestr start end)
	 (cond ((or (< (- end start) 5)
		    (char/= (schar namestr (1- end)) #\~))
		(values :newest end))
	       ((and (char= (schar namestr (- end 2)) #\*)
		     (char= (schar namestr (- end 3)) #\~)
		     (char= (schar namestr (- end 4)) #\.))
		(values :wild (- end 4)))
	       (t
		(do ((i (- end 2) (1- i)))
		    ((< i (+ start 2)) (values :newest end))
		  (let ((char (schar namestr i)))
		    (when (eql char #\~)
		      (return (if (char= (schar namestr (1- i)) #\.)
				  (values (parse-integer namestr :start (1+ i)
							 :end (1- end))
					  (1- i))
				  (values :newest end))))
		    (unless (char<= #\0 char #\9)
		      (return (values :newest end))))))))
       (any-version (namestr start end)
	 ;; process end of string looking for a version candidate.
	 (multiple-value-bind (version where)
	   (explicit-version namestr start end)
	   (cond ((not (eq version :newest))
		  (values version where))
		 ((and (>= (- end 2) start)
		       (char= (schar namestr (- end 1)) #\*)
		       (char= (schar namestr (- end 2)) #\.)
		       (find #\. namestr
			     :start (min (1+ start) (- end 2))
			     :end (- end 2)))
		  (values :wild (- end 2)))
		 (t (values version where)))))
       (any-type (namestr start end)
	 ;; Process end of string looking for a type. A leading "."
	 ;; is part of the name.
	 (let ((where (position #\. namestr
				:start (min (1+ start) end)
				:end end :from-end t)))
	   (when where
	     (values where end))))
       (any-name (namestr start end)
	 (declare (ignore namestr))
	 (values start end)))
    (multiple-value-bind
	(version vstart)(any-version namestr start end)
      (multiple-value-bind
	  (tstart tend)(any-type namestr start vstart)
	(multiple-value-bind
	    (nstart nend)(any-name namestr start (or tstart vstart))
	  (values
	   (maybe-make-pattern namestr nstart nend)
	   (and tstart (maybe-make-pattern namestr (1+ tstart) tend))
	   version))))))

***************

**** Buffer filesys.lisp-G76:
**** Buffer filesys-G77:
	   (logical-p (logical-pathname-p pathname))
***************

**** Buffer filesys.lisp-G76:
	(unless type-supplied
	  (error "Cannot specify the version without a type: ~S" pathname))
	(strings (if (eq version :wild)
		     ".*"
		     (format nil ".~D" version)))))
**** Buffer filesys-G77:
	(strings (if (eq version :wild)
		     (if logical-p ".*" ".~*~")
		     (format nil (if logical-p ".~D" ".~~~D~~")
			     version)))))
***************

**** Buffer filesys.lisp-G76:
	     (strings ".*"))
	    (integer
	     (strings (format nil ".~D" pathname-version)))
**** Buffer filesys-G77:
	     (strings ".~*~"))
	    (integer
	     (strings (format nil ".~~~D~~" pathname-version)))
***************

**** Buffer filesys.lisp-G76:
  (when (and (integerp (pathname-version pathname))
	     (member (pathname-type pathname) '(nil :unspecific)))
    (error "Cannot supply a version without a type:~%  ~S" pathname))
**** Buffer filesys-G77:
***************

**** Buffer filesys.lisp-G76:
	       (setf file (concatenate 'string file "."
				       (quick-integer-to-string version))))
**** Buffer filesys-G77:
	       (setf file (concatenate 'string file ".~"
				       (quick-integer-to-string version)
				       "~")))
***************

**** Buffer filesys.lisp-G76:
      (error "~S doesn't exist." new-val))
**** Buffer filesys-G77:
      (error 'simple-file-error
             :format-control "~S doesn't exist."
             :format-arguments (list new-val)))
***************

Done.
