-*- flush-trailing-whitespace: nil -*-

FIX /home/matt/src/nightshade-0.0+/src/code/CVS is a directory.

+++ /home/matt/src/nightshade-0.0+/src/code/alieneval.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/alieneval.lisp.
+++++++++++++++
       The alien is allocated on the heap, and has infinite extent.  The alien
---------------
       The alien is allocated on the heap, and has infinate extent.  The alien
+++ /home/matt/src/nightshade-0.0+/src/code/alpha-vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/alpha-vm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/array.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/array.lisp.
+++++++++++++++
  "Creates an array of the specified Dimensions.  See FIX manual for details."
---------------
  "Creates an array of the specified Dimensions.  See manual for details."
+++ /home/matt/src/nightshade-0.0+/src/code/backq.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/backq.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/bignum-test.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/bignum-test.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/bignum.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/bignum.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/bit-bash.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/bit-bash.lisp.
+++++++++++++++
	;; They aren't aligned.
---------------
	;; They arn't aligned.
+++ /home/matt/src/nightshade-0.0+/src/code/bsd-os.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/bsd-os.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/byte-interp.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/byte-interp.lisp.
+++++++++++++++
	       (declare (ignore d))
---------------
	       (declare (ignore d)) 
+++++++++++++++
;;; Fetch an 8/24 bit operand out of the code stream.
---------------
;;; Fetch and 8/24 bit operand out of the code stream.
+++++++++++++++
;;;
---------------
;;; 
+++++++++++++++
;;;
---------------
;;; 
+++++++++++++++
;;;
---------------
;;; 
+++++++++++++++
;;;
---------------
;;; 
+++++++++++++++
;;;
---------------
;;; 
+++++++++++++++
;;;
---------------
;;; 
+++++++++++++++
;;;
---------------
;;; 
+++++++++++++++
;;;

---------------
;;; 

+++++++++++++++
;;;
---------------
;;; 
+++ /home/matt/src/nightshade-0.0+/src/code/c-call.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/c-call.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/char.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/char.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/class.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/class.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/clx-ext.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/clx-ext.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/numbers.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/numbers.lisp.
+++++++++++++++
	  boole-andc1 boole-andc2 boole-orc1 boole-orc2 lognot logcom logtest
---------------
	  boole-andc1 boole-andc2 boole-orc1 boole-orc2 lognot logtest
+++++++++++++++
;; FIX
(defun lognot (number)
  "Returns the bit-wise logical complement of Number."
---------------
(defun lognot (number)
  "Returns the bit-wise logical not of integer."
+++++++++++++++
(defun logcom (number)
  "Returns the bit-wise logical complement of Number."
  (etypecase number
    (fixnum (lognot (truly-the fixnum number)))
    (bignum (bignum-logical-not number))))


---------------
+++++++++++++++
;; FIX define explicitly to aid searching
---------------
+++ /home/matt/src/nightshade-0.0+/src/code/commandline.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/commandline.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/cprofile.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/cprofile.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/debug-info.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/debug-info.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/debug-int.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/debug-int.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/debug-vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/debug-vm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/debug.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/debug.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/defmacro.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/defmacro.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/defstruct.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/defstruct.lisp.
+++++++++++++++
	    (error "FIX dd-maybe-make-print-method (requires CLOS)")
	    `((if (fboundp 'print-object)
---------------
	    `((when (fboundp 'print-object)
+++++++++++++++
   Popular DEFSTRUCT options (see manual FIX for others):

---------------
   Popular DEFSTRUCT options (see manual for others):

+++ /home/matt/src/nightshade-0.0+/src/code/describe.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/describe.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/dyncount.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/dyncount.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/error.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/error.lisp.
+++++++++++++++
   recently established to least recently established.  If Condition is
---------------
   recently established to less recently established.  If Condition is
+++++++++++++++
			       (cadr clause) ;bvl=3  ;; FIX bvl means? body/block var list?
---------------
			       (cadr clause) ;bvl=3
+++++++++++++++
		  ; FIX (still in pd version?) Warning: Undefined type CLASS    ; class from clos?
---------------
+++++++++++++++
;;;; HANDLER-BIND (SIGNAL is in lispinit.lisp).

---------------
;;;; HANDLER-BIND and SIGNAL.

+++++++++++++++
(define-condition serious-condition (condition)())  ; FIX add space bw )(?

---------------
(define-condition serious-condition (condition)())

+++++++++++++++
;;; This macro doesn't work in older versions of the CMUCL system due to
;;; lossage in closing over tags.  The previous version sets up unique
;;; run-time tags.
---------------
;;; This macro doesn't work in older version of CMUCL system due to lossage
;;; in closing over tags.  The previous version sets up unique run-time tags.
+++ /home/matt/src/nightshade-0.0+/src/code/eval.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/eval.lisp.
+++++++++++++++
	  tagbody prog prog* go
---------------
	  tagbody prog prog* go 
+++++++++++++++
          declare special
---------------
          declare special 
+++++++++++++++
*evalhook* *applyhook* evalhook applyhook
---------------
*evalhook* *applyhook* evalhook applyhook 
+++++++++++++++
	       (declare (ignore d))
---------------
	       (declare (ignore d)) 
+++++++++++++++
   result or results."
---------------
  result or results."
+++++++++++++++
;;;
---------------
;;; 
+++++++++++++++
;;;
---------------
;;; 
+++ /home/matt/src/nightshade-0.0+/src/code/exports.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/exports.lisp.
+++++++++++++++
(if (find-package "FTP")
    (rename-package "FTP" "FTP" nil)
    (make-package "FTP" :nicknames 'nil :use nil))
---------------
+++++++++++++++
(use-package '("LISP") "FTP")
---------------
+++++++++++++++
---------------
(defpackage "ANSI-LOOP")

+++++++++++++++
             "DADDR-T" "DEV-T" "DIRECT" "EXECALL" "EXECGRP" "EXECOTH" "EXECOWN"
	     "F-DUPFD"
             "F-GETFD" "F-GETFL" "F-GETOWN" "F-SETFD" "F-SETFL" "F-SETOWN"
             "FAPPEND" "FASYNC" "FCREAT" "FEXCL" "FIONREAD" "FNDELAY" "FTRUNC"
             "F_OK" "GET-TIMEZONE" "GET-UNIX-ERROR-MSG" "GID-T" "INO-T" "IT-INTERVAL"
---------------
             "DADDR-T" "DEV-T" "DIRECT" "EXECGRP" "EXECOTH" "EXECOWN" "F-DUPFD"
             "F-GETFD" "F-GETFL" "F-GETOWN" "F-SETFD" "F-SETFL" "F-SETOWN"
             "FAPPEND" "FASYNC" "FCREAT" "FEXCL" "FIONREAD" "FNDELAY" "FTRUNC"
             "F_OK" "GET-UNIX-ERROR-MSG" "GID-T" "INO-T" "IT-INTERVAL"
+++++++++++++++
	     "O_TRUNC" "O_WRONLY" "READALL" "READGRP" "READOTH" "READOWN"
	     "RLIM-CUR"
---------------
             "O_TRUNC" "O_WRONLY" "READGRP" "READOTH" "READOWN" "RLIM-CUR"
+++++++++++++++
	     "WRITEALL" "WRITEGRP" "WRITEOTH" "WRITEOWN"
	     "WS-COL" "WS-ROW" "WS-XPIXEL"
---------------
             "WRITEGRP" "WRITEOTH" "WRITEOWN" "WS-COL" "WS-ROW" "WS-XPIXEL"
+++++++++++++++
             "FILE-ERROR-PATHNAME" "FILE-LENGTH" "FILE-MODE" "FILE-NAMESTRING"
---------------
             "FILE-ERROR-PATHNAME" "FILE-LENGTH" "FILE-NAMESTRING"
+++++++++++++++
	     "INTERACTIVE-STREAM-P" "INTERNAL-REAL-TO-UNIVERSAL-TIME" "INCF"
---------------
	     "INTERACTIVE-STREAM-P" "INCF"
+++++++++++++++
	     "LOGIOR" "LOGNAND" "LOGNOR" "LOGCOM" "LOGNOT" "LOGORC1" "LOGORC2" "LOGTEST"
---------------
	     "LOGIOR" "LOGNAND" "LOGNOR" "LOGNOT" "LOGORC1" "LOGORC2" "LOGTEST"
+++++++++++++++
             "UNION" "UNIVERSAL-TO-INTERNAL-REAL-TIME" "UNLESS" "UNREAD-CHAR"
	     "UNSIGNED-BYTE" "UNTRACE"
---------------
             "UNION" "UNLESS" "UNREAD-CHAR" "UNSIGNED-BYTE" "UNTRACE"
+++++++++++++++
	     "LIST-FILES"
---------------
+++++++++++++++
	     "MAKE-STREAM-COMMAND" "MAKE-WEAK-POINTER" "MAP-FILES"
---------------
	     "MAKE-STREAM-COMMAND" "MAKE-WEAK-POINTER"
+++++++++++++++
             "PRINT-DIRECTORY" "PRINT-FILES" "PRINT-HERALD" "PRINT-PRETTY-KEY"
---------------
             "PRINT-DIRECTORY" "PRINT-HERALD" "PRINT-PRETTY-KEY"
+++++++++++++++
	   "BYTE-FASL-FILE-VERSION"
	   "*COMPILE-COMPONENT*"
	   "BLOCK-NUMBER"
	   "DYNCOUNT-INFO-COUNTS"
	   "BACKEND-BYTE-FASL-FILE-IMPLEMENTATION"
	   "IR2-BLOCK-BLOCK"
	   "DISASSEM-BYTE-COMPONENT"
	   "LITTLE-ENDIAN-FASL-FILE-IMPLEMENTATION"
	   "DYNCOUNT-INFO-COSTS"
	   "FUNCALLABLE-INSTANCE-LEXENV"
	   "DISASSEM-BYTE-FUN"
	   "VOP-BLOCK"
	   "BACKEND-BYTE-FASL-FILE-TYPE"
	   "BIG-ENDIAN-FASL-FILE-IMPLEMENTATION"
	   "*ASSEMBLY-OPTIMIZE*"
	   "LARGE-ALLOC"
	   "%SET-FUNCTION-SELF"
	   "IR2-COMPONENT-DYNCOUNT-INFO"
	   "DYNCOUNT-INFO" "DYNCOUNT-INFO-P"))
---------------
"BYTE-FASL-FILE-VERSION"
"*COMPILE-COMPONENT*"
"BLOCK-NUMBER"
"DYNCOUNT-INFO-COUNTS"
"BACKEND-BYTE-FASL-FILE-IMPLEMENTATION"
"IR2-BLOCK-BLOCK"
"DISASSEM-BYTE-COMPONENT"
"LITTLE-ENDIAN-FASL-FILE-IMPLEMENTATION"
"DYNCOUNT-INFO-COSTS"
"FUNCALLABLE-INSTANCE-LEXENV"
"DISASSEM-BYTE-FUN"
"VOP-BLOCK"
"BACKEND-BYTE-FASL-FILE-TYPE"
"BIG-ENDIAN-FASL-FILE-IMPLEMENTATION"
"*ASSEMBLY-OPTIMIZE*"
"LARGE-ALLOC"
"%SET-FUNCTION-SELF"
"IR2-COMPONENT-DYNCOUNT-INFO"
"DYNCOUNT-INFO" "DYNCOUNT-INFO-P")
)
+++ /home/matt/src/nightshade-0.0+/src/code/extensions.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/extensions.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/fd-stream.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/fd-stream.lisp.
+++++++++++++++
			   "Error opening ~S, ~A."
			   pathname
			   (unix:get-unix-error-msg errno)))
---------------
			  "Error opening ~S, ~A."
			  pathname
			  (unix:get-unix-error-msg errno)))
+++ /home/matt/src/nightshade-0.0+/src/code/fdefinition.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/fdefinition.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/filesys.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/filesys.lisp.
+++++++++++++++
          rename-file delete-file file-write-date file-author
	  file-mode))

(use-package "EXTENSIONS")

(in-package "EXTENSIONS")
(export '(print-directory print-files complete-file ambiguous-files
	  default-directory file-writable unix-namestring
	  map-files list-files))
---------------
          rename-file delete-file file-write-date file-author))

(use-package "EXTENSIONS")

(in-package "EXTENSIONS")
(export '(print-directory complete-file ambiguous-files default-directory
			  file-writable unix-namestring))
+++++++++++++++
;;;; Wildcard matching.

---------------
;;;; Wildcard matching stuff.

+++++++++++++++
      (enumerate-matches (name pathname nil
			       :verify-existance for-input
---------------
      (enumerate-matches (name pathname nil :verify-existance for-input
+++++++++++++++
      (error 'simple-file-error
---------------
      (error 'simple-file-error 
+++++++++++++++
---------------
;;;    Delete the file, Man.
;;;
+++++++++++++++
  "Return file's creation (FIX modified?) date in universal format, or NIL
   if it doesn't exist.  An error of type file-error is signaled if file is
   a wild pathname"
  (if (wild-pathname-p file)
      (error 'simple-file-error
---------------
  "Return file's creation date, or NIL if it doesn't exist.
 An error of type file-error is signaled if file is a wild pathname"
  (if (wild-pathname-p file)
      (error 'simple-file-error 
+++++++++++++++
;;; File-Mode  --  Public
;;;
(defun file-mode (file)
  "Returns the file mode, or nil on failure.  Signals an error of type
   file-error if file doesn't exist, or file is a wild pathname."
  (if (wild-pathname-p file)
      (error 'simple-file-error
	     :pathname file
	     "Bad place for a wild pathname.")
      (let ((name (unix-namestring (pathname file) t)))
	(unless name
	  (error 'simple-file-error
		 :pathname file
		 :format-control "~S doesn't exist."
		 :format-arguments (list file)))
	(multiple-value-bind (res dev ino mode)
			     (unix:unix-stat name)
	  (declare (ignore dev ino))
	  (if res mode)))))


;;;; DIRECTORY.

;;; ENUMERATE-NAMES  --  internal.
;;;
(defun enumerate-names (pathname &optional all follow-links backups recurse)
  "Returns a list of pathnames for Pathname." ;; FIX options
  (let ((results nil))
    (enumerate-search-list
     (pathname (merge-pathnames pathname
				(make-pathname :name :wild
					       :type :wild
					       :version :wild)))
     (enumerate-matches (name pathname nil :follow-links follow-links)
	(when (and (or backups
		       (if (or (char= (schar name (1- (length name))) #\~)
 			       (string= (pathname-type name) "BAK")
 			       (string= (pathname-type name) "CKP"))
			   nil
			   t))
		   (or all
		       (let ((slash (position #\/ name :from-end t)))
			 (or (null slash)
			     (= (1+ slash) (length name))
			     (char/= (schar name (1+ slash)) #\.)))))
	  (push name results))))
    (when recurse
      (dolist (name results)
	(when (eq (unix:unix-file-kind name) :directory)
	  (setq results
		(append results
			(enumerate-names (concatenate 'string name "/")
					 all follow-links backups t))))))
    results))
; (defun enumerate-names (pathname &optional all follow-links backups recurse &key test)
;   "Returns a list of pathnames for Pathname." ;; FIX options
;   (let ((results nil))
;     (enumerate-search-list
;      (pathname (merge-pathnames pathname
; 				(make-pathname :name :wild
; 					       :type :wild
; 					       :version :wild)))
;      (enumerate-matches (name pathname nil :follow-links follow-links)
; 	(when (and (or backups
; 		       (char/= (schar name (1- (length name))) #\~))
; 		   (or all
; 		       (let ((slash (position #\/ name :from-end t)))
; 			 (or (null slash)
; 			     (= (1+ slash) (length name))
; 			     (char/= (schar name (1+ slash)) #\.))))
; 		   ;; FIX speed?
; 		   (if test (funcall test name) t))
; 	  (push name results))))
;     (when recurse
;       (dolist (name results)
; 	(when (eq (unix:unix-file-kind name) :directory)
; 	  (setq results
; 		(append results
; 			(enumerate-names (concatenate 'string name "/")
; 					 all follow-links backups t :test test))))))
;     results))
  
(defun map-files (pathname function
		  &key (all t) follow-links (backups t) recurse)
  "Call Function on each file and directory in Pathname.
   Keys:
      all           if true include hidden files (files starting with a .)
      follow-links  if true follow symbolic links
      backups       if true include backup files (files ending in: ~ BAK CKP)
      recurse       if true recurse into subdirectories."
  (enumerate-search-list
   (pathname (merge-pathnames (directory-namestring pathname)
			      (make-pathname :name :wild
					     :type :wild
					     :version :wild)))
   (enumerate-matches (name pathname nil :follow-links follow-links)
     (when (and (or backups
		    (if (or (char= (schar name (1- (length name))) #\~)
			    (string= (pathname-type name) "BAK")
			    (string= (pathname-type name) "CKP"))
			nil
			t))
		(or all
		    (let ((slash (position #\/ name :from-end t)))
		      (or (null slash)
			  (= (1+ slash) (length name))
			  (if (char= (schar name (1+ slash)) #\.) nil t)))))
       (funcall function name))
     (if (and recurse (eq (unix:unix-file-kind name) :directory))
	 (map-files (concatenate 'string name "/") function
		    :all all :follow-links follow-links
		    :backups backups :recurse t)))))

(defun list-files (pathname &optional (predicate #'identity)
			    &key (all t) follow-links (backups t) recurse)
  "Return a list of all files and directories in Pathname that match Predicate.
   Keys:
      all           if true include hidden files (files starting with a .)
      follow-links  if true follow symbolic links
      backups       if true include backup files (files ending in a ~)
      recurse       if true recurse into subdirectories.
   Predicate is called on the file name."
  (let ((results ()))
    (enumerate-search-list
     (pathname (merge-pathnames (directory-namestring pathname)
				(make-pathname :name :wild
					       :type :wild
					       :version :wild)))
     (enumerate-matches (name pathname nil :follow-links follow-links)
	(when (and (or backups
		       (if (or (char= (schar name (1- (length name))) #\~)
			       (string= (pathname-type name) "BAK")
			       (string= (pathname-type name) "CKP"))
			   nil
			   t))
		   (or all
		       (let ((slash (position #\/ name :from-end t)))
			 (or (null slash)
			     (= (1+ slash) (length name))
			     (if (char= (schar name (1+ slash)) #\.) nil t))))
		   (funcall predicate name))
	  (push name results))
	(if (and recurse (eq (unix:unix-file-kind name) :directory))
	    (let ((files (list-files (concatenate 'string name "/") predicate
				     :all all :follow-links follow-links
				     :backups backups :recurse t)))
	      (if files
		  (setq results (append files results)))))))
    results))
  
;;; DIRECTORY  --  public.
;;;
(defun directory (pathname &key (all t) (check-for-subdirs t)
			   (truenamep t) (follow-links t) (backups t)
			   (recurse nil))
---------------

;;;; DIRECTORY.

;;; DIRECTORY  --  public.
;;; 
(defun directory (pathname &key (all t) (check-for-subdirs t)
			   (truenamep t) (follow-links t))
+++++++++++++++
   not followed.  If BACKUPS is true then backup files (files ending in ~) are
   also listed.  If RECURSE is true then pathnames of subdirectories are included,
   recursively."
  (let ((*ignore-wildcards* t))
    (mapcar #'(lambda (name)
		(let ((name (if (and check-for-subdirs
				     (eq (unix:unix-file-kind name)
					 :directory))
				(concatenate 'string name "/")
				name)))
		  (if truenamep (truename name) (pathname name))))
	    (sort (delete-duplicates (enumerate-names pathname
						      all follow-links
						      backups recurse)
				     :test #'string=) #'string<))))

---------------
   not followed."
  (let ((results nil))
    (enumerate-search-list
	(pathname (merge-pathnames pathname
				   (make-pathname :name :wild
						  :type :wild
						  :version :wild)))
      (enumerate-matches (name pathname nil :follow-links follow-links)
	(when (or all
		  (let ((slash (position #\/ name :from-end t)))
		    (or (null slash)
			(= (1+ slash) (length name))
			(char/= (schar name (1+ slash)) #\.))))
	  (push name results))))
    (let ((*ignore-wildcards* t))
      (mapcar #'(lambda (name)
		  (let ((name (if (and check-for-subdirs
				       (eq (unix:unix-file-kind name)
					   :directory))
				  (concatenate 'string name "/")
				  name)))
		    (if truenamep (truename name) (pathname name))))
	      (sort (delete-duplicates results :test #'string=) #'string<)))))

+++++++++++++++
;;;
(defun print-directory (pathname &optional stream &key all verbose return-list
				 (backups t) (recurse nil) coldefs)
  "Like Directory, but prints a terse, multi-coloumn directory listing
   instead of returning a list of pathnames.  When :all is supplied and
   non-nil, then Unix dot files are included too (as ls -a).  When :verbose
   is supplied and non-nil, then a long listing of miscellaneous
   information is output one file per line.  When :backups is supplied and
   true then backup files (files ending in ~) are included.  If :coldefs is
   nil outputs in the usual column format, otherwise outputs in the column
   format described by :coldefs."
  (let ((*standard-output* (out-synonym-of stream))
	(pathname pathname)
	(contents (directory pathname
			     :all all :check-for-subdirs (if verbose nil t)
			     :truenamep nil :backups backups :recurse recurse)))
    (if verbose
	(print-directory-verbose pathname contents all return-list coldefs)
	(print-directory-formatted pathname contents all return-list))))

;;; PRINT-FILES is exported from the EXTENSIONS package.
;;;
(defun print-files (files &optional stream &key verbose return-list coldefs)
  "Print the list of files FILES like Print-Directory prints a pathname.
   FILES may be a list of lists, where the first element is the file name
   and the rest is extra information (typically used by a column
   definition)."
  (let ((*standard-output* (out-synonym-of stream))
 	(pathname "/"))  ;; FIX maybe find longest common path
    (if verbose
	(print-directory-verbose pathname files nil return-list coldefs)
	(print-directory-formatted pathname files nil return-list return-list))))

;;; PRINT-MODE is internal.
;;;
(defun print-mode (mode)
  (macrolet ((frob (bit name &optional sbit sname negate)
	       `(if ,(if negate
			 `(not (logbitp ,bit mode))
			 `(logbitp ,bit mode))
		    ,(if sbit
			 `(if (logbitp ,sbit mode)
			      (write-char ,sname)
			      (write-char ,name))
			 `(write-char ,name))
		    (write-char #\-))))
    (frob 15 #\d nil nil t)
    (frob 8 #\r)
    (frob 7 #\w)
    (frob 6 #\x 11 #\s)
    (frob 5 #\r)
    (frob 4 #\w)
    (frob 3 #\x 10 #\s)
    (frob 2 #\r)
    (frob 1 #\w)
    (frob 0 #\x)))

(defun print-directory-verbose (pathname contents all return-list coldefs)
  (declare (ignore all)) ;; FIX is all for something?
  (let ((result nil)
	(dir-len (1+ (or (position #\/ (unix-namestring pathname)
				   :from-end t
				   :end (length (unix-namestring pathname))
				   :test #'char=)
			 -1))))
    (format t "v Directory of ~A :~%" (namestring pathname))
    (if coldefs
	;;; Print according to column definitions.
	(if (listp coldefs)
	    (dolist (file-or-more contents)
	      (let* ((file (if (listp file-or-more)
			       (car file-or-more)
			       file-or-more))
		     (namestring (unix-namestring file))
		     (tail (subseq namestring dir-len)))
		(multiple-value-bind
		    (reslt dev-or-err ino mode nlink uid gid rdev size atime mtime)
		    (unix:unix-lstat namestring)
		  (declare (ignore ino gid rdev atime)
			   (fixnum uid mode))
		  (if reslt
		      (progn
			(dolist (coldef coldefs)
			  (typecase coldef
			    (string (princ coldef))
			    (number
			     ;; Assume file-or-more is a list.
			     (princ (nth coldef file-or-more)))
			    (keyword
			     (case coldef
			       (:mode  (print-mode mode))
			       (:nlink (format t "~2D" nlink))
			       (:uid   (format t "~8A" (or (lookup-login-name uid) uid)))
			       (:size  (format t "~8D" size))
			       (:date  (format t "~12A" 
					       (multiple-value-bind (sec min hour date month year)
								    (get-decoded-time)
						 (declare (ignore sec min hour date month))
						 (decode-universal-time-for-files mtime year))))
			       (:name
				(if (= (logand mode unix:s-ifmt) unix:s-iflnk)
				    ;; FIX could print min part of link path
				    (let ((link (unix:unix-readlink namestring)))
				      (format t "~A~:[~;/~] --> ~A"
					      tail
					      (eq (unix:unix-file-kind link) :directory)
					      link))
				    (format t "~A~@[/~]"
					    tail
					    (= (logand mode unix:s-ifmt) unix:s-ifdir))))))))
			(terpri)
			(when return-list
			  (push (if (= (logand mode unix:s-ifmt) unix:s-ifdir)
				    (pathname (concatenate 'string namestring "/"))
				    file)
				result)))
		      (format t "Couldn't stat ~A -- ~A.~%"
			      tail
			      (unix:get-unix-error-msg dev-or-err))))))
	    (error "COLDEFS must be a list."))
	;;; Print the usual column format directly.
	(dolist (file contents)
	  (let* ((namestring (unix-namestring file))
		 (tail (subseq namestring dir-len)))
	    (multiple-value-bind
		(reslt dev-or-err ino mode nlink uid gid rdev size atime mtime)
		(unix:unix-lstat namestring)
	      (declare (ignore ino gid rdev atime)
		       (type (or fixnum null) uid mode))
	      (cond (reslt
		     ;;
		     ;; Print characters for file modes.
		     (print-mode mode)
		     ;;
		     ;; Print the rest.
		     (multiple-value-bind (sec min hour date month year)
					  (get-decoded-time)
		       (declare (ignore sec min hour date month))
		       (format t " ~2D ~8A ~8D ~12A ~A~@[/~]"
			       nlink
			       (or (lookup-login-name uid) uid)
			       size
			       (decode-universal-time-for-files mtime year)
			       tail
			       (= (logand mode unix:s-ifmt) unix:s-ifdir))
		       (if (= (logand mode unix:s-ifmt) unix:s-iflnk)
			   ;; FIX could print min part of link path
			   (let ((link (unix:unix-readlink namestring)))
			     (format t "~:[~;/~] --> ~A~%"
				     (eq (unix:unix-file-kind link) :directory)
				     link))
			   (format t "~%"))))
		    (t
		     (format t "Couldn't stat ~A -- ~A.~%"
			       tail
			       (unix:get-unix-error-msg dev-or-err))))
	      (when return-list
		(push (if (and mode
			       (or (= (logand mode unix:s-ifmt) unix:s-ifdir)
				   (and (= (logand mode unix:s-ifmt) unix:s-iflnk)
					(eq (unix:unix-file-kind
					     (unix:unix-readlink namestring))
					    :directory))))
			  (pathname (concatenate 'string namestring "/"))
			  file)
		      result))))))
---------------
;;; 
(defun print-directory (pathname &optional stream &key all verbose return-list)
  "Like Directory, but prints a terse, multi-coloumn directory listing
   instead of returning a list of pathnames.  When :all is supplied and
   non-nil, then Unix dot files are included too (as ls -a).  When :vervose
   is supplied and non-nil, then a long listing of miscellaneous
   information is output one file per line."
  (let ((*standard-output* (out-synonym-of stream))
	(pathname pathname))
    (if verbose
	(print-directory-verbose pathname all return-list)
	(print-directory-formatted pathname all return-list))))

(defun print-directory-verbose (pathname all return-list)
  (let ((contents (directory pathname :all all :check-for-subdirs nil
			     :truenamep nil))
	(result nil))
    (format t "Directory of ~A :~%" (namestring pathname))
    (dolist (file contents)
      (let* ((namestring (unix-namestring file))
	     (tail (subseq namestring
			   (1+ (or (position #\/ namestring
					     :from-end t
					     :test #'char=)
				   -1)))))
	(multiple-value-bind 
	    (reslt dev-or-err ino mode nlink uid gid rdev size atime mtime)
	    (unix:unix-stat namestring)
	  (declare (ignore ino gid rdev atime)
		   (fixnum uid mode))
	  (cond (reslt
		 ;;
		 ;; Print characters for file modes.
		 (macrolet ((frob (bit name &optional sbit sname negate)
			      `(if ,(if negate
					`(not (logbitp ,bit mode))
					`(logbitp ,bit mode))
				   ,(if sbit
					`(if (logbitp ,sbit mode)
					     (write-char ,sname)
					     (write-char ,name))
					`(write-char ,name))
				   (write-char #\-))))
		   (frob 15 #\d nil nil t)
		   (frob 8 #\r)
		   (frob 7 #\w)
		   (frob 6 #\x 11 #\s)
		   (frob 5 #\r)
		   (frob 4 #\w)
		   (frob 3 #\x 10 #\s)
		   (frob 2 #\r)
		   (frob 1 #\w)
		   (frob 0 #\x))
		 ;;
		 ;; Print the rest.
		 (multiple-value-bind (sec min hour date month year)
				      (get-decoded-time)
		   (declare (ignore sec min hour date month))
		   (format t "~2D ~8A ~8D ~12A ~A~@[/~]~%"
			   nlink
			   (or (lookup-login-name uid) uid)
			   size
			   (decode-universal-time-for-files mtime year)
			   tail
			   (= (logand mode unix:s-ifmt) unix:s-ifdir))))
		(t (format t "Couldn't stat ~A -- ~A.~%"
			   tail
			   (unix:get-unix-error-msg dev-or-err))))
	  (when return-list
	    (push (if (= (logand mode unix:s-ifmt) unix:s-ifdir)
		      (pathname (concatenate 'string namestring "/"))
		      file)
		  result)))))
+++++++++++++++
(defun print-directory-formatted (pathname result all return-list)
---------------
(defun print-directory-formatted (pathname all return-list)
+++++++++++++++
	(dir-len (1+ (or (position #\/ (unix-namestring pathname)
				   :from-end t
				   :end (length (unix-namestring pathname))
				   :test #'char=)
			 -1))))
---------------
	(result (directory pathname :all all :truenamep nil)))
+++++++++++++++
	     (slash-name (subseq name dir-len))
---------------
	     (length (length name))
	     (end (if (and (plusp length)
			   (char= (schar name (1- length)) #\/))
		      (1- length)
		      length))
	     (slash-name (subseq name
				 (1+ (or (position #\/ name
						   :from-end t
						   :end end
						   :test #'char=)
					 -1))))
+++++++++++++++
	     (cond ((null good-files)
		    (setf files good-files))   ;; FIX why? added via pd-attempt
---------------
	     (cond ((null good-files))
+++++++++++++++
;;;
---------------
;;; 
+++ /home/matt/src/nightshade-0.0+/src/code/final.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/final.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/float-trap.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/float-trap.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/float.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/float.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/foreign.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/foreign.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/format-time.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/format-time.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/format.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/format.lisp.
+++++++++++++++
    ~A or ~nA     Prints one argument as if by PRINC
    ~S or ~nS     Prints one argument as if by PRIN1
    ~D or ~nD     Prints one argument as a decimal integer
    ~%            Does a TERPRI
    ~&            Does a FRESH-LINE

     where n is the width of the field in which the object is printed.
  
---------------
        ~A or ~nA     Prints one argument as if by PRINC
        ~S or ~nS     Prints one argument as if by PRIN1
        ~D or ~nD     Prints one argument as a decimal integer
        ~%            Does a TERPRI
        ~&            Does a FRESH-LINE

         where n is the width of the field in which the object is printed.
  
+++++++++++++++
  Other directives include:

     ~C            Prints a character  (with : prints #\  as Space)
     ~T            Prints a tab

     ~:[...~;...~] Prints first alternative if argument is true, else second
     ~@(...~)      Prints contents of braces (...) as a capitalized string
     ~:@(...~)     Prints contents of braces (...) in upper case
     ~P            Prints an s if the argument is plural (> 0), else ""
     ~:P           Prints an s if the previous argument is plural, else ""

FIX
     ~@<...>       Splice?
~&~@<Warning:  ~3i~:_~A~:>~%
~,2f
~@[~* including the header~]
~@[~A~]   print arg if arg is true
(:short \"~D/~D/~2,'0D\")			;;  MM/DD/YY
   ~2,'0D turns 9 into 09
~36R   1 = 1, 35 = Z, 36 = 10

     Printing of numeric arguments
       ~B            Binary
       ~O            Octal
       ~X            Hexadecimal
       ~:D           Decimal with commas, e.g. 30,000
       ~R            Words, e.g. one hundred
       ~@R           Roman numerals.

  FIX FORMAT has many additional capabilities."
---------------
  FORMAT has many additional capabilities not described here.  Consult
  Section 22.3 (Formatted Output) of the ANSI Common Lisp standard for
  details."
+++ /home/matt/src/nightshade-0.0+/src/code/gc.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/gc.lisp.
+++++++++++++++
  (declare (optimize (speed 3) (safety 0) (inhibit-warnings 3)))
---------------
  (declare (optimize (speed 3) (safety 0)(inhibit-warnings 3)))
+++++++++++++++
;;; The number of generations.
;;; 
#+gencgc
(defconstant *gc-generations* 6
  "The number of generations.")

---------------
+++++++++++++++
(in-package "UNIX")    ;; FIX

(alien:def-alien-type nil
   (struct alloc-region
	   (free-pointer (* t))
	   (end-addr (* t))
	   (first-page c-call:int)
	   (last-page c-call:int)
	   (start-addr (* t))))

(alien:def-alien-type lispobj
		      #-alpha c-call:unsigned-long
		      #+alpha #| FIX |# c-call:u32)

;; FIX Linux
(alien:def-alien-type os-vm-address-t unix::caddr-t)
(alien:def-alien-type os-vm-size-t unix::size-t)
(alien:def-alien-type os-vm-offset-t unix::off-t)
(alien:def-alien-type os-vm-prot-t c-call:int)
(defvar read-only-space-start #x10000000)

;; FIX Hack, defined in gencgc.c.
(alien:def-alien-variable "os_vm_prot_read" os-vm-prot-t)
(alien:def-alien-variable "os_vm_prot_write" os-vm-prot-t)
(alien:def-alien-variable "os_vm_prot_execute" os-vm-prot-t)
(alien:def-alien-variable "os_vm_prot_all" os-vm-prot-t)

(alien:def-alien-routine os-protect c-call:void
			 (addr os-vm-address-t)
			 (len os-vm-size-t)
			 (protection os-vm-prot-t))

; FIX next 3 generated from vm::*primitive-objects* into internals.h

(alien:def-alien-type nil
   (struct scavenger-hook
	   (header lispobj)
	   (value lispobj)
	   (function lispobj)
	   (next (* (struct scavenger-hook)))))

(alien:def-alien-type nil
   (struct code
	   (header lispobj)
	   (code-size lispobj)
	   (entry-points lispobj)
	   (debug-info lispobj)
	   (trace-table-offset lispobj)
	   (constants (array lispobj 1))))

(alien:def-alien-type nil
   (struct function
	   (header lispobj)
	   (self lispobj)
	   (next lispobj)
	   (name lispobj)
	   (arglist lispobj)
	   (type lispobj)
	   (code (array c-call:unsigned-char 1))))


(alien:def-alien-type nil
   (struct generation
	   ;; The first page that gc-alloc checks on its next call.
	   (alloc-start-page c-call:int)
	   ;; The first page that gc-alloc-unboxed checks on its next
	   ;; call.
	   (alloc-unboxed-start-page c-call:int)
	   ;; The first page that gc-alloc-large (boxed) considers on
	   ;; its next call.  Although it always allocates after the
	   ;; boxed-region.
	   (alloc-large-start-page c-call:int)
	   ;; The first page that gc-alloc-large (unboxed) considers on
	   ;; its next call.  Although it always allocates after the
	   ;; current-unboxed-region.
	   (alloc-large-unboxed-start-page c-call:int)
	   ;; The bytes allocate to this generation.
	   (bytes-allocated c-call:int)
	   ;; The number of bytes at which to trigger a GC
	   (gc-trigger c-call:int)
	   ;; To calculate a new level for gc-trigger
	   (bytes-consed-between-gc c-call:int)
	   ;; The number of GCs since the last raise.
	   (num-gc c-call:int)
	   ;; The average age at after which a GC will raise objects to
	   ;; the next generation.
	   (trigger-age c-call:int)
	   ;; The cumulative sum of the bytes allocated to this
	   ;; generation. It is cleared after a GC on this generations,
	   ;; and update before new objects are added from a GC of a
	   ;; younger generation. Dividing by the bytes-allocated will
	   ;; give the average age of the memory in this generation
	   ;; since its last GC.
	   (cum-sum-bytes-allocated c-call:int)
	   ;; A minimum average memory age before a GC will occur helps
	   ;; prevent a GC when a large number of new live objects have
	   ;; been added, in which case a GC could be a waste of time.
	   (min-av-mem-age c-call:double)))

(alien:def-alien-type nil
   (struct page
	   ;; Page flags.
	   (flags c-call:unsigned-int)

	   ;; It is important to know the offset to the first object in the
	   ;; page.  Currently it's only important to know if an object
	   ;; starts at the begining of the page in which case the offset
	   ;; would be 0
	   (first-object-offset c-call:int)
  
	   ;; The number of bytes of this page that are used. This may be
	   ;; less than the actual bytes used for pages within the current
	   ;; allocation regions. It should be 0 for all unallocated pages
	   ;; (not hard to achieve).
	   (bytes-used c-call:int)))


(alien:def-alien-variable "alien_nil" (* t))

(alien:def-alien-variable "boxed_region" (struct alloc-region))
(alien:def-alien-variable "unboxed_region" (struct alloc-region))

(alien:def-alien-variable "current_region_free_pointer" (* t))
(alien:def-alien-variable "current_region_end_addr" (* t))

(defvar num-generations 6)

(alien:def-alien-variable "generations" (array (struct generation) 7))

(alien:def-alien-variable "gencgc_oldest_gen_to_gc" c-call:unsigned-int)

(alien:def-alien-variable "gc_alloc_generation" c-call:int)

(alien:def-alien-variable "last_free_page" c-call:int)

(alien:def-alien-variable "page_table" (* (struct page)))

(alien:def-alien-variable "heap_base" (* t))

(alien:def-alien-variable "dynamic_space_pages" c-call:unsigned-int)

(alien:def-alien-variable "undefined_tramp" int)

(alien:def-alien-variable "bytes_allocated" c-call:unsigned-long)

(alien:def-alien-variable "from_space" c-call:int)
(alien:def-alien-variable "new_space" c-call:int)

#+()
(alien:def-alien-routine valid-dynamic-space-pointer c-call:int
			 (pointer (* lispobj)))

(alien:def-alien-routine fpu-save c-call:void
			 (fpu-state (* t)))
(alien:def-alien-routine fpu-restore c-call:void
			 (fpu-state (* t)))

;; FIX this calls ~back into lisp
(alien:def-alien-routine funcall0 c-call:void
			 (function lispobj))

(defvar verify-dynamic-code-check nil
  "Enable the printing of a note when code objects are found in the dynamic
   space during a heap verify.")

(defvar pre-verify-gen-0 nil
  "Enable a pre-scan verify of generation 0 before it's GCed.")

(defvar gencgc-verbose 0
 "The verbose level. All non-error messages are disabled at level 0;
  and only a few rare messages are printed at level 1.")

;; NetBSD on x86 has no way to retrieve the faulting address in the SIGSEGV
;; handler, so for the moment we can't use page protection.
(defvar enable-page-protection #-netbsd t #+netbsd nil
 "Enable the use of page protection to help avoid the scavenging of pages
  that don't have pointers to younger generations.")

; (alien:def-alien-routine hack-ptr (* c-call:void)
;  			 (obj (* c-call:void)))
; (alien:def-alien-routine hack-ptr (* c-call:void)
;  			 (obj (* c-call:void)))
; (alien:def-alien-routine hack-ptr (* c-call:void)
; 			 (obj (* t)))

(defvar lowtag-bits 3)
(defvar lowtag-mask (1- (ash 1 lowtag-bits)))
 
(defun ptr (addr)
  (sap-alien (int-sap (logand (sap-int (alien-sap addr))
			      (logcom lowtag-mask)))
	     (* t)))

#+()
(alien:def-alien-routine lose c-call:void)
#+()
(defmacro gc-assert (&rest body)
  "Continue only if body is true."
  `(or (progn ,@body) (lose)))      ;; FIX Does (lose) work?
(defmacro gc-assert (&rest body)
  "Continue only if body is true."
  (declare (ignore body)))

;; Set when the page is write protected. If it is writen into it is made
;; writable and this flag is cleared. This should always reflect the actual
;; write-protect status of a page.

(defvar page-write-protected-mask #x00000010)

;; Page allocated flag: 0 for a free page; 1 when allocated. If the page is
;; free then the following slots are invalid - well the bytes-used must be
;; 0.

(defvar page-allocated-mask #x00000040)

(defmacro page-allocated-p (page)
  `(if (zerop (logand (slot (deref page-table ,page) 'flags)
		      page-allocated-mask))
       nil t))

;; The generation that this page belongs to. This should be valid for all
;; pages that may have objects allocated, even current allocation region
;; pages - this allows the space of an object to be easily determined.

(defvar page-generation-mask #x0000000f)

(defmacro page-generation (page)
  `(logand (slot (deref page-table ,page) 'flags) page-generation-mask))

(defmacro page-flags (page mask)
  `(logand (slot (deref page-table ,page) 'flags) ,mask))

;; Unboxed region flag: 1 for unboxed objects, 0 for boxed objects.

(defvar page-unboxed-mask #x00000080)
(defvar page-unboxed-shift 7)

(defmacro page-unboxed-p (page)
  `(if (zerop (logand (slot (deref page-table ,page) 'flags)
		      page-unboxed-mask))
       nil t))

(defmacro page-unboxed-val (page)
  `(ash (logand (slot (deref page-table ,page) 'flags)
		page-unboxed-mask)
	(- page-unboxed-shift)))

;; If this page should not be moved during a GC then this flag is set. It's
;; only valid during a GC for allocated pages.

(defvar page-dont-move-mask #x00000100)
(defmacro page-dont-move-p (page)
  `(if (zerop (logand (slot (deref page-table ,page) 'flags)
		      page-dont-move-mask))
       nil t))

;; If the page is part of a large object then this flag is set. No other
;; objects should be allocated to these pages. This is only valid when the
;; page is allocated.

(defvar page-large-object-mask #x00000200)
(defvar page-large-object-shift 9)

(defmacro page-large-object-p (page)
  `(if (zerop (logand (slot (deref page-table ,page) 'flags)
		      page-large-object-mask))
       nil t))

(defvar page-size 4096
  "The smallest page size that can be independently allocated and write
   protected.")

(alien:def-alien-routine page-address (* t)
			 (page-num c-call:int))

(defmacro page-address-sap (page-num)
  "Calculate the start address for the given page number."
  `(sap+ (alien-sap heap-base) (* page-size ,page-num)))

(declaim (inline find-page-index))

(defun find-page-index (addr)
  "Find the page index within the page-table for the given address.  Return
   -1 on failure."
  (let ((index (- (sap-int (alien-sap addr))
		  (sap-int (alien-sap heap-base)))))
    (when (>= index 0)
      (setq index (truncate (/ index page-size)))
      (if (< index dynamic-space-pages)
	  (return-from find-page-index index))))
  -1)

(defun count-write-protect-generation-pages (generation)
  ;; Count the number of write protected pages within the given generation.
  (let ((cnt 0))
    (loop
      for mmask = (logior page-allocated-mask
			  page-write-protected-mask
			  page-generation-mask)
      for mflags = (logior page-allocated-mask
			   page-write-protected-mask
			   generation)
      for i from 0 to (1- last-free-page)
      do
      (if (equal (page-flags i mmask) mflags)
	  (incf cnt)))
    cnt))

(defun count-generation-pages (generation)
  ;; Count the number of pages within the given generation.
  (let ((cnt 0))
    (loop
      for mmask = (logior page-allocated-mask page-generation-mask)
      for mflags = (logior page-allocated-mask generation)
      for i from 0 to (1- last-free-page)
      do
      (if (equal (page-flags i mmask) mflags)
	  (incf cnt)))
    cnt))

(defun generation-bytes-allocated (generation)
  "Work through the pages and add up the number of bytes used for the given
   generation."
  (let ((bytes-allocated 0))
    (loop
      for mmask = (logior page-allocated-mask page-generation-mask)
      for mflags = (logior page-allocated-mask generation)
      for i from 0 to (1- last-free-page)
      do
      (if (equal (page-flags i mmask) mflags)
	  (incf bytes-allocated (slot (deref page-table i) 'bytes-used))))
    bytes-allocated))

(defun gen-av-mem-age (gen)
  (if (eq (slot (deref generations gen) 'bytes-allocated) 0)
      0.0d0)

  (/ (coerce (slot (deref generations gen) 'cum-sum-bytes-allocated)
	     'double-float)
     (coerce (slot (deref generations gen) 'bytes-allocated)
	     'double-float)))

(defmacro pointerp (obj)
  `(if (zerop (logand ,obj #x01)) nil t))

(defvar type-bits 8)
(defvar type-mask (1- (ash 1 type-bits)))
(defmacro vm-type-id-of (object)
  `(logand ,object type-mask))
(defmacro header-value (object)
  `(ash (- type-bits) ,object))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Scavenging/transporting routines derived from gc.c

;; FIX from internals.h
(alien:def-alien-type nil
   (struct weak-pointer
	   (header lispobj)
	   (value lispobj)
	   (broken lispobj)
	   (next (* (struct weak-pointer)))))

;static int (*scavtab[256])(lispobj *where, lispobj object);
;static lispobj (*transother[256])(lispobj object);
(alien:def-alien-variable "sizetab"
			  (array (* (function c-call:int (* lispobj)))
				 256))

(alien:def-alien-variable "weak_pointers" (* (struct weak-pointer)))

(alien:def-alien-variable "scavenger_hooks" (* (struct scavenger-hook)))

(defmacro gc-ceiling (x y) `(logand (+ ,x (1- ,y)) (logcom (1- ,y))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(defun print-ptr (addr)
  "Print out some information about the pointer at ADDR."
  ;; If addr is in the dynamic space then print out the page information.
  (let ((pi1 (find-page-index addr)))
    (or (equal pi1 -1)
	(format *stderr*
		"  ~X: page ~D  alloc ~D unboxed ~D gen ~D  bytes-used ~D  offset ~D  dont-move ~D~%"
		addr pi1 (page-allocated-p pi1) (page-unboxed-p pi1)
		(page-generation pi1)
		(slot (deref page-table pi1) 'bytes-used)
		(slot (deref page-table pi1) 'first-object-offset)
		(page-dont-move-p pi1)))
    (flet ((off- (addr offset)
	     (deref (sap-alien (sap+ (alien-sap addr)
				     (- (* offset (alien-size lispobj :bytes))))
			       (* lispobj))))
	   (off+ (addr offset)
	     (deref (sap-alien (sap+ (alien-sap addr)
				     (* offset (alien-size lispobj :bytes)))
			       (* lispobj)))))
      (format *stderr*
	      "  ~X ~X ~X ~X (~X) ~X ~X ~X ~X~%"
	      (off- addr 4) (off- addr 3) (off- addr 2) (off- addr 1)
	      (off- addr 0)
	      (off+ addr 1) (off+ addr 2) (off+ addr 3) (off+ addr 4)))))

(alien:def-alien-routine verify-space c-call:void
			 (start (* lispobj))
			 (words unix::size-t))

#+()
(defun verify-space (start words)
  (declare (type (alien (* lispobj)) start))
  (let ((dynamic-space (if (eq (find-page-index start) -1) nil t))
	(readonly-space (and (<= read-only-space-start
				 (sap-int (alien-sap start)))
			     (< (sap-int (alien-sap start))
				lisp::*read-only-space-free-pointer*))))
    (loop
      for count = 1 then 1
      for thing = (deref start) then (deref start)
      while (> words 0)
      do
      (if (pointerp thing)
	  (let ((page-index (find-page-index
			     (sap-alien (int-sap thing) (* t))))
		(to-readonly-space
		 (and (<= read-only-space-start thing)
		      (< thing
			 lisp::*read-only-space-free-pointer*)))
		(to-static-space
		 (and (<= (lisp::static-space-start)
			  thing)
		      (< thing
			 lisp::*static-space-free-pointer*))))
	    
	    (if (equal page-index -1)
		;; Verify that thing points to a valid space.
		(or to-readonly-space
		    to-static-space
		    (equal thing
			   (sap-int (alien-sap (addr undefined-tramp))))
		    (progn
		      (format *stderr*
			      "*** Ptr ~X @ ~X sees Junk~%"
			      thing start)
		      (print-ptr start)))
		;; Thing points into dynamic space.
		(progn
		  ;; If it's within the dynamic space it should point to a
		  ;; used page.  X Could check the offset too.
		  (when (and (page-allocated-p page-index)
			     (zerop (slot (deref page-table page-index)
					  'bytes-used)))
		    (format *stderr*
			    "*** Ptr ~X @ ~X sees free page.~%"
			    thing start)
		    (print-ptr start))

		  ;; Check whether it points to a forwarding pointer!
		  (when (equal (deref (cast (ptr thing) (* lispobj)))
			       #x01)
		    (format *stderr*
			    "*** Ptr %x @ %x sees forwarding ptr.\n"
			    thing start)
		    (print-ptr start))
		  
		  ;; Check that its not in the RO space as it would then be
		  ;; a pointer from the RO to the dynamic space.
		  (when readonly-space
		    (format *stderr*
			    "*** Ptr to dynamic space %x, from RO space %x\n"
			    thing start)
		    (print-ptr start))
		  
		  ;; Does it point to a plausible object? This check slows
		  ;; it down a lot.
		  #+()
		  (or (valid-dynamic-space-pointer (cast thing (* lispobj)))
		      (progn
			(format *stderr*
				"*** Ptr %x to invalid object %x\n"
				thing start)
			(print-ptr start))))))

	  (or (zerop (logand thing #x3)) ; Skip fixnums.
	      (eval ;; FIX convert verify-space to macro? maybe gen verify-space via a macro
	       `(case (vm-type-id-of (deref start))

		  ;; Boxed objects.
		  ((,vm::simple-vector-type
		    ,vm::ratio-type ,vm::complex-type
		    ,vm::simple-array-type ,vm::complex-string-type
		    ,vm::complex-bit-vector-type
		    ,vm::complex-vector-type
		    ,vm::complex-array-type
		    ,vm::closure-header-type
		    ,vm::funcallable-instance-header-type
		    ,vm::byte-code-function-type
		    ,vm::byte-code-closure-type
		    ,vm::dylan-function-header-type
		    ,vm::value-cell-header-type
		    ,vm::symbol-header-type ,vm::base-char-type
		    ,vm::unbound-marker-type
		    ,vm::instance-header-type ,vm::fdefn-type
		    ,vm::scavenger-hook-type)
		   (setq count 1))

		  ((,vm::code-header-type)
		   (let ((object (deref start))
			 (code (cast start (* (struct code)))))
		     ;; Check that it's not in the dynamic space.
		     (if (and dynamic-space
			      ;; It's ok if it's byte compiled code.  The
			      ;; trace table offset will be a fixnum if
			      ;; it's x86 compiled code - check.
			      (zerop (logand (slot code 'trace-table-offset)
					     #x3))
			      ;; Only when enabled.
			      verify-dynamic-code-check)
			 (format *stderr*
				 "*** Code object at ~X in the dynamic space~%"
				 start))
		     
		     (let ((nheader-words (header-value object))
			   (nwords (gc-ceiling
				    (+ (fixnum-value (slot code
							   'code-size))
				       nheader-words) 2)))
		       ;; Scavenge the boxed section of the code data
		       ;; block.
		       (verify-space (sap-alien (sap+ (alien-sap start)
						      (alien-size lispobj :bytes))
						(* lispobj))
				     (1- nheader-words))
		       ;; Scavenge the boxed section of each function
		       ;; object in the code data block.
		       (loop
			 for fheaderl = (slot code 'entry-points)
			 do
			 (if (equal fheaderl alien-nil) (return))
			 (let ((fheaderp (cast (ptr fheaderl)
					       (struct function *))))
			   (gc-assert
			    (equal (vm-type-id-of (slot fheaderp
							'header))
				   vm:function-header-type))
			   (verify-space (addr (slot fheaderp 'name)) 1)
			   (verify-space (addr (slot fheaderp 'arglist) 1))
			   (verify-space (addr (slot fheaderp 'type)) 1)
			   (setq fheaderl (slot fheaderp 'next))))
		       (setq count nwords))))
	       
		  ;; Unboxed objects.
		  ((vm::bignum-type
		    vm::single-float-type
		    vm::double-float-type
		    #+long-float vm::long-float-type
		    ; FIX all these
		    ;#ifdef type_ComplexSingleFloat
		    vm::complex-single-float-type
		    ;#ifdef type_ComplexDoubleFloat
		    vm::complex-double-float-type
		    ;#ifdef type_ComplexLongFloat
		    vm::complex-long-float-type
		    vm::simple-string-type
		    vm::simple-bit-vector-type
		    vm::simple-array-unsigned-byte-2-type
		    vm::simplearrayunsigned-byte-4-type
		    vm::simple-array-unsigned-byte8-type
		    vm::simple-array-unsigned-byte16-type
		    vm::simple-array-unsigned-byte32-type
		    ;#ifdef type_SimpleArraySignedByte8
		    vm::simple-array-signed-byte-8-type
		    ;#ifdef type_SimpleArraySignedByte16
		    vm::simple-array-signed-byte-16-type
		    ;#ifdef type_SimpleArraySignedByte30
		    vm::simple-array-signed-byte-30-type
		    ;#ifdef type_SimpleArraySignedByte32
		    vm::simple-array-signed-byte-32-type
		    vm::simple-array-single-float-type
		    vm::simple-array-double-float-type
		    ;#ifdef type_SimpleArrayComplexLongFloat
		    vm::simple-array-long-float-type
		    ;#ifdef type_SimpleArrayComplexSingleFloat
		    vm::simple-array-complex-single-float-type
		    ;#ifdef type_SimpleArrayComplexDoubleFloat
		    vm::simple-array-complex-double-float-type
		    ;#ifdef type_SimpleArrayComplexLongFloat
		    vm::simple-array-complex-long-float-type
		    vm::sap-type vm::weak-pointer-type)
		   (setq count
			 (alien-funcall (deref sizetab
					       (vm-type-id-of (deref start)))
					start)))

		  (t (gc-abort))))))
	  
      (setq start
	    (sap-alien (sap+ (alien-sap start)
			     (* count (alien-size lispobj :bytes)))
		       (* lispobj)))
      (decf words count))))

#+()
(alien:def-alien-routine verify-generation1 c-call:int
			 (i c-call:int)
			 (last-page c-call:int)
			 (region-unboxed c-call:int)
			 (generation c-call:int))

#+()
(alien:def-alien-routine verify-space1 c-call:void
			 (page unix::int)
			 (words unix::size-t))

(alien:def-alien-routine verify-generation c-call:void
			 (generation c-call:int))

#+()
(defun verify-generation (generation)
  (loop for page from 0 to (1- last-free-page) do
    (when (page-allocated-p page)
      (or (zerop (slot (deref page-table page) 'bytes-used))
	  (when (equal (page-generation page) generation)
	    (let ((last-page page)
		  (region-unboxed (page-unboxed-p page)))

	      ;; This should be the start of a contiguous block.
	      (gc-assert (zerop (slot (deref page-table page)
				      'first-object-offset)))

; FIX for tracing
;  	      (setq last-page
;  		    (verify-generation1 page last-page (if region-unboxed 1 0)
;  					generation))

	      ;; Need to find the full extent of this contiguous block in
	      ;; case objects span pages.

	      ;; Now work forward until the end of this contiguous area is
	      ;; found.
	      (loop
		;; Check if this is the last page in this contiguous block.
		;; FIX Or it is page-size and is the last in the block.
		while (and (>= (slot (deref page-table last-page) 'bytes-used)
			       page-size)
			   (page-allocated-p (1+ last-page))
			   (eq (page-unboxed-p (1+ last-page)) region-unboxed))
		do

		(if (or (zerop (slot (deref page-table (1+ last-page))
				     'bytes-used))
			(if (equal (page-generation (1+ last-page))
				   generation)
			    (zerop (slot (deref page-table (1+ last-page))
					 'first-object-offset))
			    (return)))
		    (return))

		(incf last-page))

	      (verify-space (sap-alien (page-address-sap page) (* lispobj))
			    (/ (+ (slot (deref page-table last-page) 'bytes-used)
				  (* page-size (- last-page page)))
			       4))

; 	      (verify-space1 page
; 			     (/ (+ (slot (deref page-table last-page) 'bytes-used)
; 				   (* page-size (- last-page page)))
; 				4))

;; (call to c version)
;; FIX causes segfs, like page-address in write-protect-generation-pages
; 	      (verify-space (sap-alien (page-address-sap page) (* lispobj))
; 			    (/ (+ (slot (deref page-table last-page) 'bytes-used)
; 				  (* page-size (- last-page page)))
; 			       4))

	      (setq page last-page)))))))

(defun print-generation-stats (verbose)
  "Verbose controls how much to print out: 0 for normal level of detail; 1
   for debugging."
  (let (;; Number of generations to print out.
	(gens (if verbose num-generations (1+ num-generations))))
    (with-alien ((fpu-state (array c-call:int 27)))
      ;; This code uses the FP instructions which may be setup for Lisp so
      ;; they need to be saved and reset for C.
      (fpu-save (cast fpu-state (* t)))
      ;; Print the heap stats.
      (format *stderr*
	      "   Generation Boxed Unboxed LB   LUB    Alloc  Waste   Trig    WP  GCs Mem-age~%")
      (loop for i from 0 to (1- gens) do
	(let ((boxed-cnt 0) (unboxed-cnt 0)
	      (large-boxed-cnt 0) (large-unboxed-cnt 0))
	  (loop for j from 0 to (1- last-free-page)
	        for flags = (slot (deref page-table j) 'flags)
	        do
	    (when (equal (logand flags page-generation-mask) i)
	      (or (zerop (logand flags page-allocated-mask))
		  ;; Count the number of boxed and unboxed pages within the
		  ;; given generation.
		  (if (zerop (logand flags page-unboxed-mask))
		      (if (zerop (logand flags page-large-object-mask))
			  (incf boxed-cnt)
			  (incf large-boxed-cnt))
		      (if (zerop (logand flags page-large-object-mask))
			  (incf unboxed-cnt)
			  (incf large-unboxed-cnt))))))

	  (gc-assert (equal (slot (deref generations i) 'bytes-allocated)
			    (generation-bytes-allocated i)))

	  (format *stderr*
		  ;; FIX last was %7.4f
		  "   ~8D ~5D ~5D ~5D ~5D ~8D ~5D ~8D ~4D ~3D ~12,4F~%"
		  i boxed-cnt unboxed-cnt large-boxed-cnt large-unboxed-cnt
		  (slot (deref generations i) 'bytes-allocated)
		  (- (* page-size (count-generation-pages i))
		     (slot (deref generations i) 'bytes-allocated))
		  (slot (deref generations i) 'gc-trigger)
		  (count-write-protect-generation-pages i)
		  (slot (deref generations i) 'num-gc)
		  (gen-av-mem-age i))))

      (format *stderr* "   Total bytes alloc=~D~%" (lisp::dynamic-usage))

      (fpu-restore (cast fpu-state (* t))))))

(alien:def-alien-routine write-protect-generation-pages c-call:void
			 (generation c-call:int))

#+()
(alien:def-alien-routine write-protect-generation-pages1 c-call:void
			 (page-start (* t))
			 (i c-call:int))

(alien:def-alien-routine os-protect1 c-call:void
			 (page c-call:int)
			 (len os-vm-size-t)
			 (protection os-vm-prot-t))

#+()
(defun write-protect-generation-pages (generation)
  "Write protect all the dynamic boxed pages in the given generation."
  (gc-assert (< generation num-generations))
  (loop for i from 0 to (1- last-free-page) do
    (when (page-allocated-p i)
      (or (page-unboxed-p i)
	  (zerop (slot (deref page-table i) 'bytes-used))
	  (when (equal (page-generation i) generation)

;	    (format t "(page-address ~S): .~S.~%" i (page-address i))

;	    (write-protect-generation-pages1 i)
;	    (write-protect-generation-pages1 (page-address i) i)
; 	    (write-protect-generation-pages1 (sap-alien (page-address-sap i)
; 							(* t)))

 	    (os-protect1 i
 			 page-size
 			 (logior os-vm-prot-read os-vm-prot-execute))

;; FIX these ~segfs
; 	    (os-protect (sap-alien (page-address-sap i) os-vm-address-t)
; 	    (os-protect (page-address-sap i)
; 	    (os-protect (cast (page-address i) os-vm-address-t)
; 	    (os-protect (alien-sap (page-address i))
; 	    (os-protect (sap-int (alien-sap (page-address i)))  ; type err
; 			page-size
;  			(logior os-vm-prot-read os-vm-prot-execute))

	    ;; Note the page as protected in the page tables.
	    (setf (slot (deref page-table i) 'flags)
		  (logior (slot (deref page-table i) 'flags)
			  page-write-protected-mask))))))
  (when (> gencgc-verbose 1)
    (format *stderr*
	    "Write protected ~D of ~D pages in generation ~D.~%"
	    (count-write-protect-generation-pages generation)
	    (count-generation-pages generation)
	    generation)))

(alien:def-alien-routine update-x86-dynamic-space-free-pointer c-call:void)

;; FIX confirm that this is tested
#+()
(defun update-x86-dynamic-space-free-pointer ()
  "Update last-free-page then ALLOCATION_POINTER."
  (let ((last-page -1))
    (loop for i from 0 to dynamic-space-pages do
      (if (page-allocated-p i)
	  (or (zerop (slot (deref page-table i) 'bytes-used))
	      (setq last-page i))))
    (setq last-free-page (1+ last-page)))
  (setq vm::*allocation-pointer*
	(+ (sap-int (alien-sap heap-base)) (* page-size last-free-page))))

; (alien:def-alien-routine call-garbage-collect-generation c-call:void
; 			 (last-gen c-call:unsigned-int)
; 			 (gen c-call:int)
; 			 (raise c-call:int))

; (alien:def-alien-routine garbage-collect-generation c-call:void
; 			 (generation c-call:int)
; 			 (raise c-call:int))

(alien:def-alien-routine collect-garbage1 c-call:int
;(alien:def-alien-routine collect-garbage1 c-call:void
;			 (last-gen c-call:unsigned-int)
			 (last-gen c-call:int)
 			 (gen c-call:int)
 			 (raise c-call:int)
)

(alien:def-alien-routine collect-garbage2 c-call:void
			 (last-gen c-call:unsigned-int)
 			 (gen c-call:int)
 			 (raise c-call:int))

;; If the record_new_objects flag is 2 then all new regions created
;; are recorded.
;;
;; If it's 1 then then it is only recorded if the first page of the
;; current region is <= new_areas_ignore_page.  This helps avoid
;; unnecessary recording when doing full scavenge pass.
;;
;; The new_object structure holds the page, byte offset, and size of
;; new regions of objects. Each new area is placed in the array of
;; these structures pointed to by new_areas; new_areas_index holds the
;; offset into new_areas.
;;
;; If new_area overflows NUM_NEW_AREAS then it stops adding them.  The
;; later code must detect this and handle it, probably by doing a full
;; scavenge of a generation.

(alien:def-alien-routine add-new-area c-call:void
			 (first-page c-call:int)
			 (offset c-call:int)
			 (size c-call:int))

; (defvar num-new-areas 512)
; (alien:def-alien-variable "record_new_objects" c-call:int)
; (alien:def-alien-variable "new_areas_ignore_page" c-call:int)
; (alien:def-alien-type nil
;    (struct new-area
; 	   (page c-call:int)
; 	   (offset c-call:int)
; 	   (size c-call:int)))
; (alien:def-alien-variable "new_areas" (* (* (struct new-area))))
; (alien:def-alien-variable "new_areas_index" c-call:int)
; (alien:def-alien-variable "max_new_areas" c-call:int)

#+()
(defun add-new-area (first-page offset size)
  "Add a new area to new-areas."

  ;; Ignore if full.
  (if (>= new-areas-index num-new-areas)
      (return-from add-new-area))

  (cond
    ((equal record-new-objects 0)
     (return-from add-new-area))
    ((equal record-new-objects 1)
     (if (> first-page new-areas-ignore-page)
	 (return-from add-new-area)))
    ((equal record-new-objects 2))
    (t (gc-abort)))

  (let ((new-area-start (+ (* page-size first-page) offset)))

    ;; Search backwards for a prior area that this follows from.  If found
    ;; this will save adding a new area.
  
    (loop for i = (1- new-areas-index) then (1- i)
          for c = 0 then (1+ c)
          while (and (>= i 0) (< c 8)) do
      (let ((area-end (+ (* page-size
			    (slot (deref (deref new-areas) i) 'page))
			 (slot (deref (deref new-areas) i) 'offset)
			 (slot (deref (deref new-areas) i) 'size))))
	#+()
	(format *stderr* "*S1 ~D ~D ~D ~D~%" i c new-area-start area-end)
	(when (equal new-area-start area-end)
	  #+()
	  (format *stderr*
		  "-> Adding to [~D] ~D ~D ~D with ~D ~D ~D:~%"
		  i
		  (slot (deref (deref new-areas) i) 'page)
		  (slot (deref (deref new-areas) i) 'offset)
		  (slot (deref (deref new-areas) i) 'size)
		  first-page offset size)
	  (incf (slot (deref (deref new-areas) i) 'size) size)
	  (return-from add-new-area))))
    #+()
    (format *stderr* "*S1 ~D ~D ~D~%" i c new-area-start)

    (setf (slot (deref (deref new-areas) new-areas-index) 'page)
	  first-page)
    (setf (slot (deref (deref new-areas) new-areas-index) 'offset)
	  offset)
    (setf (slot (deref (deref new-areas) new-areas-index) 'size)
	  size)
    #+()
    (format *stderr*
	    "  new-area ~D page ~D offset ~D size ~D~%"
	    new-areas-index first-page offset size)
    (incf new-areas-index)

    ;; Note the max new-areas used.
    (if (> new-areas-index max-new-areas)
	(setq max-new-areas new-areas-index))))

(alien:def-alien-routine gc-alloc-update-page-tables c-call:void
			 (unboxed c-call:int)
			 (alloc-region (* (struct alloc-region))))

#+()
(defun gc-alloc-update-page-tables (unboxed alloc-region)
  "Update the tables for the Alloc-region.  The region may be added to the
   new-areas.

   When done the Alloc-region is setup so that the next quick alloc will
   fail safely and thus a new region will be allocated.  Further it is safe
   to try and re-update the page table of this reset Alloc-region.

   Unboxed must be 0 or 1 (unboxed)."
;  (declare (type (alien (* (struct alloc-region))) alloc-region))
  (declare (debug 3))

  #+()
  (format *stderr* "gc-alloc-update-page-tables to gen ~D: "
	  gc-alloc-generation)

  (let ((first-page (slot (deref alloc-region) 'first-page)))

    ;; Catch an unused alloc-region.
    (if (and (zerop first-page)
	     (equal (slot (deref alloc-region) 'last-page) -1))
	(return-from gc-alloc-update-page-tables))

    (let ((next-page (1+ first-page)))

      (if (equal (sap-int (alien-sap (slot (deref alloc-region) 'free-pointer)))
		 (sap-int (alien-sap (slot (deref alloc-region) 'start-addr))))
	  ;; No bytes allocated.  Unallocate the first-page if there are 0
	  ;; bytes-used.
	  (if (zerop (slot (deref page-table first-page) 'bytes-used))
	      (setf (slot (deref page-table first-page) 'flags)
		    (logand (slot (deref page-table first-page) 'flags)
			    (logcom page-allocated-mask))))
	  (let ((orig-first-page-bytes-used
		 (slot (deref page-table first-page) 'bytes-used))
		(byte-cnt 0)
		(more))

	    (gc-assert
	     (equal (sap-int (alien-sap (slot (deref alloc-region) 'start-addr)))
		    (+ (sap-int (alien-sap (page-address first-page)))
		       (sap-int (alien-sap (slot (deref page-table first-page)
						 'bytes-used))))))

	    ;; All the pages used need to be updated

	    ;; Update the first page.

	    #+() (format *stderr* "0")

	    ;; If the page was free then setup the gen, and
	    ;; first-object-offset.
	    (if (zerop (slot (deref page-table first-page) 'bytes-used))
		(gc-assert (zerop (slot (deref (page-table first-page)
					       'first-object-offset)))))

	    (gc-assert (page-allocated-p first-page))
	    (gc-assert (equal (page-unboxed-val first-page) unboxed))
	    (gc-assert (equal (page-generation first-page)
			      gc-alloc-generation))
	    (gc-assert (if (page-large-object-p first-page) nil t))

	    ;; Calc. the number of bytes used in this page. This is not
	    ;; always the number of new bytes, unless it was free.
    
	    (let ((bytes-used (- (sap-int (alien-sap (slot (deref alloc-region)
							   'free-pointer)))
				 (sap-int (alien-sap (page-address first-page))))))
	      (when (> bytes-used page-size)
		(setq bytes-used page-size)
		(setq more t))
	      (setf (slot (deref page-table first-page) 'bytes-used)
		    bytes-used)
	      (incf byte-cnt bytes-used)

	      ;; All the rest of the pages should be free. Need to set
	      ;; their first-object-offset pointer to the start of the
	      ;; region, and set the bytes-used.
    
	      (loop while more do
		#+() (format *stderr* "+")

		(gc-assert (page-allocated-p next-page))
		(gc-assert (equal (page-unboxed-val next-page) unboxed))
		(gc-assert (zerop (slot (deref page-table next-page)
					'bytes-used)))
		(gc-assert (equal (page-generation next-page)
				  gc-alloc-generation))
		(gc-assert (if (page-large-object next-page) nil t))

		(gc-assert (equal (slot (deref page-table next-page)
					'first-object-offset)
				  (- (sap-int (alien-sap (slot (deref alloc-region)
							       'start-addr)))
				     (sap-int (alien-sap (page-address next-page))))))

		;; Calc. the number of bytes used in this page.
		(setq more nil)
		(setq bytes-used (- (sap-int (alien-sap (slot (deref alloc-region)
							      'free-pointer)))
				    (sap-int (alien-sap (page-address next-page)))))
		(when (> bytes-used page-size)
		  (setq bytes-used page-size)
		  (setq more t))
		(setf (slot (deref page-table next-page) 'bytes-used)
		      bytes-used)
		(incf byte-cnt bytes-used)

		(incf next-page))

	      (let ((region-size (- (sap-int (alien-sap (slot (deref alloc-region)
							      'free-pointer)))
				    (sap-int (alien-sap (slot (deref alloc-region)
							      'start-addr))))))
		(incf bytes-allocated region-size)
		(incf (slot (deref generations gc-alloc-generation)
			    'bytes-allocated)
		      region-size)

		(gc-assert (equal (- byte-cnt orig-first-page-bytes-used)
				  region-size))
    
		;; Set the generations alloc restart page to the last page
		;; of the region.
		(if (zerop unboxed)
		    (setf (slot (deref generations gc-alloc-generation)
				'alloc-start-page)
			  (1- next-page))
		    (setf (slot (deref generations gc-alloc-generation)
				'alloc-unboxed-start-page)
			  (1- next-page)))

		;; Add the region to the new-areas if requested.
		(if (zerop unboxed)
		    (add-new-area first-page
				  orig-first-page-bytes-used
				  region-size))

		#+()
		(format *stderr*
			"  gc-alloc-update-page-tables update ~D bytes to gen ~D~%"
			region-size gc-alloc-generation)))))

      ;; Unallocate any unused pages.
      (loop
	while (<= next-page (slot (deref alloc-region) 'last-page)) do
	(gc-assert (zerop (slot (deref page-table next-page)
				'bytes-used)))
	(setf (slot (deref page-table next-page) 'flags)
	      (logand (slot (deref page-table next-page) 'flags)
		      (logcom page-allocated-mask)))
	(incf next-page))))

  ;; Reset the alloc-region.
  (setf (slot (deref alloc-region) 'first-page) 0)
  (setf (slot (deref alloc-region) 'last-page) -1)
  (setf (slot (deref alloc-region) 'start-addr) (page-address 0))
  (setf (slot (deref alloc-region) 'free-pointer) (page-address 0))
  (setf (slot (deref alloc-region) 'end-addr) (page-address 0))

  #+() (format *stderr* "~%"))

(alien:def-alien-routine unprotect-oldspace c-call:void)

;; Un-write-protect all the pages in from-space. This is done at the
;; start of a GC else there may be many page faults while scavenging
;; the newspace (I've seen drive the system time to 99%). These pages
;; would need to be unprotected anyway before unmapping in
;; free-oldspace; not sure what effect this has on paging?.
#+()
(defun unprotect-oldspace ()
  (loop for i from 0 to (1- last-free-page) do
    (if (page-allocated-p i)
	(or (zerop (slot (deref page-table i) 'bytes-used))
	    (when (equal (page-generation i) from-space)
	      (let ((page-start (page-address i)))
		;; Remove any write protection.  Should be able to rely on
		;; the WP flag to avoid redundant calls.
		(when (page-write-protected-p i) {
		  (os-protect page-start page-size os-vm-prot-all)
		  (setf (slot (deref page-table i) 'flags)
			(logand (slot (deref page-table i) 'flags)
				(logcom page-write-protected-mask))))))))))

#|
;; Garbage collect a generation. If raise is 0 the remains of the
;; generation are not raised to the next generation.
(defun garbage-collect-generation(int generation int raise)

  unsigned long i
  unsigned long read-only-space-size static-space-size

  (gc-assert (<= generation (1- NUM-GENERATIONS)))

  ;; The oldest generation can't be raised.
  (gc-assert (if (equal generation (1- num-generations)) (zerop raise) t))

  ;; Initialise the weak pointer list.
  (setq weak-pointers (sap-alien (int-sap 0) (* (struct weak-pointer))))

  ;; When a generation is not being raised it is transported to a
  ;; temporary generation (NUM-GENERATIONS), and lowered when
  ;; done. Setup this new generation. There should be no pages
  ;; allocated to it yet.
  
  (if (zerop raise)
      (gc-assert (zerop (slot (deref generations num-generations)
			      'bytes-allocated))))

  ;; Set the global src and dest. generations.
  (setq from-space generation)
  (setq new-space (if (zerop raise)
		      NUM-GENERATIONS
		      (1+ generation)))

  ;; Change to a new space for allocation, reseting the alloc-start-page.

  (setq gc-alloc-generation new-space)
  (setq (slot (deref generations new-space) 'alloc-start-page) 0)
  (setq (slot (deref generations new-space) 'alloc-unboxed-start-page) 0)
  (setq (slot (deref generations new-space) 'alloc-large-start-page) 0)
  (setq (slot (deref generations new-space) 'alloc-large-unboxed-start-page) 0)

  ;; Before any pointers are preserved, the dont-move flags on the pages
  ;; need to be cleared.
  
  (loop for i from 0 to (1- last-free-page) do
    (setq (slot (deref page-table i) 'flags)
	  (logand (slot (deref page-table i) 'flags)
		  (logcom page-dont-move-mask))))

  ;; Un-write-protect the old-space pages. This is essential for the
  ;; promoted pages as they may contain pointers into the old-space which
  ;; need to be scavenged. It also helps avoid unnecessary page faults as
  ;; forwarding pointer are written into them. They need to be un-protected
  ;; anyway before unmapping later.
  
  (unprotect-oldspace)

  ;; Scavenge the stacks conservative roots.
  {
    lispobj **ptr
    for (ptr = (lispobj **) CONTROL-STACK-END - 1;
	 ptr > (lispobj **) &raise; ptr--)
      preserve-pointer(*ptr)
  }
#ifdef CONTROL-STACKS
  scavenge-thread-stacks()
#endif

  if (gencgc-verbose > 1) {
    int num-dont-move-pages = count-dont-move-pages()
    fprintf(stderr "Non-movable pages due to conservative pointers = %d %d bytes\n"
	    num-dont-move-pages PAGE-SIZE * num-dont-move-pages)
  }

  ;; Scavenge all the rest of the roots.

  ;;
  ;; Scavenge the Lisp functions of the interrupt handlers, taking
  ;; care to avoid SIG-DFL, SIG-IGN.
  

  for (i = 0; i < NSIG; i++) {
    union interrupt-handler handler = interrupt-handlers[i]
    if ((handler.c != SIG-IGN) && (handler.c != SIG-DFL))
      scavenge((lispobj *) (interrupt-handlers + i) 1)
  }

  ;; Scavenge the binding stack.
  scavenge(binding-stack
	   (lispobj *) SymbolValue(BINDING-STACK-POINTER) - binding-stack)

  ;;
  ;; Scavenge the scavenge-hooks in case this refers to a hook added
  ;; in a prior generation GC. From here on the scavenger-hook will
  ;; only be updated with hooks already scavenged so this only needs
  ;; doing here.
  

  scavenge((lispobj *) &scavenger-hooks 1)

  if (SymbolValue(SCAVENGE-READ-ONLY-SPACE) != NIL) {
    read-only-space-size = (lispobj *) SymbolValue(READ-ONLY-SPACE-FREE-POINTER)
      - read-only-space
    fprintf(stderr "Scavenge read only space: %d bytes\n"
	    read-only-space-size * sizeof(lispobj))
    scavenge(read-only-space read-only-space-size)
  }

  static-space-size = (lispobj *) SymbolValue(STATIC-SPACE-FREE-POINTER)
    - static-space
  if (gencgc-verbose > 1)
    fprintf(stderr "Scavenge static space: %d bytes\n"
	    static-space-size * sizeof(lispobj))
  scavenge(static-space static-space-size)

  ;;
  ;; All generations but the generation being GCed need to be
  ;; scavenged. The new-space generation needs special handling as
  ;; objects may be moved in - it is handle separately below.
  
  for (i = 0; i < NUM-GENERATIONS; i++)
    if (i != generation && i != new-space)
      scavenge-generation(i)

  ;;
  ;; Finally scavenge the new-space generation.  Keep going until no
  ;; more objects are moved into the new generation.
  
  scavenge-newspace-generation(new-space)

#define RESCAN-CHECK 0
#if RESCAN-CHECK  
  ;;
  ;; As a check re-scavenge the newspace once; no new objects should
  ;; be found.
  
  {
    int old-bytes-allocated = bytes-allocated
    int bytes-allocated

    ;; Start with a full scavenge
    scavenge-newspace-generation-one-scan(new-space)

    scavenge((lispobj *) &scavenger-hooks 1)

    ;; Flush the current regions updating the tables.
    gc-alloc-update-page-tables(0 &boxed-region)
    gc-alloc-update-page-tables(1 &unboxed-region)

    bytes-allocated = bytes-allocated - old-bytes-allocated

    if (bytes-allocated != 0)
      fprintf(stderr "*** rescan of new-space allocated % more bytes?\n"
	      bytes-allocated)
  }
#endif

  scan-weak-pointers()

  ;; Flush the current regions updating the tables.
  gc-alloc-update-page-tables(0 &boxed-region)
  gc-alloc-update-page-tables(1 &unboxed-region)

  ;; Free the pages in oldspace, but not those marked dont-move.
  free-oldspace()

  ;;
  ;; If the GC is not raising the age then lower the generation back
  ;; to its normal generation number.
  
  if (!raise) {
    for (i = 0; i < last-free-page; i++)
      if (page-table[i].bytes-used != 0
	  && PAGE-GENERATION(i) == NUM-GENERATIONS)
	PAGE-FLAGS-UPDATE(i PAGE-GENERATION-MASK generation)
    gc-assert(generations[generation].bytes-allocated == 0)
    generations[generation].bytes-allocated = generations[NUM-GENERATIONS].bytes-allocated
    generations[NUM-GENERATIONS].bytes-allocated = 0
  }

  ;; Reset the alloc-start-page for generation.
  generations[generation].alloc-start-page = 0
  generations[generation].alloc-unboxed-start-page = 0
  generations[generation].alloc-large-start-page = 0
  generations[generation].alloc-large-unboxed-start-page = 0

  if(generation >= verify-gens) {
    if (gencgc-verbose)
      fprintf(stderr "Checking\n")
    verify-gc()
    verify-dynamic-space()
  }

  ;; Set the new gc trigger for the GCed generation
  generations[generation].gc-trigger = generations[generation].bytes-allocated + generations[generation].bytes-consed-between-gc


  ;; If the generation was raised clear num-gc
  if (raise)
    generations[generation].num-gc = 0
  else
    ;; Else increase it.
    generations[generation].num-gc++
}
|#

(alien:def-alien-routine call-gc-alloc-update-page-tables c-call:void)

(defun collect-garbage (#+gencgc last-gen)
  #-gencgc
  (unix:unix-exit 1)

  (setf (slot boxed-region 'free-pointer) current-region-free-pointer)

  (when (> last-gen lisp::*gc-generations*)
;     (format *stderr*
; 	    "** collect-garbage: last-gen = ~A. Doing a level 0 GC.~%"
; 	    last-gen)
    (setq last-gen 0))

  (call-gc-alloc-update-page-tables)

#|
  FIX even w the c version of gc-a-u-p-t this segfs when used to build another sys

;  (format *stdout* "boxed-region: ~S~%" boxed-region)
  (gc-alloc-update-page-tables 0 (alien:sap-alien (alien:alien-sap boxed-region)
						  (* (struct alloc-region))))
;  (gc-alloc-update-page-tables 0 (sap-int (alien-sap (alien:addr boxed-region))))
;  (gc-alloc-update-page-tables 0 (alien:addr boxed-region))
;  (gc-alloc-update-page-tables 0 (alien:alien-sap (alien:addr boxed-region)))
  (gc-alloc-update-page-tables 1 (alien:sap-alien (alien:alien-sap unboxed-region)
						  (* (struct alloc-region))))
;  (gc-alloc-update-page-tables 1 (sap-int (alien-sap (alien:addr unboxed-region))))
;  (gc-alloc-update-page-tables 1 (alien:addr unboxed-region))
;  (gc-alloc-update-page-tables 1 (alien:alien-sap (alien:addr unboxed-region)))
|#

  ;; Verify the new objects created by lisp code.
  (when pre-verify-gen-0
    (format *stderr* "Pre-Checking generation 0~%")
    (verify-generation 0))

  (if (> gencgc-verbose 1)
      (print-generation-stats 0))

  ;; FIX new-genesis.lisp, end of emit-c-header-aux
  (setq scavenger-hooks alien-nil)
;  (setq scavenger-hooks (cast alien-nil (* (struct scavenger-hook)))) ; quick error
;  (setq scavenger-hooks nil) ; result is alien at #x00000000
;  (format *stdout* "s-h after ~S~%" scavenger-hooks)  ; FIX printing causes ~segf!

;  (collect-garbage1 last-gen)

  (let ((gen 0) (raise))
;    (collect-garbage1 last-gen gen 0))

    (loop
      ;; Collect the generation.

      ;; Only raise the generation if there is an older one.
      (setq raise
	    (if (>= gen gencgc-oldest-gen-to-gc)
		0
		(if (< gen last-gen)
		    1
		    ;; Only raise if the age is >= the trigger age.
		    (if (>= (slot (deref generations gen) 'num-gc)
			    (slot (deref generations gen) 'trigger-age))
			1 0))))

      (if (> gencgc-verbose 1)
	  (format *stderr*
		  "Starting GC of generation ~D with raise=~D alloc=~D trig=~D GCs=~D~%"
		  gen
		  raise
		  (slot (deref generations gen) 'bytes-allocated)
		  (slot (deref generations gen) 'gc-trigger)
		  (slot (deref generations gen) 'num-gc)))
      
      ;; If an older generation is being filled then update its memory
      ;; age.
      
      (if (eq raise 1)
	  (incf (slot (deref generations (1+ gen)) 'cum-sum-bytes-allocated)
		(slot (deref generations (1+ gen)) 'bytes-allocated)))

;; FIX works using c from here to before incf (last night)
;; FIX err this way (today)

      (collect-garbage1 last-gen gen raise)

;      (garbage-collect-generation gen raise)       ; "trying to write prot. gen. 1 when gen. 0 is..."
;      (call-garbage-collect-generation gen raise)  ; "trying to write prot. gen. 1 when gen. 0 is..."
;      (call-garbage-collect-generation last-gen gen raise)

;      (collect-garbage1 last-gen gen raise)
      
;       ;; Reset the memory age cum-sum.
;       (setf (slot (deref generations gen) 'cum-sum-bytes-allocated) 0)
;       
;       (when (> gencgc-verbose 1)
; 	(format *stderr* "GC of generation ~D finished:~%" gen)
; 	(print-generation-stats 0))
      
      (incf gen)
      
      (or (and (<= gen gencgc-oldest-gen-to-gc)
	       (or (< gen last-gen)
		   (and (<= gen gencgc-oldest-gen-to-gc) ;; FIX just checked?
			raise
			(> (slot (deref generations gen) 'bytes-allocated) 
			   (slot (deref generations gen) 'gc-trigger))
			(> (gen-av-mem-age gen)
			   (slot (deref generations gen) 'min-av-mem-age)))))
	  (return)))

      (collect-garbage2 last-gen gen raise)

;     ;; Now if gen-1 was raised all generations before gen are empty. If
;     ;; it wasn't raised then all generations before gen-1 are empty.
;     ;;
;     ;; Now objects within this gen's pages cannot pointer to younger
;     ;; generations unless they are written to. This can be exploited by
;     ;; write protecting the pages of gen; then when younger generations
;     ;; are GCed only the page written need scanning.
;     (let ((gen-to-wp (if (zerop raise) (1- gen) gen)))
;       ;; Not much point in WPing pages in generation 0 as it is never
;       ;; scavenged (except promoted pages).
;       (when (and (> gen-to-wp 0) enable-page-protection)
; 	;; Check that they are all empty.
; 	(loop for i from 0 upto (1- gen-to-wp) do
; 	  (or (zerop (slot (deref generations i) 'bytes-allocated))
; 	      (format *stderr*
; 	      "*** trying to write prot. gen. ~D when gen. ~D is not empty~%"
; 		      gen-to-wp i)))
; 	(write-protect-generation-pages gen-to-wp))
; 
; ;; FIX close let here
; 
; ;     (collect-garbage1 0)
; 
;       ;; Set gc-alloc back to generation 0. The current regions should be
;       ;; flushed after the above GCs.
;       (gc-assert (eq (- (slot boxed-region 'free-pointer)
; 			(slot boxed-region 'start-addr))
; 		     0))
;       (setq gc-alloc-generation 0)
; 
;       (update-x86-dynamic-space-free-pointer)
; 
;       (setq current-region-free-pointer (slot boxed-region 'free-pointer))
;       (setq current-region-end-addr (slot boxed-region 'end-addr))
; 
;       ;; Call the scavenger hook functions.
;       (with-alien ((sh (* (struct scavenger-hook))
; 		       (cast (ptr scavenger-hooks)
; 			     (* (struct scavenger-hook)))))
; 	(loop
; 	  (if (equal (sap-int (alien-sap sh))
; 		     (sap-int (alien-sap (ptr alien-nil))))
; 	      (return))
; 	  (with-alien ((sh-next (* (struct scavenger-hook))
; 				(cast (ptr (slot (deref sh) 'next))
; 				      (* (struct scavenger-hook)))))
; 	    (funcall0 (slot (deref sh) 'function))
; 	    (setf (slot (deref sh) 'next)
; 		  ;; FIX assuming (a-s-m 0) always allocs at 0x0
; ;		  (sap-alien (int-sap 0)
; 		  (sap-alien (allocate-system-memory 0)
; 			     (* (struct scavenger-hook))))
; 	    (setq sh sh-next))))
;       (setq scavenger-hooks (cast alien-nil (* (struct scavenger-hook))))
;       )
  )
  )

(defun test-gc ()
  "Create a random list and a random vector many times, returning some of
   the created elements."
  (let ((result)
	(*random-state* (make-random-state)))
    (loop for i from 0 to 50 do
      (let* ((list-size (1+ (random 500)))
	     (vector-size (1+ (random 250)))
	     (list ())
	     (vector (make-array (1+ vector-size))))
	(loop for i from 0 to (1+ list-size) do
	  (setq list (cons (random 10000) list))
	  (let ((rand (random 8)))
	    (cond ((eq rand 0)
		   (setf (aref vector (random vector-size)) t))
		  ((eq rand 1)
		   (setf (aref vector (random vector-size))
			 (random 250)))
		  ((eq rand 2)
		   (setf (aref vector (random vector-size))
			 "test string"))
		  ((eq rand 3)
		   (let ((sublist ()))
		     (loop for i from 0 to (random 20) do
		       (setq sublist (cons (random 100000) sublist)))
		     (setf (aref vector (random vector-size))
			   sublist)))
		  ((eq rand 4)
		   (setf (aref vector (random vector-size))
			 (car list)))
;			 (nth (random (max 1 i)) list)))
		  ((eq rand 5)
		   (setf (aref vector (random vector-size))
			 (make-array (* (1+ (random 4)) page-size)
				     :initial-element (random 7777))))
		  ((eq rand 6)
		   (setf (aref vector (random vector-size))
			 (make-random-state t))))))
	(if (equal (type-of (car list)) (type-of (aref vector 0)))
	    (push (cons (car list) (aref vector 0)) result))))
    result))

(alien:def-alien-routine collect-garbage c-call:int
			 #+gencgc (last-gen c-call:int))



(in-package "LISP")

; (alien:def-alien-routine collect-garbage c-call:int
;   #+gencgc (last-gen c-call:int))

; (defun collect-garbage (#+gencgc last-gen)
;   (unix::collect-garbage1 #+gencgc last-gen))

(defun collect-garbage (#+gencgc last-gen)
  (unix::collect-garbage #+gencgc last-gen))

#-ibmrt
(alien:def-alien-routine set-auto-gc-trigger c-call:void
  (dynamic-usage c-call:unsigned-long))

#+ibmrt
(defun set-auto-gc-trigger (bytes)
  (let ((words (ash (+ (current-dynamic-space-start) bytes) -2)))
    (unless (and (fixnump words) (plusp words))
      (clear-auto-gc-trigger)
      (warn "Attempt to set GC trigger to something bogus: ~S" bytes))
    (setf rt::*internal-gc-trigger* words)))

#-ibmrt
(alien:def-alien-routine clear-auto-gc-trigger c-call:void)

#+ibmrt
(defun clear-auto-gc-trigger ()
  (setf rt::*internal-gc-trigger* -1))

;;;
;;; *INTERNAL-GC*
;;;
;;; This variables contains the function that does the real GC.  This is
;;; for low-level GC experimentation.  Do not touch it if you do not
;;; know what you are doing.
;;; 
(defvar *internal-gc* #'collect-garbage)


;;;; SUB-GC

;;;
;;; CAREFULLY-FUNCALL -- Internal
;;;
;;; Used to carefully invoke hooks.
;;; 
(defmacro carefully-funcall (function &rest args)
  `(handler-case (funcall ,function ,@args)
     (error (cond)
       (warn "(FUNCALL ~S~{ ~S~}) lost:~%~A" ',function ',args cond)
       nil)))

;;;
;;; SUB-GC -- Internal
;;;
;;; SUB-GC decides when and if to do a garbage collection.  The
;;; VERBOSE-P flag controls whether or not the notify functions are
;;; called.  The FORCE-P flags controls if a GC should occur even if the
;;; dynamic usage is not greater than *GC-TRIGGER*.
;;; 
;;; For GENCGC all generations < GEN will be GC'ed.
;;;
(defun sub-gc (&key (verbose-p *gc-verbose*) force-p #+gencgc (gen 0))
  (unless *already-maybe-gcing*
    (let* ((*already-maybe-gcing* t)
	   (start-time (get-internal-run-time))
	   (pre-gc-dyn-usage (dynamic-usage)))
      (unless (integerp (symbol-value '*bytes-consed-between-gcs*))
	;; The noise w/ symbol-value above is to keep the compiler from
	;; optimizing the test away because of the type declaim for
	;; *bytes-consed-between-gcs*.
	(warn "The value of *BYTES-CONSED-BETWEEN-GCS*, ~S, is not an ~
	       integer.  Reseting it to ~D." *bytes-consed-between-gcs*
	       default-bytes-consed-between-gcs)
	(setf *bytes-consed-between-gcs* default-bytes-consed-between-gcs))
      (when (and *gc-trigger* (> pre-gc-dyn-usage *gc-trigger*))
	(setf *need-to-collect-garbage* t))
      (when (or force-p
		(and *need-to-collect-garbage* (not *gc-inhibit*)))
	(when (and (not force-p)
		   *gc-inhibit-hook*
		   (carefully-funcall *gc-inhibit-hook* pre-gc-dyn-usage))
	  (setf *gc-inhibit* t)
	  (return-from sub-gc nil))
	(without-interrupts
	  (let ((*standard-output* *terminal-io*))
	    (when verbose-p
	      (carefully-funcall *gc-notify-before* pre-gc-dyn-usage))
	    (dolist (hook *before-gc-hooks*)
	      (carefully-funcall hook))
	    (when *gc-trigger*
	      (clear-auto-gc-trigger))
	    #-gencgc (funcall *internal-gc*)
	    #+gencgc (if (eq *internal-gc* #'collect-garbage)
			 (funcall *internal-gc* gen)
			 (funcall *internal-gc*))
	    (let* ((post-gc-dyn-usage (dynamic-usage))
		   (bytes-freed (- pre-gc-dyn-usage post-gc-dyn-usage)))
	      (when *last-bytes-in-use*
		(incf *total-bytes-consed*
		      (- pre-gc-dyn-usage *last-bytes-in-use*))
		(setq *last-bytes-in-use* post-gc-dyn-usage))
	      (setf *need-to-collect-garbage* nil)
	      (setf *gc-trigger*
		    (+ post-gc-dyn-usage *bytes-consed-between-gcs*))
	      (set-auto-gc-trigger *gc-trigger*)
	      (dolist (hook *after-gc-hooks*)
		(carefully-funcall hook))
	      (when verbose-p
		(carefully-funcall *gc-notify-after*
				   post-gc-dyn-usage bytes-freed
				   *gc-trigger*))))
	  (scrub-control-stack)))
      (incf *gc-run-time* (- (get-internal-run-time) start-time))))
  nil)

;;;
;;; MAYBE-GC -- Internal
;;; 
;;; This routine is called by the allocation miscops to decide if a GC
;;; should occur.  The argument, object, is the newly allocated object
;;; which must be returned to the caller.
;;; 
(defun maybe-gc (&optional object)
  (sub-gc)
  object)

;;;
;;; GC -- Exported
;;;
;;; This is the user advertised garbage collection function.
;;; 
#-gencgc
(defun gc (&optional (verbose-p *gc-verbose*))
  "Initiates a garbage collection.  The optional argument, VERBOSE-P,
  which defaults to the value of the variable *GC-VERBOSE* controls
  whether or not GC statistics are printed."
  (sub-gc :verbose-p verbose-p :force-p t))
;;;
#+gencgc
(defun gc (&key (verbose *gc-verbose*) (gen 0) (full nil))
  "Initiates a garbage collection.  The keyword :VERBOSE, which
   defaults to the value of the variable *GC-VERBOSE* controls whether or
   not GC statistics are printed. The keyword :GEN defaults to 0, and
   controls the number of generations to garbage collect."
  (sub-gc :verbose-p verbose :force-p t :gen (if full *gc-generations* gen)))


;;;; Auxiliary Functions.

(defun bytes-consed-between-gcs ()
  "Return the amount of memory that will be allocated before the next garbage
   collection is initiated.  This can be set with SETF."
  *bytes-consed-between-gcs*)
;;;
(defun %set-bytes-consed-between-gcs (val)
  (declare (type index val))
  (let ((old *bytes-consed-between-gcs*))
    (setf *bytes-consed-between-gcs* val)
    (when *gc-trigger*
      (setf *gc-trigger* (+ *gc-trigger* (- val old)))
      (cond ((<= (dynamic-usage) *gc-trigger*)
	     (clear-auto-gc-trigger)
	     (set-auto-gc-trigger *gc-trigger*))
	    (t
	     (system:scrub-control-stack)
	     (sub-gc)))))
  val)
;;;
(defsetf bytes-consed-between-gcs %set-bytes-consed-between-gcs)


(defun gc-on ()
  "Enables the garbage collector."
  (setq *gc-inhibit* nil)
  (when *need-to-collect-garbage*
    (sub-gc))
  nil)

(defun gc-off ()
  "Disables the garbage collector."
  (setq *gc-inhibit* t)
  nil)



;;;; Initialization stuff.

(defun gc-init ()
  (when *gc-trigger*
    (if (< *gc-trigger* (dynamic-usage))
	(sub-gc)
	(set-auto-gc-trigger *gc-trigger*))))
---------------
(alien:def-alien-routine collect-garbage c-call:int
  #+gencgc (last-gen c-call:int))

#-ibmrt
(alien:def-alien-routine set-auto-gc-trigger c-call:void
  (dynamic-usage c-call:unsigned-long))

#+ibmrt
(defun set-auto-gc-trigger (bytes)
  (let ((words (ash (+ (current-dynamic-space-start) bytes) -2)))
    (unless (and (fixnump words) (plusp words))
      (clear-auto-gc-trigger)
      (warn "Attempt to set GC trigger to something bogus: ~S" bytes))
    (setf rt::*internal-gc-trigger* words)))

#-ibmrt
(alien:def-alien-routine clear-auto-gc-trigger c-call:void)

#+ibmrt
(defun clear-auto-gc-trigger ()
  (setf rt::*internal-gc-trigger* -1))

;;;
;;; *INTERNAL-GC*
;;;
;;; This variables contains the function that does the real GC.  This is
;;; for low-level GC experimentation.  Do not touch it if you do not
;;; know what you are doing.
;;; 
(defvar *internal-gc* #'collect-garbage)


;;;; SUB-GC

;;;
;;; CAREFULLY-FUNCALL -- Internal
;;;
;;; Used to carefully invoke hooks.
;;; 
(defmacro carefully-funcall (function &rest args)
  `(handler-case (funcall ,function ,@args)
     (error (cond)
       (warn "(FUNCALL ~S~{ ~S~}) lost:~%~A" ',function ',args cond)
       nil)))

;;;
;;; SUB-GC -- Internal
;;;
;;; SUB-GC decides when and if to do a garbage collection.  The
;;; VERBOSE-P flag controls whether or not the notify functions are
;;; called.  The FORCE-P flags controls if a GC should occur even if the
;;; dynamic usage is not greater than *GC-TRIGGER*.
;;; 
;;; For GENCGC all generations < GEN will be GC'ed.
;;;
(defun sub-gc (&key (verbose-p *gc-verbose*) force-p #+gencgc (gen 0))
  (unless *already-maybe-gcing*
    (let* ((*already-maybe-gcing* t)
	   (start-time (get-internal-run-time))
	   (pre-gc-dyn-usage (dynamic-usage)))
      (unless (integerp (symbol-value '*bytes-consed-between-gcs*))
	;; The noise w/ symbol-value above is to keep the compiler from
	;; optimizing the test away because of the type declaim for
	;; *bytes-consed-between-gcs*.
	(warn "The value of *BYTES-CONSED-BETWEEN-GCS*, ~S, is not an ~
	       integer.  Reseting it to ~D." *bytes-consed-between-gcs*
	       default-bytes-consed-between-gcs)
	(setf *bytes-consed-between-gcs* default-bytes-consed-between-gcs))
      (when (and *gc-trigger* (> pre-gc-dyn-usage *gc-trigger*))
	(setf *need-to-collect-garbage* t))
      (when (or force-p
		(and *need-to-collect-garbage* (not *gc-inhibit*)))
	(when (and (not force-p)
		   *gc-inhibit-hook*
		   (carefully-funcall *gc-inhibit-hook* pre-gc-dyn-usage))
	  (setf *gc-inhibit* t)
	  (return-from sub-gc nil))
	(without-interrupts
	  (let ((*standard-output* *terminal-io*))
	    (when verbose-p
	      (carefully-funcall *gc-notify-before* pre-gc-dyn-usage))
	    (dolist (hook *before-gc-hooks*)
	      (carefully-funcall hook))
	    (when *gc-trigger*
	      (clear-auto-gc-trigger))
	    #-gencgc (funcall *internal-gc*)
	    #+gencgc (if (eq *internal-gc* #'collect-garbage)
			 (funcall *internal-gc* gen)
			 (funcall *internal-gc*))
	    (let* ((post-gc-dyn-usage (dynamic-usage))
		   (bytes-freed (- pre-gc-dyn-usage post-gc-dyn-usage)))
	      (when *last-bytes-in-use*
		(incf *total-bytes-consed*
		      (- pre-gc-dyn-usage *last-bytes-in-use*))
		(setq *last-bytes-in-use* post-gc-dyn-usage))
	      (setf *need-to-collect-garbage* nil)
	      (setf *gc-trigger*
		    (+ post-gc-dyn-usage *bytes-consed-between-gcs*))
	      (set-auto-gc-trigger *gc-trigger*)
	      (dolist (hook *after-gc-hooks*)
		(carefully-funcall hook))
	      (when verbose-p
		(carefully-funcall *gc-notify-after*
				   post-gc-dyn-usage bytes-freed
				   *gc-trigger*))))
	  (scrub-control-stack)))
      (incf *gc-run-time* (- (get-internal-run-time) start-time))))
  nil)

;;;
;;; MAYBE-GC -- Internal
;;; 
;;; This routine is called by the allocation miscops to decide if a GC
;;; should occur.  The argument, object, is the newly allocated object
;;; which must be returned to the caller.
;;; 
(defun maybe-gc (&optional object)
  (sub-gc)
  object)

;;;
;;; GC -- Exported
;;;
;;; This is the user advertised garbage collection function.
;;; 
#-gencgc
(defun gc (&optional (verbose-p *gc-verbose*))
  "Initiates a garbage collection.  The optional argument, VERBOSE-P,
  which defaults to the value of the variable *GC-VERBOSE* controls
  whether or not GC statistics are printed."
  (sub-gc :verbose-p verbose-p :force-p t))
;;;
#+gencgc
(defun gc (&key (verbose *gc-verbose*) (gen 0) (full nil))
  "Initiates a garbage collection.  The keyword :VERBOSE, which
   defaults to the value of the variable *GC-VERBOSE* controls whether or
   not GC statistics are printed. The keyword :GEN defaults to 0, and
   controls the number of generations to garbage collect."
  (sub-gc :verbose-p verbose :force-p t :gen (if full 6 gen)))


;;;; Auxiliary Functions.

(defun bytes-consed-between-gcs ()
  "Return the amount of memory that will be allocated before the next garbage
   collection is initiated.  This can be set with SETF."
  *bytes-consed-between-gcs*)
;;;
(defun %set-bytes-consed-between-gcs (val)
  (declare (type index val))
  (let ((old *bytes-consed-between-gcs*))
    (setf *bytes-consed-between-gcs* val)
    (when *gc-trigger*
      (setf *gc-trigger* (+ *gc-trigger* (- val old)))
      (cond ((<= (dynamic-usage) *gc-trigger*)
	     (clear-auto-gc-trigger)
	     (set-auto-gc-trigger *gc-trigger*))
	    (t
	     (system:scrub-control-stack)
	     (sub-gc)))))
  val)
;;;
(defsetf bytes-consed-between-gcs %set-bytes-consed-between-gcs)


(defun gc-on ()
  "Enables the garbage collector."
  (setq *gc-inhibit* nil)
  (when *need-to-collect-garbage*
    (sub-gc))
  nil)

(defun gc-off ()
  "Disables the garbage collector."
  (setq *gc-inhibit* t)
  nil)



;;;; Initialization stuff.

(defun gc-init ()
  (when *gc-trigger*
    (if (< *gc-trigger* (dynamic-usage))
	(sub-gc)
	(set-auto-gc-trigger *gc-trigger*))))
+++ /home/matt/src/nightshade-0.0+/src/code/generic-site.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/generic-site.lisp.
+++++++++++++++
(setq *short-site-name* "Short site name")
(setq *long-site-name* "Long site name")

;;; We would appreciate it if each site establishes a local maintainer who can
;;; filter bug reports from novice users to make sure that they really have
;;; found a bug.  Fill in the maintainer's address here.
(rplaca
 (cdr (member :subsystems *herald-items*))
 '("Loaded subsystems:" terpri))

---------------
(setq *short-site-name* "Unknown")
(setq *long-site-name* "Site name not initialized")

;;; We would appreciate it if each site establishes a local maintainer who can
;;; filter bug reports from novice users to make sure that they really have
;;; found a bug.  Fill in the maintainer's address here..
(rplaca
 (cdr (member :bugs *herald-items*))
 '("Send questions and bug reports to your local CMU CL maintainer, " terpri
   "or to cmucl-help@cons.org. and cmucl-imp@cons.org. respectively." terpri
   "Loaded subsystems:" terpri))

+++++++++++++++
;(setf (search-list "target:") "<the source tree root>/")
---------------
#|
(setf (search-list "target:") "<the source tree root>/")
|#
+++ /home/matt/src/nightshade-0.0+/src/code/gengc.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/gengc.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/globals.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/globals.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/hash-new.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/hash-new.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/hash.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/hash.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/hppa-vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/hppa-vm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/hpux-os.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/hpux-os.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/internet.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/internet.lisp.
+++++++++++++++
(defun connect-to-inet-socket (host port &optional (kind :stream))
---------------
 (defun connect-to-inet-socket (host port &optional (kind :stream))
+++ /home/matt/src/nightshade-0.0+/src/code/interr.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/interr.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/irix-os.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/irix-os.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/irrat.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/irrat.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/kernel.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/kernel.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/linux-os.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/linux-os.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/lispinit.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/lispinit.lisp.
+++++++++++++++
;;;
---------------
;;; 
+++++++++++++++
(defvar *lisp-implementation-version* "0.0+")


---------------
(defvar *lisp-implementation-version* "4.0(?)")


+++++++++++++++
;;;

---------------
;;; 

+++++++++++++++
        ((symbolp datum) ; Roughly, (subtypep datum 'condition).
---------------
        ((symbolp datum) ;Roughly, (subtypep datum 'condition).
+++++++++++++++
  (system:without-hemlock
   (kernel:infinite-error-protect
---------------
  (kernel:infinite-error-protect
+++++++++++++++
	 (coerce-to-condition datum arguments 'simple-condition 'break))))))
---------------
	 (coerce-to-condition datum arguments 'simple-condition 'break)))))
+++++++++++++++
	    (setf (svref *load-time-values* (third fun))
---------------
	    (setf (svref *load-time-values* (third fun)) 
+++++++++++++++
  (princ "Nightshade kernel core image ")
---------------
  (princ "CMU Common Lisp kernel core image ")
+++++++++++++++
  (princ "[Current package: ")
  (princ (package-%name *package*))
  (princ "]")
  (terpri)
  (let ((wot (catch '%end-of-the-world
	       (%top-level))))
---------------
  (princ "[You are in the LISP package.]")
  (terpri)
  (let ((wot 
	 (catch '%end-of-the-world
	   (loop
	     (%top-level)
	     (write-line "You're certainly a clever child.")))))
+++++++++++++++
  true."
---------------
  non-Nil."
+++++++++++++++
		  (if (and (fboundp 'commandp) (funcall 'commandp form))
---------------
		  (if (and (fboundp 'commandp)(funcall 'commandp form))
+++ /home/matt/src/nightshade-0.0+/src/code/list.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/list.lisp.
+++++++++++++++
;;;
---------------
;;; 
+++++++++++++++
  "Constructs and returns a list Args."
---------------
  "Returns constructs and returns a list of its arguments."
+++++++++++++++
		 (let* ((result (cons (caar top) '()))
---------------
		 (let* ((result (cons (caar top) '())) 
+++++++++++++++
				   (if (atom (car x))
---------------
				   (if (atom (car x)) 
+++++++++++++++
;;;    This is not in an (eval-when (compile eval) ...
---------------
;;;    This is not in and (eval-when (compile eval) ...
+++++++++++++++
    (if (or (endp x) (endp y))
---------------
    (if (or (endp x) (endp y)) 
+++++++++++++++
	 (ret-list (list nil))
---------------
	 (ret-list (list nil)) 
+++++++++++++++
  "Returns list with all elements EQ to ITEM deleted."
---------------
  "Returns list with all elements with all elements EQ to ITEM deleted."
+++++++++++++++
	     (if (null splice)
---------------
	     (if (null splice) 
+++ /home/matt/src/nightshade-0.0+/src/code/load.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/load.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/loop.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/loop.lisp.
+++++++++++++++
;;; -*- Package: LOOP -*-
;;;
;;; **********************************************************************
;;; This code was written as part of the CMU Common Lisp project at
;;; Carnegie Mellon University, and has been placed in the public domain.
;;;
(ext:file-comment
  "$Header: /project/cmucl/cvsroot/src/code/old-loop.lisp,v 1.10 1994/10/31 04:11:27 ram Exp $")
;;;
;;; **********************************************************************
;;;
;;; Loop facility, written by William Lott.
;;; 
(in-package "LOOP")

(in-package "LISP")
(export '(loop loop-finish))

(in-package "LOOP")


;;;; Specials used during the parse.

;;; These specials hold the different parts of the result as we are generating
;;; them.
;;; 
(defvar *loop-name*)
(defvar *outside-bindings*)
(defvar *prologue*)
(defvar *inside-bindings*)
(defvar *body-forms*)
(defvar *iteration-forms*)
(defvar *epilogue*)
(defvar *result-var*)
(defvar *return-value*)
(defvar *default-return-value*)
(defvar *accumulation-variables*)

;;; This special holds the remaining stuff we need to parse.
;;; 
(defvar *remaining-stuff*)

;;; This special holds a value that is EQ only to itself.
;;; 
(defvar *magic-cookie* (list '<magic-cookie>))


;;;; Utility functions/macros used by the parser.

(proclaim '(inline maybe-car maybe-cdr))

(defun maybe-car (thing)
  (if (consp thing) (car thing) thing))

(defun maybe-cdr (thing)
  (if (consp thing) (cdr thing) thing))


(defmacro loop-keyword-p (thing keyword &rest more-keywords)
  `(let ((thing ,thing))
     (and (symbolp thing)
	  (let ((name (symbol-name thing)))
	    (or ,@(mapcar #'(lambda (keyword)
			      `(string= name ,keyword))
			  (cons keyword more-keywords)))))))

(defun preposition-p (prep)
  (when (loop-keyword-p (car *remaining-stuff*) prep)
    (pop *remaining-stuff*)
    t))


(defun splice-in-subform (form subform)
  (if (eq form *magic-cookie*)
      subform
      (labels ((sub-splice-in-subform (form path)
		 (cond ((atom form)
			nil)
		       ((member form path)
			nil)
		       ((eq (car form) *magic-cookie*)
			(setf (car form) subform)
			t)
		       (t
			(let ((new-path (cons form path)))
			  (or (sub-splice-in-subform (car form) new-path)
			      (sub-splice-in-subform (cdr form) new-path)))))))
	(if (sub-splice-in-subform form nil)
	    form
	    (error "Couldn't find the magic cookie in:~% ~S~%Loop is broken."
		   form)))))

(defmacro queue-var (where name type &key
			   (initer nil initer-p) (stepper nil stepper-p))
  `(push (list ,name ,type ,initer-p ,initer ,stepper-p ,stepper)
	 ,where))

(defvar *default-values* '(nil 0 0.0)
  "The different possible default values.  When we need a default value, we
  use the first value in this list that is typep the desired type.")

(defun pick-default-value (var type)
  (if (consp var)
      (cons (pick-default-value (car var) (maybe-car type))
	    (pick-default-value (cdr var) (maybe-cdr type)))
      (dolist (default *default-values*
		       (error "Cannot default variables of type ~S ~
		               (for variable ~S)."
			      type var))
	(when (typep default type)
	  (return default)))))

(defun only-simple-types (type-spec)
  (if (atom type-spec)
      (member type-spec '(fixnum float t nil))
      (and (only-simple-types (car type-spec))
	   (only-simple-types (cdr type-spec)))))


(defun build-let-expression (vars)
  (if (null vars)
      (values *magic-cookie* *magic-cookie*)
      (let ((inside nil)
	    (outside nil)
	    (steppers nil)
	    (sub-lets nil))
	(dolist (var vars)
	  (labels
	      ((process (name type initial-p initial stepper-p stepper)
	         (cond ((atom name)
			(cond ((not stepper-p)
			       (push (list type name initial) outside))
			      ((not initial-p)
			       (push (list type name stepper) inside))
			      (t
			       (push (list type name initial) outside)
			       (setf steppers
				     (nconc steppers (list name stepper))))))
		       ((and (car name) (cdr name))
			(let ((temp (gensym (format nil "TEMP-FOR-~A-" name))))
			  (process temp 'list initial-p initial
				   stepper-p stepper)
			  (push (if stepper-p
				    (list (car name)
					  (maybe-car type)
					  nil nil
					  t `(car ,temp))
				    (list (car name)
					  (maybe-car type)
					  t `(car ,temp)
					  nil nil))
				sub-lets)
			  (push (if stepper-p
				    (list (cdr name)
					  (maybe-cdr type)
					  nil nil
					  t `(cdr ,temp))
				    (list (car name)
					  (maybe-cdr type)
					  t `(cdr ,temp)
					  nil nil))
				sub-lets)))
		       ((car name)
			(process (car name)
				 (maybe-car type)
				 initial-p `(car ,initial)
				 stepper-p `(car ,stepper)))
		       ((cdr name)
			(process (cdr name)
				 (maybe-cdr type)
				 initial-p `(cdr ,initial)
				 stepper-p `(cdr ,stepper))))))
	    (process (first var) (second var) (third var)
		     (fourth var) (fifth var) (sixth var))))
	(when steppers
	  (push (cons 'psetq steppers)
		*iteration-forms*))
	(multiple-value-bind
	    (sub-outside sub-inside)
	    (build-let-expression sub-lets)
	  (values (build-bindings outside sub-outside)
		  (build-bindings inside sub-inside))))))

(defun build-bindings (vars guts)
  (if (null vars)
      guts
      `(let ,(mapcar #'cdr vars)
	 (declare ,@(mapcar #'build-declare vars))
	 ,guts)))

(defun build-declare (var)
  `(type ,(car var) ,(cadr var)))



;;;; LOOP itself.

(defmacro loop (&rest stuff)
  "General iteration facility.  See the FIX manual for details, 'cause it's
  very confusing."
  (if (some #'atom stuff)
      (parse-loop stuff)
      (let ((repeat (gensym "REPEAT-"))
	    (out-of-here (gensym "OUT-OF-HERE-")))
	`(block nil
	   (tagbody
	    ,repeat
	    (macrolet ((loop-finish () '(go ,out-of-here)))
;	    (macrolet ((loop-finish () `(go ,out-of-here)))
	      ,@stuff)
	    (go ,repeat)
	    ,out-of-here)))))



;;;; The parser.

;;; Top level parser.  Bind the specials, and call the other parsers.
;;; 
(defun parse-loop (stuff)
  (let* ((*prologue* nil)
	 (*outside-bindings* *magic-cookie*)
	 (*inside-bindings* *magic-cookie*)
	 (*body-forms* nil)
	 (*iteration-forms* nil)
	 (*epilogue* nil)
	 (*result-var* nil)
	 (*return-value* nil)
	 (*default-return-value* nil)
	 (*accumulation-variables* nil)
	 (*remaining-stuff* stuff)
	 (name (parse-named)))
    (loop
      (when (null *remaining-stuff*)
	(return))
      (let ((clause (pop *remaining-stuff*)))
	(cond ((not (symbolp clause))
	       (error "Invalid clause, ~S, must be a symbol." clause))
	      ((loop-keyword-p clause "INITIALLY")
	       (setf *prologue* (nconc *prologue* (parse-expr-list))))
	      ((loop-keyword-p clause "FINALLY")
	       (parse-finally))
	      ((loop-keyword-p clause "WITH")
	       (parse-with))
	      ((loop-keyword-p clause "FOR" "AS")
	       (parse-for-as))
	      ((loop-keyword-p clause "REPEAT")
	       (parse-repeat))
	      (t
	       (push clause *remaining-stuff*)
	       (return)))))
    (loop
      (when (null *remaining-stuff*)
	(return))
      (let ((clause (pop *remaining-stuff*)))
	(cond ((not (symbolp clause))
	       (error "Invalid clause, ~S, must be a symbol." clause))
	      ((loop-keyword-p clause "INITIALLY")
	       (setf *prologue* (nconc *prologue* (parse-expr-list))))
	      ((loop-keyword-p clause "FINALLY")
	       (parse-finally))
	      ((loop-keyword-p clause "WHILE")
	       (setf *body-forms*
		     (nconc *body-forms*
			    `((unless ,(pop *remaining-stuff*)
				(loop-finish))))))
	      ((loop-keyword-p clause "UNTIL")
	       (setf *body-forms*
		     (nconc *body-forms*
			    `((when ,(pop *remaining-stuff*) (loop-finish))))))
	      ((loop-keyword-p clause "ALWAYS")
	       (setf *body-forms*
		     (nconc *body-forms*
			    `((unless ,(pop *remaining-stuff*)
				(return-from ,name nil)))))
	       (setf *default-return-value* t))
	      ((loop-keyword-p clause "NEVER")
	       (setf *body-forms*
		     (nconc *body-forms*
			    `((when ,(pop *remaining-stuff*)
				(return-from ,name nil)))))
	       (setf *default-return-value* t))
	      ((loop-keyword-p clause "THEREIS")
	       (setf *body-forms*
		     (nconc *body-forms*
			    (let ((temp (gensym "THEREIS-")))
			      `((let ((,temp ,(pop *remaining-stuff*)))
				  (when ,temp
				    (return-from ,name ,temp))))))))
	      (t
	       (push clause *remaining-stuff*)
	       (or (maybe-parse-unconditional)
		   (maybe-parse-conditional)
		   (maybe-parse-accumulation)
		   (error "Unknown clause, ~S" clause))))))
    (let ((again-tag (gensym "AGAIN-"))
	  (end-tag (gensym "THIS-IS-THE-END-")))
      `(block ,name
	 ,(splice-in-subform
	   *outside-bindings*
	   `(macrolet ((loop-finish () '(go ,end-tag)))
	      (tagbody
	       ,@*prologue*
	       ,again-tag
	       ,(splice-in-subform
		 *inside-bindings*
		 `(progn
		    ,@*body-forms*
		    ,@(nreverse *iteration-forms*)))
	       (go ,again-tag)
	       ,end-tag
	       ,@*epilogue*
	       (return-from ,name
			    ,(or *return-value*
				 *default-return-value*
				 *result-var*)))))))))

(defun parse-named ()
  (when (loop-keyword-p (car *remaining-stuff*) "NAMED")
    (pop *remaining-stuff*)
    (if (symbolp (car *remaining-stuff*))
	(pop *remaining-stuff*)
	(error "Loop name ~S is not a symbol." (car *remaining-stuff*)))))


(defun parse-expr-list ()
  (let ((results nil))
    (loop
      (when (atom (car *remaining-stuff*))
	(return (nreverse results)))
      (push (pop *remaining-stuff*) results))))

(defun parse-finally ()
  (let ((sub-clause (pop *remaining-stuff*)))
    (if (loop-keyword-p sub-clause "RETURN")
	(cond ((not (null *return-value*))
	       (error "Cannot specify two FINALLY RETURN clauses."))
	      ((null *remaining-stuff*)
	       (error "FINALLY RETURN must be followed with an expression."))
	      (t
	       (setf *return-value* (pop *remaining-stuff*))))
	(progn
	  (unless (loop-keyword-p sub-clause "DO" "DOING")
	    (push sub-clause *remaining-stuff*))
	  (setf *epilogue* (nconc *epilogue* (parse-expr-list)))))))

(defun parse-with ()
  (let ((vars nil))
    (loop
      (multiple-value-bind (var type) (parse-var-and-type-spec)
	(let ((initial
	       (if (loop-keyword-p (car *remaining-stuff*) "=")
		   (progn
		     (pop *remaining-stuff*)
		     (pop *remaining-stuff*))
		   (list 'quote
			 (pick-default-value var type)))))
	  (queue-var vars var type :initer initial)))
      (if (loop-keyword-p (car *remaining-stuff*) "AND")
	  (pop *remaining-stuff*)
	  (return)))
    (multiple-value-bind
	(outside inside)
	(build-let-expression vars)
      (setf *outside-bindings*
	    (splice-in-subform *outside-bindings* outside))
      (setf *inside-bindings*
	    (splice-in-subform *inside-bindings* inside)))))

(defun parse-var-and-type-spec ()
  (values (pop *remaining-stuff*)
	  (parse-type-spec t)))

(defun parse-type-spec (default)
  (cond ((preposition-p "OF-TYPE")
	 (pop *remaining-stuff*))
	((and *remaining-stuff*
	      (only-simple-types (car *remaining-stuff*)))
	 (pop *remaining-stuff*))
	(t
	 default)))



;;;; FOR/AS stuff.

;;; These specials hold the vars that need to be bound for this FOR/AS clause
;;; and all of the FOR/AS clauses connected with AND.  All the *for-as-vars*
;;; are bound in parallel followed by the *for-as-sub-vars*.
;;; 
(defvar *for-as-vars*)
(defvar *for-as-sub-vars*)

;;; These specials hold any extra termination tests.  *for-as-term-tests* are
;;; processed after the *for-as-vars* are bound, but before the
;;; *for-as-sub-vars*.  *for-as-sub-term-tests* are processed after the
;;; *for-as-sub-vars*.

(defvar *for-as-term-tests*)
(defvar *for-as-sub-term-tests*)


(defun parse-for-as ()
  (let ((*for-as-vars* nil)
	(*for-as-term-tests* nil)
	(*for-as-sub-vars* nil)
	(*for-as-sub-term-tests* nil))
    (loop
      (multiple-value-bind (name type) (parse-var-and-type-spec)
	(let ((sub-clause (pop *remaining-stuff*)))
	  (cond ((loop-keyword-p sub-clause "FROM" "DOWNFROM" "UPFROM"
				 "TO" "DOWNTO" "UPTO" "BELOW" "ABOVE")
		 (parse-arithmetic-for-as sub-clause name type))
		((loop-keyword-p sub-clause "IN")
		 (parse-in-for-as name type))
		((loop-keyword-p sub-clause "ON")
		 (parse-on-for-as name type))
		((loop-keyword-p sub-clause "=")
		 (parse-equals-for-as name type))
		((loop-keyword-p sub-clause "ACROSS")
		 (parse-across-for-as name type))
		((loop-keyword-p sub-clause "BEING")
		 (parse-being-for-as name type))
		(t
		 (error "Invalid FOR/AS subclause: ~S" sub-clause)))))
      (if (loop-keyword-p (car *remaining-stuff*) "AND")
	  (pop *remaining-stuff*)
	  (return)))
    (multiple-value-bind
	(outside inside)
	(build-let-expression *for-as-vars*)
      (multiple-value-bind
	  (sub-outside sub-inside)
	  (build-let-expression *for-as-sub-vars*)
	(setf *outside-bindings*
	      (splice-in-subform *outside-bindings*
				 (splice-in-subform outside sub-outside)))
	(let ((inside-body
	       (if *for-as-term-tests*
		   `(if (or ,@(nreverse *for-as-term-tests*))
			(loop-finish)
			,*magic-cookie*)
		   *magic-cookie*))
	      (sub-inside-body
	       (if *for-as-sub-term-tests*
		   `(if (or ,@(nreverse *for-as-sub-term-tests*))
			(loop-finish)
			,*magic-cookie*)
		   *magic-cookie*)))
	  (setf *inside-bindings*
		(splice-in-subform
		 *inside-bindings*
		 (splice-in-subform
		  inside
		  (splice-in-subform
		   inside-body
		   (splice-in-subform
		    sub-inside
		    sub-inside-body))))))))))

(defun parse-arithmetic-for-as (sub-clause name type)
  (unless (atom name)
    (error "Cannot destructure arithmetic FOR/AS variables: ~S" name))
  (let (start stop (inc 1) dir exclusive-p)
    (cond ((loop-keyword-p sub-clause "FROM")
	   (setf start (pop *remaining-stuff*)))
	  ((loop-keyword-p sub-clause "DOWNFROM")
	   (setf start (pop *remaining-stuff*))
	   (setf dir :down))
	  ((loop-keyword-p sub-clause "UPFROM")
	   (setf start (pop *remaining-stuff*))
	   (setf dir :up))
	  (t
	   (push sub-clause *remaining-stuff*)))
    (cond ((preposition-p "TO")
	   (setf stop (pop *remaining-stuff*)))
	  ((preposition-p "DOWNTO")
	   (setf stop (pop *remaining-stuff*))
	   (if (eq dir :up)
	       (error "Can't mix UPFROM and DOWNTO in ~S." name)
	       (setf dir :down)))
	  ((preposition-p "UPTO")
	   (setf stop (pop *remaining-stuff*))
	   (if (eq dir :down)
	       (error "Can't mix DOWNFROM and UPTO in ~S." name)
	       (setf dir :up)))
	  ((preposition-p "ABOVE")
	   (setf stop (pop *remaining-stuff*))
	   (setf exclusive-p t)
	   (if (eq dir :up)
	       (error "Can't mix UPFROM and ABOVE in ~S." name)
	       (setf dir :down)))
	  ((preposition-p "BELOW")
	   (setf stop (pop *remaining-stuff*))
	   (setf exclusive-p t)
	   (if (eq dir :down)
	       (error "Can't mix DOWNFROM and BELOW in ~S." name)
	       (setf dir :up))))
    (when (preposition-p "BY")
      (setf inc (pop *remaining-stuff*)))
    (when (and (eq dir :down) (null start))
      (error "No default starting value for decremental stepping."))
    (let ((temp (gensym "TEMP-AMOUNT-")))
      (queue-var *for-as-sub-vars* temp type :initer inc)
      (queue-var *for-as-sub-vars* name type
		 :initer (or start 0)
		 :stepper `(,(if (eq dir :down) '- '+) ,name ,temp))
      (when stop
	(let ((stop-var (gensym "STOP-VAR-")))
	  (queue-var *for-as-sub-vars* stop-var type :initer stop)
	  (push (list (if (eq dir :down)
			  (if exclusive-p '<= '<)
			  (if exclusive-p '>= '>))
		      name stop-var)
		*for-as-sub-term-tests*))))))

(defun parse-in-for-as (name type)
  (let* ((temp (gensym "LIST-"))
	 (initer (pop *remaining-stuff*))
	 (stepper (if (preposition-p "BY")
		      `(funcall ,(pop *remaining-stuff*) ,temp)
		      `(cdr ,temp))))
    (queue-var *for-as-vars* temp 'list :initer initer :stepper stepper)
    (queue-var *for-as-sub-vars* name type :stepper `(car ,temp))
    (push `(null ,temp) *for-as-sub-term-tests*)))

(defun parse-on-for-as (name type)
  (let* ((temp (if (atom name) name (gensym "LIST-")))
	 (initer (pop *remaining-stuff*))
	 (stepper (if (preposition-p "BY")
		      `(funcall ,(pop *remaining-stuff*) ,temp)
		      `(cdr ,temp))))
    (cond ((atom name)
	   (queue-var *for-as-sub-vars* name type
		      :initer initer :stepper stepper)
	   (push `(endp ,name) *for-as-sub-term-tests*))
	  (t
	   (queue-var *for-as-vars* temp type
		      :initer initer :stepper stepper)
	   (queue-var *for-as-sub-vars* name type :stepper temp)
	   (push `(endp ,temp) *for-as-term-tests*)))))

(defun parse-equals-for-as (name type)
  (let ((initer (pop *remaining-stuff*)))
    (if (preposition-p "THEN")
	(queue-var *for-as-sub-vars* name type
		   :initer initer :stepper (pop *remaining-stuff*))
	(queue-var *for-as-vars* name type :stepper initer))))

(defun parse-across-for-as (name type)
  (let* ((temp (gensym "VECTOR-"))
	 (length (gensym "LENGTH-"))
	 (index (gensym "INDEX-")))
    (queue-var *for-as-vars* temp `(vector ,type)
	       :initer (pop *remaining-stuff*))
    (queue-var *for-as-sub-vars* length 'fixnum
	       :initer `(length ,temp))
    (queue-var *for-as-vars* index 'fixnum :initer 0 :stepper `(1+ ,index))
    (queue-var *for-as-sub-vars* name type :stepper `(aref ,temp ,index))
    (push `(>= ,index ,length) *for-as-term-tests*)))

(defun parse-being-for-as (name type)
  (let ((clause (pop *remaining-stuff*)))
    (unless (loop-keyword-p clause "EACH" "THE")
      (error "BEING must be followed by either EACH or THE, not ~S"
	     clause)))
  (let ((clause (pop *remaining-stuff*)))
    (cond ((loop-keyword-p clause "HASH-KEY" "HASH-KEYS"
 			   "HASH-VALUE" "HASH-VALUES")
	   (let ((prep (pop *remaining-stuff*)))
	     (unless (loop-keyword-p prep "IN" "OF")
	       (error "~A must be followed by either IN or OF, not ~S"
		      (symbol-name clause) prep)))
	   (let ((table (pop *remaining-stuff*))
		 (iterator (gensym (format nil "~A-ITERATOR-" name)))
		 (exists-temp (gensym (format nil "~A-EXISTS-TEMP-" name)))
		 (key-temp (gensym (format nil "~A-KEY-TEMP-" name)))
		 (value-temp (gensym (format nil "~A-VALUE-TEMP-" name))))
	     (setf *outside-bindings*
		   (splice-in-subform
		    *outside-bindings*
		    `(with-hash-table-iterator (,iterator ,table)
					       ,*magic-cookie*)))
	     (multiple-value-bind
		 (using using-type)
		 (when (preposition-p "USING")
		   ;; ### This is wrong.
		   (parse-var-and-type-spec))
	       (multiple-value-bind
		   (key-var key-type value-var value-type)
		   (if (loop-keyword-p clause "HASH-KEY" "HASH-KEYS")
		       (values name type using using-type)
		       (values using using-type name type))
		 (setf *inside-bindings*
		       (splice-in-subform
			*inside-bindings*
			`(multiple-value-bind
			     (,exists-temp ,key-temp ,value-temp)
			     (,iterator)
			   ,@(unless (and key-var value-var)
			       `((declare (ignore ,@(if (null key-var)
							(list key-temp))
						  ,@(if (null value-var)
							(list value-temp))))))
			   ,*magic-cookie*)))
		 (push `(not ,exists-temp) *for-as-term-tests*)
		 (when key-var
		   (queue-var *for-as-sub-vars* key-var key-type
			      :stepper key-temp))
		 (when value-var
		   (queue-var *for-as-sub-vars* value-var value-type
			      :stepper value-temp))))))
	  ((loop-keyword-p clause "SYMBOL" "PRESENT-SYMBOL" "EXTERNAL-SYMBOL"
			   "SYMBOLS" "PRESENT-SYMBOLS" "EXTERNAL-SYMBOLS")
	   (let ((package
		  (if (or (preposition-p "IN")
			  (preposition-p "OF"))
		      (pop *remaining-stuff*)
		      '*package*))
		 (iterator (gensym (format nil "~A-ITERATOR-" name)))
		 (exists-temp (gensym (format nil "~A-EXISTS-TEMP-" name)))
		 (symbol-temp (gensym (format nil "~A-SYMBOL-TEMP-" name))))
	     (setf *outside-bindings*
		   (splice-in-subform
		    *outside-bindings*
		    `(with-package-iterator
			 (,iterator
			  ,package
			  ,@(cond ((loop-keyword-p clause "SYMBOL" "SYMBOLS")
				   '(:internal :external :inherited))
				  ((loop-keyword-p clause "PRESENT-SYMBOL"
						   "PRESENT-SYMBOLS")
				   '(:internal))
				  ((loop-keyword-p clause "EXTERNAL-SYMBOL"
						   "EXTERNAL-SYMBOLS")
				   '(:external))
				  (t
				   (error "Don't know how to deal with ~A?  ~
				           Bug in LOOP?" clause))))
		       ,*magic-cookie*)))
	     (setf *inside-bindings*
		   (splice-in-subform
		    *inside-bindings*
		    `(multiple-value-bind
			 (,exists-temp ,symbol-temp)
			 (,iterator)
		       ,*magic-cookie*)))
	     (push `(not ,exists-temp) *for-as-term-tests*)
	     (queue-var *for-as-sub-vars* name type :stepper symbol-temp)))
	  (t
	   (error
	    "Unknown sub-clause, ~A, for BEING.  Must be one of:~%  ~
	     HASH-KEY HASH-KEYS HASH-VALUE HASH-VALUES SYMBOL SYMBOLS~%  ~
	     PRESENT-SYMBOL PRESENT-SYMBOLS EXTERNAL-SYMBOL EXTERNAL-SYMBOLS"
	    (symbol-name clause))))))



;;;;

(defun parse-repeat ()
  (let ((temp (gensym "REPEAT-")))
    (setf *outside-bindings*
	  (splice-in-subform *outside-bindings*
			     `(let ((,temp ,(pop *remaining-stuff*)))
				,*magic-cookie*)))
    (setf *inside-bindings*
	  (splice-in-subform *inside-bindings*
			     `(if (minusp (decf ,temp))
				  (loop-finish)
				  ,*magic-cookie*)))))


(defun maybe-parse-unconditional ()
  (cond ((loop-keyword-p (car *remaining-stuff*) "DO" "DOING")
	 (pop *remaining-stuff*)
	 (setf *body-forms* (nconc *body-forms* (parse-expr-list)))
	 t)
	((loop-keyword-p (car *remaining-stuff*) "RETURN")
	 (pop *remaining-stuff*)
	 (setf *body-forms*
	       (nconc *body-forms* `((return ,(pop *remaining-stuff*)))))
	 t)))


(defun maybe-parse-conditional ()
  (let ((clause (pop *remaining-stuff*)))
    (cond ((loop-keyword-p clause "IF" "WHEN")
	   (parse-conditional (pop *remaining-stuff*))
	   t)
	  ((loop-keyword-p clause "UNLESS")
	   (parse-conditional `(not ,(pop *remaining-stuff*)))
	   t)
	  (t
	   (push clause *remaining-stuff*)
	   nil))))

(defun parse-conditional (condition)
  (let ((clauses (parse-and-clauses))
	(else-clauses (when (preposition-p "ELSE")
			(parse-and-clauses))))
    (setf *body-forms*
	  (nconc *body-forms*
		 `((if ,condition
		       (progn
			 ,@clauses)
		       (progn
			 ,@else-clauses)))))
    (preposition-p "END")))

(defun parse-and-clauses ()
  (let ((*body-forms* nil))
    (loop
      (or (maybe-parse-unconditional)
	  (maybe-parse-conditional)
	  (maybe-parse-accumulation)
	  (error "Invalid clause for inside a conditional: ~S"
		 (car *remaining-stuff*)))
      (unless (preposition-p "AND")
	(return *body-forms*)))))


;;;; Assumulation stuff

(defun maybe-parse-accumulation ()
  (when (loop-keyword-p (car *remaining-stuff*)
		       "COLLECT" "COLLECTING"
		       "APPEND" "APPENDING" "NCONC" "NCONCING"
		       "COUNT" "COUNTING" "SUM" "SUMMING"
		       "MAXIMIZE" "MAXIMIZING" "MINIMIZE" "MINIMIZING")
    (parse-accumulation)
    t))

(defun parse-accumulation ()
  (let* ((clause (pop *remaining-stuff*))
	 (expr (pop *remaining-stuff*))
	 (var (if (preposition-p "INTO")
		  (pop *remaining-stuff*)
		  (or *result-var*
		      (setf *result-var*
			    (gensym (concatenate 'simple-string
						 (string clause)
						 "-"))))))
	 (info (assoc var *accumulation-variables*))
	 (type nil)
	 (initial nil))
    (cond ((loop-keyword-p clause "COLLECT" "COLLECTING" "APPEND" "APPENDING"
			   "NCONC" "NCONCING")
	   (setf initial nil)
	   (setf type 'list)
	   (let ((aux-var
		  (or (caddr info)
		      (let ((aux-var (gensym "LAST-")))
			(setf *outside-bindings*
			      (splice-in-subform *outside-bindings*
						 `(let ((,var nil)
							(,aux-var nil))
						    (declare (type list
								   ,var
								   ,aux-var))
						    ,*magic-cookie*)))
			(if (null info)
			    (push (setf info (list var 'list aux-var))
				  *accumulation-variables*)
			    (setf (cddr info) (list aux-var)))
			aux-var)))
		 (value
		  (cond ((loop-keyword-p clause "COLLECT" "COLLECTING")
			 `(list ,expr))
			((loop-keyword-p clause "APPEND" "APPENDING")
			 `(copy-list ,expr))
			((loop-keyword-p clause "NCONC" "NCONCING")
			 expr)
			(t
			 (error "Bug in loop?")))))
	     (setf *body-forms*
		   (nconc *body-forms*
			  `((cond ((null ,var)
				   (setf ,var ,value)
				   (setf ,aux-var (last ,var)))
				  (t
				   (nconc ,aux-var ,value)
				   (setf ,aux-var (last ,aux-var)))))))))
	  ((loop-keyword-p clause "COUNT" "COUNTING")
	   (setf type (parse-type-spec 'unsigned-byte))
	   (setf initial 0)
	   (setf *body-forms*
		 (nconc *body-forms*
			`((when ,expr (incf ,var))))))
	  ((loop-keyword-p clause "SUM" "SUMMING")
	   (setf type (parse-type-spec 'number))
	   (setf initial 0)
	   (setf *body-forms*
		 (nconc *body-forms*
			`((incf ,var ,expr)))))
	  ((loop-keyword-p clause "MAXIMIZE" "MAXIMIZING")
	   (setf type `(or null ,(parse-type-spec 'number)))
	   (setf initial nil)
	   (setf *body-forms*
		 (nconc *body-forms*
			(let ((temp (gensym "MAX-TEMP-")))
			  `((let ((,temp ,expr))
			      (when (or (null ,var)
					(> ,temp ,var))
				(setf ,var ,temp))))))))
	  ((loop-keyword-p clause "MINIMIZE" "MINIMIZING")
	   (setf type `(or null ,(parse-type-spec 'number)))
	   (setf initial nil)
	   (setf *body-forms*
		 (nconc *body-forms*
			(let ((temp (gensym "MIN-TEMP-")))
			  `((let ((,temp ,expr))
			      (when (or (null ,var)
					(< ,temp ,var))
				(setf ,var ,temp))))))))
	  (t
	   (error "Invalid accumulation clause: ~S" clause)))
    (cond (info
	   (unless (equal type (cadr info))
	     (error "Attempt to use ~S for both types ~S and ~S."
		    var type (cadr info))))
	  (t
	   (push (list var type) *accumulation-variables*)
	   (setf *outside-bindings*
		 (splice-in-subform *outside-bindings*
				    `(let ((,var ,initial))
				       (declare (type ,type ,var))
				       ,*magic-cookie*)))))))
---------------
;;;   -*- Mode: LISP; Package: ANSI-LOOP; Syntax: Common-lisp; Base: 10; Lowercase:T -*-
;;;>
;;;> Portions of LOOP are Copyright (c) 1986 by the Massachusetts Institute of Technology.
;;;> All Rights Reserved.
;;;> 
;;;> Permission to use, copy, modify and distribute this software and its
;;;> documentation for any purpose and without fee is hereby granted,
;;;> provided that the M.I.T. copyright notice appear in all copies and that
;;;> both that copyright notice and this permission notice appear in
;;;> supporting documentation.  The names "M.I.T." and "Massachusetts
;;;> Institute of Technology" may not be used in advertising or publicity
;;;> pertaining to distribution of the software without specific, written
;;;> prior permission.  Notice must be given in supporting documentation that
;;;> copying distribution is by permission of M.I.T.  M.I.T. makes no
;;;> representations about the suitability of this software for any purpose.
;;;> It is provided "as is" without express or implied warranty.
;;;> 
;;;>      Massachusetts Institute of Technology
;;;>      77 Massachusetts Avenue
;;;>      Cambridge, Massachusetts  02139
;;;>      United States of America
;;;>      +1-617-253-1000
;;;>
;;;> Portions of LOOP are Copyright (c) 1989, 1990, 1991, 1992 by Symbolics, Inc.
;;;> All Rights Reserved.
;;;> 
;;;> Permission to use, copy, modify and distribute this software and its
;;;> documentation for any purpose and without fee is hereby granted,
;;;> provided that the Symbolics copyright notice appear in all copies and
;;;> that both that copyright notice and this permission notice appear in
;;;> supporting documentation.  The name "Symbolics" may not be used in
;;;> advertising or publicity pertaining to distribution of the software
;;;> without specific, written prior permission.  Notice must be given in
;;;> supporting documentation that copying distribution is by permission of
;;;> Symbolics.  Symbolics makes no representations about the suitability of
;;;> this software for any purpose.  It is provided "as is" without express
;;;> or implied warranty.
;;;> 
;;;> Symbolics, CLOE Runtime, and Minima are trademarks, and CLOE, Genera,
;;;> and Zetalisp are registered trademarks of Symbolics, Inc.
;;;>
;;;>      Symbolics, Inc.
;;;>      8 New England Executive Park, East
;;;>      Burlington, Massachusetts  01803
;;;>      United States of America
;;;>      +1-617-221-1000

;; $aclHeader: loop.cl,v 1.5 91/12/04 01:13:48 cox acl4_1 $

#+cmu
(ext:file-comment
 "$Header: /project/cmucl/cvsroot/src/code/loop.lisp,v 1.12 2002/07/30 16:40:28 toy Exp $")

;;;; LOOP Iteration Macro

#+allegro
(in-package :excl)
#-allegro
(in-package :ansi-loop)

(provide :loop)

#+Cloe-Runtime					;Don't ask.
(car (push "%Z% %M% %I% %E% %U%" system::*module-identifications*))

;;; Technology.
;;;
;;; The LOOP iteration macro is one of a number of pieces of code
;;; originally developed at MIT for which free distribution has been
;;; permitted, as long as the code is not sold for profit, and as long
;;; as notification of MIT's interest in the code is preserved.
;;;
;;; This version of LOOP, which is almost entirely rewritten both as
;;; clean-up and to conform with the ANSI Lisp LOOP standard, started
;;; life as MIT LOOP version 829 (which was a part of NIL, possibly
;;; never released).
;;;
;;; A "light revision" was performed by me (Glenn Burke) while at
;;; Palladian Software in April 1986, to make the code run in Common
;;; Lisp.  This revision was informally distributed to a number of
;;; people, and was sort of the "MIT" version of LOOP for running in
;;; Common Lisp.
;;;
;;; A later more drastic revision was performed at Palladian perhaps a
;;; year later.  This version was more thoroughly Common Lisp in style,
;;; with a few miscellaneous internal improvements and extensions.  I
;;; have lost track of this source, apparently never having moved it to
;;; the MIT distribution point.  I do not remember if it was ever
;;; distributed.
;;;
;;; This revision for the ANSI standard is based on the code of my April
;;; 1986 version, with almost everything redesigned and/or rewritten.


;;; The design of this LOOP is intended to permit, using mostly the same
;;; kernel of code, up to three different "loop" macros:
;;; 
;;; (1) The unextended, unextensible ANSI standard LOOP;
;;;
;;; (2) A clean "superset" extension of the ANSI LOOP which provides
;;; functionality similar to that of the old LOOP, but "in the style of"
;;; the ANSI LOOP.  For instance, user-definable iteration paths, with a
;;; somewhat cleaned-up interface.
;;;
;;; (3) Extensions provided in another file which can make this LOOP
;;; kernel behave largely compatibly with the Genera-vintage LOOP macro,
;;; with only a small addition of code (instead of two whole, separate,
;;; LOOP macros).
;;;
;;; Each of the above three LOOP variations can coexist in the same LISP
;;; environment.
;;; 


;;;; Miscellaneous Environment Things



;;;@@@@The LOOP-Prefer-POP feature makes LOOP generate code which "prefers" to use POP or
;;; its obvious expansion (prog1 (car x) (setq x (cdr x))).  Usually this involves
;;; shifting fenceposts in an iteration or series of carcdr operations.  This is
;;; primarily recognized in the list iterators (FOR .. {IN,ON}), and LOOP's
;;; destructuring setq code.
(eval-when (compile load eval)
  #+(or Genera Minima) (pushnew :LOOP-Prefer-POP *features*)
  )


;;; The uses of this macro are retained in the CL version of loop, in
;;; case they are needed in a particular implementation.  Originally
;;; dating from the use of the Zetalisp COPYLIST* function, this is used
;;; in situations where, were cdr-coding in use, having cdr-NIL at the
;;; end of the list might be suboptimal because the end of the list will
;;; probably be RPLACDed and so cdr-normal should be used instead.
(defmacro loop-copylist* (l)
  #+Genera `(lisp:copy-list ,l nil t)		; arglist = (list &optional area force-dotted)
  ;;@@@@Explorer??
  #-Genera `(copy-list ,l)
  )


(defvar *loop-gentemp*
	nil)

(defun loop-gentemp (&optional (pref 'loopvar-))
  (if *loop-gentemp*
      (gentemp (string pref))
      (gensym)))



(defvar *loop-real-data-type* 'real)


(defun loop-optimization-quantities (env)
  ;;@@@@ The ANSI conditionalization here is for those lisps that implement
  ;; DECLARATION-INFORMATION (from cleanup SYNTACTIC-ENVIRONMENT-ACCESS).
  ;; It is really commentary on how this code could be written.  I don't
  ;; actually expect there to be an ANSI #+-conditional -- it should be
  ;; replaced with the appropriate conditional name for your
  ;; implementation/dialect.
  (declare #-ANSI (ignore env)
	   #+Genera (values speed space safety compilation-speed debug))
  #+ANSI (let ((stuff (declaration-information 'optimize env)))
	   (values (or (cdr (assoc 'speed stuff)) 1)
		   (or (cdr (assoc 'space stuff)) 1)
		   (or (cdr (assoc 'safety stuff)) 1)
		   (or (cdr (assoc 'compilation-speed stuff)) 1)
		   (or (cdr (assoc 'debug stuff)) 1)))
  #+CLOE-Runtime (values compiler::time compiler::space
			 compiler::safety compiler::compilation-speed 1)
  #-(or ANSI CLOE-Runtime) (values 1 1 1 1 1))


;;;@@@@ The following form takes a list of variables and a form which presumably
;;; references those variables, and wraps it somehow so that the compiler does not
;;; consider those variables have been referenced.  The intent of this is that
;;; iteration variables can be flagged as unused by the compiler, e.g. I in
;;; (loop for i from 1 to 10 do (print t)), since we will tell it when a usage
;;; of it is "invisible" or "not to be considered".
;;;We implicitly assume that a setq does not count as a reference.  That is, the
;;; kind of form generated for the above loop construct to step I, simplified, is
;;; `(SETQ I ,(HIDE-VARIABLE-REFERENCES '(I) '(1+ I))).
(defun hide-variable-references (variable-list form)
  (declare #-Genera (ignore variable-list))
  #+Genera (if variable-list `(compiler:invisible-references ,variable-list ,form) form)
  #-Genera form)


;;;@@@@ The following function takes a flag, a variable, and a form which presumably
;;; references that variable, and wraps it somehow so that the compiler does not
;;; consider that variable to have been referenced.  The intent of this is that
;;; iteration variables can be flagged as unused by the compiler, e.g. I in
;;; (loop for i from 1 to 10 do (print t)), since we will tell it when a usage
;;; of it is "invisible" or "not to be considered".
;;;We implicitly assume that a setq does not count as a reference.  That is, the
;;; kind of form generated for the above loop construct to step I, simplified, is
;;; `(SETQ I ,(HIDE-VARIABLE-REFERENCES T 'I '(1+ I))).
;;;Certain cases require that the "invisibility" of the reference be conditional upon
;;; something.  This occurs in cases of "named" variables (the USING clause).  For instance,
;;; we want IDX in (LOOP FOR E BEING THE VECTOR-ELEMENTS OF V USING (INDEX IDX) ...)
;;; to be "invisible" when it is stepped, so that the user gets informed if IDX is
;;; not referenced.  However, if no USING clause is present, we definitely do not
;;; want to be informed that some random gensym is not used.
;;;It is easier for the caller to do this conditionally by passing a flag (which
;;; happens to be the second value of NAMED-VARIABLE, q.v.) to this function than
;;; for all callers to contain the conditional invisibility construction.
(defun hide-variable-reference (really-hide variable form)
  (declare #-Genera (ignore really-hide variable))
  #+Genera (if (and really-hide variable (atom variable))	;Punt on destructuring patterns
	       `(compiler:invisible-references (,variable) ,form)
	       form)
  #-Genera form)


;;;; List Collection Macrology


(defmacro with-loop-list-collection-head ((head-var tail-var &optional user-head-var)
					  &body body)
  ;;@@@@ TI? Exploder?
  #+LISPM (let ((head-place (or user-head-var head-var)))
	    `(let* ((,head-place nil)
		    (,tail-var
		      ,(hide-variable-reference
			 user-head-var user-head-var
			 `(progn #+Genera (scl:locf ,head-place)
				 #-Genera (system:variable-location ,head-place)))))
	       ,@body))
  #-LISPM (let ((l (and user-head-var (list (list user-head-var nil)))))
	    #+CLOE `(sys::with-stack-list* (,head-var nil nil)
		      (let ((,tail-var ,head-var) ,@l)
			,@body))
	    #-CLOE `(let* ((,head-var (list nil)) (,tail-var ,head-var) ,@l)
		      ,@body)))


(defmacro loop-collect-rplacd (&environment env
			       (head-var tail-var &optional user-head-var) form)
  (declare
    #+LISPM (ignore head-var user-head-var)	;use locatives, unconditionally update through the tail.
    )
  (setq form (macroexpand form env))
  (flet ((cdr-wrap (form n)
	   (declare (fixnum n))
	   (do () ((<= n 4) (setq form `(,(case n
					    (1 'cdr)
					    (2 'cddr)
					    (3 'cdddr)
					    (4 'cddddr))
					 ,form)))
	     (setq form `(cddddr ,form) n (- n 4)))))
    (let ((tail-form form) (ncdrs nil))
      ;;Determine if the form being constructed is a list of known length.
      (when (consp form)
	(cond ((eq (car form) 'list)
	       (setq ncdrs (1- (length (cdr form))))
	       ;;@@@@ Because the last element is going to be RPLACDed,
	       ;; we don't want the cdr-coded implementations to use
	       ;; cdr-nil at the end (which would just force copying
	       ;; the whole list again).
	       #+LISPM (setq tail-form `(list* ,@(cdr form) nil)))
	      ((member (car form) '(list* cons))
	       (when (and (cddr form) (member (car (last form)) '(nil 'nil)))
		 (setq ncdrs (- (length (cdr form)) 2))))))
      (let ((answer
	      (cond ((null ncdrs)
		     `(when (setf (cdr ,tail-var) ,tail-form)
			(setq ,tail-var (last (cdr ,tail-var)))))
		    ((< ncdrs 0) (return-from loop-collect-rplacd nil))
		    ((= ncdrs 0)
		     ;;@@@@ Here we have a choice of two idioms:
		     ;; (rplacd tail (setq tail tail-form))
		     ;; (setq tail (setf (cdr tail) tail-form)).
		     ;;Genera and most others I have seen do better with the former.
		     `(rplacd ,tail-var (setq ,tail-var ,tail-form)))
		    (t `(setq ,tail-var ,(cdr-wrap `(setf (cdr ,tail-var) ,tail-form)
						   ncdrs))))))
	;;If not using locatives or something similar to update the user's
	;; head variable, we've got to set it...  It's harmless to repeatedly set it
	;; unconditionally, and probably faster than checking.
	#-LISPM (when user-head-var
		  (setq answer `(progn ,answer (setq ,user-head-var (cdr ,head-var)))))
	answer))))


(defmacro loop-collect-answer (head-var &optional user-head-var)
  (or user-head-var
      (progn
	;;If we use locatives to get tail-updating to update the head var,
	;; then the head var itself contains the answer.  Otherwise we
	;; have to cdr it.
	#+LISPM head-var
	#-LISPM `(cdr ,head-var))))


;;;; Maximization Technology


#|
The basic idea of all this minimax randomness here is that we have to
have constructed all uses of maximize and minimize to a particular
"destination" before we can decide how to code them.  The goal is to not
have to have any kinds of flags, by knowing both that (1) the type is
something which we can provide an initial minimum or maximum value for
and (2) know that a MAXIMIZE and MINIMIZE are not being combined.

SO, we have a datastructure which we annotate with all sorts of things,
incrementally updating it as we generate loop body code, and then use
a wrapper and internal macros to do the coding when the loop has been
constructed.
|#


(defstruct (loop-minimax
	     (:constructor make-loop-minimax-internal)
	     (:copier nil)
	     (:predicate nil))
  answer-variable
  type
  temp-variable
  flag-variable
  operations
  infinity-data)


(defvar *loop-minimax-type-infinities-alist*
	;;@@@@ This is the sort of value this should take on for a Lisp that has
	;; "eminently usable" infinities.  n.b. there are neither constants nor
	;; printed representations for infinities defined by CL.
	;;@@@@ This grotesque read-from-string below is to help implementations
	;; which croak on the infinity character when it appears in a token, even
	;; conditionalized out.
	#+Genera
	  '#.(read-from-string
	      "((fixnum 	most-positive-fixnum	 most-negative-fixnum)
		(short-float 	+1s			 -1s)
		(single-float	+1f			 -1f)
		(double-float	+1d			 -1d)
		(long-float	+1l			 -1l))")
	;;This is how the alist should look for a lisp that has no infinities.  In
	;; that case, MOST-POSITIVE-x-FLOAT really IS the most positive.
	#+(or CLOE-Runtime Minima)
	  '((fixnum   		most-positive-fixnum		most-negative-fixnum)
	    (short-float	most-positive-short-float	most-negative-short-float)
	    (single-float	most-positive-single-float	most-negative-single-float)
	    (double-float	most-positive-double-float	most-negative-double-float)
	    (long-float		most-positive-long-float	most-negative-long-float))
	;; CMUCL has infinities so let's use them.
	#+CMU
	  '((fixnum		most-positive-fixnum			most-negative-fixnum)
	    (short-float	ext:single-float-positive-infinity	ext:single-float-negative-infinity)
	    (single-float	ext:single-float-positive-infinity	ext:single-float-negative-infinity)
	    (double-float	ext:double-float-positive-infinity	ext:double-float-negative-infinity)
	    (long-float		ext:long-float-positive-infinity	ext:long-float-negative-infinity))
	;; If we don't know, then we cannot provide "infinite" initial values for any of the
	;; types but FIXNUM:
	#-(or Genera CLOE-Runtime Minima CMU)
	  '((fixnum   		most-positive-fixnum		most-negative-fixnum))
	  )


(defun make-loop-minimax (answer-variable type)
  (let ((infinity-data (cdr (assoc type *loop-minimax-type-infinities-alist* :test #'subtypep))))
    (make-loop-minimax-internal
      :answer-variable answer-variable
      :type type
      :temp-variable (loop-gentemp 'loop-maxmin-temp-)
      :flag-variable (and (not infinity-data) (loop-gentemp 'loop-maxmin-flag-))
      :operations nil
      :infinity-data infinity-data)))


(defun loop-note-minimax-operation (operation minimax)
  (pushnew (the symbol operation) (loop-minimax-operations minimax))
  (when (and (cdr (loop-minimax-operations minimax))
	     (not (loop-minimax-flag-variable minimax)))
    (setf (loop-minimax-flag-variable minimax) (loop-gentemp 'loop-maxmin-flag-)))
  operation)


(defmacro with-minimax-value (lm &body body)
  (let ((init (loop-typed-init (loop-minimax-type lm)))
	(which (car (loop-minimax-operations lm)))
	(infinity-data (loop-minimax-infinity-data lm))
	(answer-var (loop-minimax-answer-variable lm))
	(temp-var (loop-minimax-temp-variable lm))
	(flag-var (loop-minimax-flag-variable lm))
	(type (loop-minimax-type lm)))
    (if flag-var
	`(let ((,answer-var ,init) (,temp-var ,init) (,flag-var nil))
	   (declare (type ,type ,answer-var ,temp-var))
	   ,@body)
	`(let ((,answer-var ,(if (eq which 'min) (first infinity-data) (second infinity-data)))
	       (,temp-var ,init))
	   (declare (type ,type ,answer-var ,temp-var))
	   ,@body))))


(defmacro loop-accumulate-minimax-value (lm operation form)
  (let* ((answer-var (loop-minimax-answer-variable lm))
	 (temp-var (loop-minimax-temp-variable lm))
	 (flag-var (loop-minimax-flag-variable lm))
	 (test
	   (hide-variable-reference
	     t (loop-minimax-answer-variable lm)
	     `(,(ecase operation
		  (min '<)
		  (max '>))
	       ,temp-var ,answer-var))))
    `(progn
       (setq ,temp-var ,form)
       (when ,(if flag-var `(or (not ,flag-var) ,test) test)
	 (setq ,@(and flag-var `(,flag-var t))
	       ,answer-var ,temp-var)))))



;;;; Loop Keyword Tables


#|
LOOP keyword tables are hash tables string keys and a test of EQUAL.

The actual descriptive/dispatch structure used by LOOP is called a "loop
universe" contains a few tables and parameterizations.  The basic idea is
that we can provide a non-extensible ANSI-compatible loop environment,
an extensible ANSI-superset loop environment, and (for such environments
as CLOE) one which is "sufficiently close" to the old Genera-vintage
LOOP for use by old user programs without requiring all of the old LOOP
code to be loaded.
|#


;;;; Token Hackery


;;;Compare two "tokens".  The first is the frob out of *LOOP-SOURCE-CODE*,
;;; the second a symbol to check against.
(defun loop-tequal (x1 x2)
  (and (symbolp x1) (string= x1 x2)))


(defun loop-tassoc (kwd alist)
  (and (symbolp kwd) (assoc kwd alist :test #'string=)))


(defun loop-tmember (kwd list)
  (and (symbolp kwd) (member kwd list :test #'string=)))


(defun loop-lookup-keyword (loop-token table)
  (and (symbolp loop-token)
       (values (gethash (symbol-name loop-token) table))))


(defmacro loop-store-table-data (symbol table datum)
  `(setf (gethash (symbol-name ,symbol) ,table) ,datum))


(defstruct (loop-universe
	     (:print-function print-loop-universe)
	     (:copier nil)
	     (:predicate nil))
  keywords					;hash table, value = (fn-name . extra-data).
  iteration-keywords				;hash table, value = (fn-name . extra-data).
  for-keywords					;hash table, value = (fn-name . extra-data).
  path-keywords					;hash table, value = (fn-name . extra-data).
  type-symbols					;hash table of type SYMBOLS, test EQ, value = CL type specifier.
  type-keywords					;hash table of type STRINGS, test EQUAL, value = CL type spec.
  ansi						;NIL, T, or :EXTENDED.
  implicit-for-required				;see loop-hack-iteration
  )


(defun print-loop-universe (u stream level)
  (declare (ignore level))
  (let ((str (case (loop-universe-ansi u)
	       ((nil) "Non-ANSI")
	       ((t) "ANSI")
	       (:extended "Extended-ANSI")
	       (t (loop-universe-ansi u)))))
    ;;Cloe could be done with the above except for bootstrap lossage...
    #+CLOE
    (format stream "#<~S ~A ~X>" (type-of u) str (sys::address-of u))
    #+(or Genera cmu)					;@@@@ This is reallly the ANSI definition.
    (print-unreadable-object (u stream :type t :identity t)
      (princ str stream))
    #-(or Genera CLOE cmu)
    (format stream "#<~S ~A>" (type-of u) str)
    ))


;;;This is the "current" loop context in use when we are expanding a
;;;loop.  It gets bound on each invocation of LOOP.
(defvar *loop-universe*)


(defun make-standard-loop-universe (&key keywords for-keywords iteration-keywords path-keywords
				    type-keywords type-symbols ansi)
  #-(and CLOE Source-Bootstrap) (check-type ansi (member nil t :extended))
  (flet ((maketable (entries)
	   (let* ((size (length entries))
		  (ht (make-hash-table :size (if (< size 10) 10 size) :test #'equal)))
	     (dolist (x entries) (setf (gethash (symbol-name (car x)) ht) (cadr x)))
	     ht)))
    (make-loop-universe
      :keywords (maketable keywords)
      :for-keywords (maketable for-keywords)
      :iteration-keywords (maketable iteration-keywords)
      :path-keywords (maketable path-keywords)
      :ansi ansi
      :implicit-for-required (not (null ansi))
      :type-keywords (maketable type-keywords)
      :type-symbols (let* ((size (length type-symbols))
			   (ht (make-hash-table :size (if (< size 10) 10 size) :test #'eq)))
		      (dolist (x type-symbols)
			(if (atom x) (setf (gethash x ht) x) (setf (gethash (car x) ht) (cadr x))))
		      ht)))) 


;;;; Setq Hackery


(defvar *loop-destructuring-hooks*
	nil
  "If not NIL, this must be a list of two things:
a LET-like macro, and a SETQ-like macro, which perform LOOP-style destructuring.")


(defun loop-make-psetq (frobs)
  (and frobs
       (loop-make-desetq
	 (list (car frobs)
	       (if (null (cddr frobs)) (cadr frobs)
		   `(prog1 ,(cadr frobs)
			   ,(loop-make-psetq (cddr frobs))))))))


(defun loop-make-desetq (var-val-pairs)
  (if (null var-val-pairs)
      nil
      (cons (if *loop-destructuring-hooks*
		(cadr *loop-destructuring-hooks*)
		'loop-really-desetq)
	    var-val-pairs)))


(defvar *loop-desetq-temporary*
	(make-symbol "LOOP-DESETQ-TEMP"))


(defmacro loop-really-desetq (&environment env &rest var-val-pairs)
  (labels ((find-non-null (var)
	     ;; see if there's any non-null thing here
	     ;; recurse if the list element is itself a list
	     (do ((tail var)) ((not (consp tail)) tail)
	       (when (find-non-null (pop tail)) (return t))))
	   (loop-desetq-internal (var val &optional temp)
	     ;; returns a list of actions to be performed
	     (typecase var
	       (null
		 (when (consp val)
		   ;; don't lose possible side-effects
		   (if (eq (car val) 'prog1)
		       ;; these can come from psetq or desetq below.
		       ;; throw away the value, keep the side-effects.
		       ;;Special case is for handling an expanded POP.
		       (mapcan #'(lambda (x)
				   (and (consp x)
					(or (not (eq (car x) 'car))
					    (not (symbolp (cadr x)))
					    (not (symbolp (setq x (macroexpand x env)))))
					(cons x nil)))
			       (cdr val))
		       `(,val))))
	       (cons
		 (let* ((car (car var))
			(cdr (cdr var))
			(car-non-null (find-non-null car))
			(cdr-non-null (find-non-null cdr)))
		   (when (or car-non-null cdr-non-null)
		     (if cdr-non-null
			 (let* ((temp-p temp)
				(temp (or temp *loop-desetq-temporary*))
				(body #+LOOP-Prefer-POP `(,@(loop-desetq-internal
							      car
							      `(prog1 (car ,temp)
								      (setq ,temp (cdr ,temp))))
							  ,@(loop-desetq-internal cdr temp temp))
				      #-LOOP-Prefer-POP `(,@(loop-desetq-internal car `(car ,temp))
							  (setq ,temp (cdr ,temp))
							  ,@(loop-desetq-internal cdr temp temp))))
			   (if temp-p
			       `(,@(unless (eq temp val)
				     `((setq ,temp ,val)))
				 ,@body)
			       `((let ((,temp ,val))
				   ,@body))))
			 ;; no cdring to do
			 (loop-desetq-internal car `(car ,val) temp)))))
	       (otherwise
		 (unless (eq var val)
		   `((setq ,var ,val)))))))
    (do ((actions))
	((null var-val-pairs)
	 (if (null (cdr actions)) (car actions) `(progn ,@(nreverse actions))))
      (setq actions (revappend
		      (loop-desetq-internal (pop var-val-pairs) (pop var-val-pairs))
		      actions)))))


;;;; LOOP-local variables

;;;This is the "current" pointer into the LOOP source code.
(defvar *loop-source-code*)


;;;This is the pointer to the original, for things like NAMED that
;;;insist on being in a particular position
(defvar *loop-original-source-code*)


;;;This is *loop-source-code* as of the "last" clause.  It is used
;;;primarily for generating error messages (see loop-error, loop-warn).
(defvar *loop-source-context*)


;;;List of names for the LOOP, supplied by the NAMED clause.
(defvar *loop-names*)

;;;The macroexpansion environment given to the macro.
(defvar *loop-macro-environment*)

;;;This holds variable names specified with the USING clause.
;;; See LOOP-NAMED-VARIABLE.
(defvar *loop-named-variables*)

;;; LETlist-like list being accumulated for one group of parallel bindings.
(defvar *loop-variables*)

;;;List of declarations being accumulated in parallel with
;;;*loop-variables*.
(defvar *loop-declarations*)

;;;Used by LOOP for destructuring binding, if it is doing that itself.
;;; See loop-make-variable.
(defvar *loop-desetq-crocks*)

;;; List of wrapping forms, innermost first, which go immediately inside
;;; the current set of parallel bindings being accumulated in
;;; *loop-variables*.  The wrappers are appended onto a body.  E.g.,
;;; this list could conceivably has as its value ((with-open-file (g0001
;;; g0002 ...))), with g0002 being one of the bindings in
;;; *loop-variables* (this is why the wrappers go inside of the variable
;;; bindings).
(defvar *loop-wrappers*)

;;;This accumulates lists of previous values of *loop-variables* and the
;;;other lists  above, for each new nesting of bindings.  See
;;;loop-bind-block.
(defvar *loop-bind-stack*)

;;;This is a LOOP-global variable for the (obsolete) NODECLARE clause
;;;which inhibits  LOOP from actually outputting a type declaration for
;;;an iteration (or any) variable.
(defvar *loop-nodeclare*)

;;;This is simply a list of LOOP iteration variables, used for checking
;;;for duplications.
(defvar *loop-iteration-variables*)


;;;List of prologue forms of the loop, accumulated in reverse order.
(defvar *loop-prologue*)

(defvar *loop-before-loop*)
(defvar *loop-body*)
(defvar *loop-after-body*)

;;;This is T if we have emitted any body code, so that iteration driving
;;;clauses can be disallowed.   This is not strictly the same as
;;;checking *loop-body*, because we permit some clauses  such as RETURN
;;;to not be considered "real" body (so as to permit the user to "code"
;;;an  abnormal return value "in loop").
(defvar *loop-emitted-body*)


;;;List of epilogue forms (supplied by FINALLY generally), accumulated
;;; in reverse order.
(defvar *loop-epilogue*)

;;;List of epilogue forms which are supplied after the above "user"
;;;epilogue.  "normal" termination return values are provide by putting
;;;the return form in here.  Normally this is done using
;;;loop-emit-final-value, q.v.
(defvar *loop-after-epilogue*)

;;;The "culprit" responsible for supplying a final value from the loop.
;;;This  is so loop-emit-final-value can moan about multiple return
;;;values being supplied.
(defvar *loop-final-value-culprit*)

;;;If not NIL, we are in some branch of a conditional.  Some clauses may
;;;be disallowed.
(defvar *loop-inside-conditional*)

;;;If not NIL, this is a temporary bound around the loop for holding the
;;;temporary  value for "it" in things like "when (f) collect it".  It
;;;may be used as a supertemporary by some other things.
(defvar *loop-when-it-variable*)

;;;Sometimes we decide we need to fold together parts of the loop, but
;;;some part of the generated iteration  code is different for the first
;;;and remaining iterations.  This variable will be the temporary which 
;;;is the flag used in the loop to tell whether we are in the first or
;;;remaining iterations.
(defvar *loop-never-stepped-variable*)

;;;List of all the value-accumulation descriptor structures in the loop.
;;; See loop-get-collection-info.
(defvar *loop-collection-cruft*)		; for multiple COLLECTs (etc)


;;;; Code Analysis Stuff


(defun loop-constant-fold-if-possible (form &optional expected-type)
  #+Genera (declare (values new-form constantp constant-value))
  (let ((new-form form) (constantp nil) (constant-value nil))
    #+Genera (setq new-form (compiler:optimize-form form *loop-macro-environment*
						    :repeat t
						    :do-macro-expansion t
						    :do-named-constants t
						    :do-inline-forms t
						    :do-optimizers t
						    :do-constant-folding t
						    :do-function-args t)
		   constantp (constantp new-form *loop-macro-environment*)
		   constant-value (and constantp (lt:evaluate-constant new-form *loop-macro-environment*)))
    #-Genera (when (setq constantp (constantp new-form))
	       (setq constant-value (eval new-form)))
    (when (and constantp expected-type)
      (unless (typep constant-value expected-type)
	(loop-warn "The form ~S evaluated to ~S, which was not of the anticipated type ~S."
		   form constant-value expected-type)
	(setq constantp nil constant-value nil)))
    (values new-form constantp constant-value)))


(defun loop-constantp (form)
  #+Genera (constantp form *loop-macro-environment*)
  #-Genera (constantp form))


;;;; LOOP Iteration Optimization

(defvar *loop-duplicate-code*
	nil)


(defvar *loop-iteration-flag-variable*
	(make-symbol "LOOP-NOT-FIRST-TIME"))


(defun loop-code-duplication-threshold (env)
  (multiple-value-bind (speed space) (loop-optimization-quantities env)
    (+ 40 (* (- speed space) 10))))


(defmacro loop-body (&environment env
		     prologue
		     before-loop
		     main-body
		     after-loop
		     epilogue
		     &aux rbefore rafter flagvar)
  (unless (= (length before-loop) (length after-loop))
    (error "LOOP-BODY called with non-synched before- and after-loop lists."))
  ;;All our work is done from these copies, working backwards from the end:
  (setq rbefore (reverse before-loop) rafter (reverse after-loop))
  (labels ((psimp (l)
	     (let ((ans nil))
	       (dolist (x l)
		 (when x
		   (push x ans)
		   (when (and (consp x) (member (car x) '(go return return-from)))
		     (return nil))))
	       (nreverse ans)))
	   (pify (l) (if (null (cdr l)) (car l) `(progn ,@l)))
	   (makebody ()
	     (let ((form `(tagbody
			    ,@(psimp (append prologue (nreverse rbefore)))
			 next-loop
			    ,@(psimp (append main-body (nreconc rafter `((go next-loop)))))
			 end-loop
			    ,@(psimp epilogue))))
	       (if flagvar `(let ((,flagvar nil)) ,form) form))))
    (when (or *loop-duplicate-code* (not rbefore))
      (return-from loop-body (makebody)))
    ;; This outer loop iterates once for each not-first-time flag test generated
    ;; plus once more for the forms that don't need a flag test
    (do ((threshold (loop-code-duplication-threshold env))) (nil)
      (declare (fixnum threshold))
      ;; Go backwards from the ends of before-loop and after-loop merging all the equivalent
      ;; forms into the body.
      (do () ((or (null rbefore) (not (equal (car rbefore) (car rafter)))))
	(push (pop rbefore) main-body)
	(pop rafter))
      (unless rbefore (return (makebody)))
      ;; The first forms in rbefore & rafter (which are the chronologically
      ;; last forms in the list) differ, therefore they cannot be moved
      ;; into the main body.  If everything that chronologically precedes
      ;; them either differs or is equal but is okay to duplicate, we can
      ;; just put all of rbefore in the prologue and all of rafter after
      ;; the body.  Otherwise, there is something that is not okay to
      ;; duplicate, so it and everything chronologically after it in
      ;; rbefore and rafter must go into the body, with a flag test to
      ;; distinguish the first time around the loop from later times.
      ;; What chronologically precedes the non-duplicatable form will
      ;; be handled the next time around the outer loop.
      (do ((bb rbefore (cdr bb)) (aa rafter (cdr aa)) (lastdiff nil) (count 0) (inc nil))
	  ((null bb) (return-from loop-body (makebody)))	;Did it.
	(cond ((not (equal (car bb) (car aa))) (setq lastdiff bb count 0))
	      ((or (not (setq inc (estimate-code-size (car bb) env)))
		   (> (incf count inc) threshold))
	       ;; Ok, we have found a non-duplicatable piece of code.  Everything
	       ;; chronologically after it must be in the central body.
	       ;; Everything chronologically at and after lastdiff goes into the
	       ;; central body under a flag test.
	       (let ((then nil) (else nil))
		 (do () (nil)
		   (push (pop rbefore) else)
		   (push (pop rafter) then)
		   (when (eq rbefore (cdr lastdiff)) (return)))
		 (unless flagvar
		   (push `(setq ,(setq flagvar *loop-iteration-flag-variable*) t) else))
		 (push `(if ,flagvar ,(pify (psimp then)) ,(pify (psimp else)))
		       main-body))
	       ;; Everything chronologically before lastdiff until the non-duplicatable form (car bb) 
	       ;; is the same in rbefore and rafter so just copy it into the body
	       (do () (nil)
		 (pop rafter)
		 (push (pop rbefore) main-body)
		 (when (eq rbefore (cdr bb)) (return)))
	       (return)))))))



(defun duplicatable-code-p (expr env)
  (if (null expr) 0
      (let ((ans (estimate-code-size expr env)))
	(declare (fixnum ans))
	;;@@@@ Use (DECLARATION-INFORMATION 'OPTIMIZE ENV) here to get an alist of
	;; optimize quantities back to help quantify how much code we are willing to
	;; duplicate.
	ans)))


(defvar *special-code-sizes*
	'((return 0) (progn 0)
	  (null 1) (not 1) (eq 1) (car 1) (cdr 1)
	  (when 1) (unless 1) (if 1)
	  (caar 2) (cadr 2) (cdar 2) (cddr 2)
	  (caaar 3) (caadr 3) (cadar 3) (caddr 3) (cdaar 3) (cdadr 3) (cddar 3) (cdddr 3)
	  (caaaar 4) (caaadr 4) (caadar 4) (caaddr 4)
	  (cadaar 4) (cadadr 4) (caddar 4) (cadddr 4)
	  (cdaaar 4) (cdaadr 4) (cdadar 4) (cdaddr 4)
	  (cddaar 4) (cddadr 4) (cdddar 4) (cddddr 4)))


(defvar *estimate-code-size-punt*
	'(block
	   do do* dolist
	   flet
	   labels lambda let let* locally
	   macrolet multiple-value-bind
	   prog prog*
	   symbol-macrolet
	   tagbody
	   unwind-protect
	   with-open-file))


(defun destructuring-size (x)
  (do ((x x (cdr x)) (n 0 (+ (destructuring-size (car x)) n)))
      ((atom x) (+ n (if (null x) 0 1)))))


(defun estimate-code-size (x env)
  (catch 'estimate-code-size
    (estimate-code-size-1 x env)))


(defun estimate-code-size-1 (x env)
  (flet ((list-size (l)
	   (let ((n 0))
	     (declare (fixnum n))
	     (dolist (x l n) (incf n (estimate-code-size-1 x env))))))
    ;;@@@@ ???? (declare (function list-size (list) fixnum))
    (cond ((constantp x #+Genera env) 1)
	  ((symbolp x) (multiple-value-bind (new-form expanded-p) (macroexpand-1 x env)
			 (if expanded-p (estimate-code-size-1 new-form env) 1)))
	  ((atom x) 1)				;??? self-evaluating???
	  ((symbolp (car x))
	   (let ((fn (car x)) (tem nil) (n 0))
	     (declare (symbol fn) (fixnum n))
	     (macrolet ((f (overhead &optional (args nil args-p))
			  `(the fixnum (+ (the fixnum ,overhead)
					  (the fixnum (list-size ,(if args-p args '(cdr x))))))))
	       (cond ((setq tem (get fn 'estimate-code-size))
		      (typecase tem
			(fixnum (f tem))
			(t (funcall tem x env))))
		     ((setq tem (assoc fn *special-code-sizes*)) (f (second tem)))
		     #+Genera
		     ((eq fn 'compiler:invisible-references) (list-size (cddr x)))
		     ((eq fn 'cond)
		      (dolist (clause (cdr x) n) (incf n (list-size clause)) (incf n)))
		     ((eq fn 'desetq)
		      (do ((l (cdr x) (cdr l))) ((null l) n)
			(setq n (+ n (destructuring-size (car l)) (estimate-code-size-1 (cadr l) env)))))
		     ((member fn '(setq psetq))
		      (do ((l (cdr x) (cdr l))) ((null l) n)
			(setq n (+ n (estimate-code-size-1 (cadr l) env) 1))))
		     ((eq fn 'go) 1)
		     ((eq fn 'function)
		      ;;This skirts the issue of implementationally-defined lambda macros
		      ;; by recognizing CL function names and nothing else.
		      (if (or (symbolp (cadr x))
			      (and (consp (cadr x)) (eq (caadr x) 'setf)))
			  1
			  (throw 'duplicatable-code-p nil)))
		     ((eq fn 'multiple-value-setq) (f (length (second x)) (cddr x)))
		     ((eq fn 'return-from) (1+ (estimate-code-size-1 (third x) env)))
		     ((or (special-operator-p fn) (member fn *estimate-code-size-punt*))
		      (throw 'estimate-code-size nil))
		     (t (multiple-value-bind (new-form expanded-p) (macroexpand-1 x env)
			  (if expanded-p
			      (estimate-code-size-1 new-form env)
			      (f 3))))))))
	  (t (throw 'estimate-code-size nil)))))


;;;; Loop Errors


(defun loop-context ()
  (do ((l *loop-source-context* (cdr l)) (new nil (cons (car l) new)))
      ((eq l (cdr *loop-source-code*)) (nreverse new))))


(defun loop-error (format-string &rest format-args)
  #+(or Genera CLOE) (declare (dbg:error-reporter))
  #+Genera (setq format-args (copy-list format-args))	;Don't ask.
  (error "~?~%Current LOOP context:~{ ~S~}." format-string format-args (loop-context)))


(defun loop-warn (format-string &rest format-args)
  (warn "~?~%Current LOOP context:~{ ~S~}." format-string format-args (loop-context)))


(defun loop-check-data-type (specified-type required-type
			     &optional (default-type required-type))
  (if (null specified-type)
      default-type
      (multiple-value-bind (a b) (subtypep specified-type required-type)
	(cond ((not b)
	       (loop-warn "LOOP couldn't verify that ~S is a subtype of the required type ~S."
			  specified-type required-type))
	      ((not a)
	       (loop-error "Specified data type ~S is not a subtype of ~S."
			   specified-type required-type)))
	specified-type)))


;;;INTERFACE: Traditional, ANSI, Lucid.
(defmacro loop-finish () 
  "Causes the iteration to terminate \"normally\", the same as implicit
termination by an iteration driving clause, or by use of WHILE or
UNTIL -- the epilogue code (if any) will be run, and any implicitly
collected result will be returned as the value of the LOOP."
  '(go end-loop))




(defun loop-build-destructuring-bindings (crocks forms)
  (if crocks
      `((destructuring-bind ,(car crocks) ,(cadr crocks)
        ,@(loop-build-destructuring-bindings (cddr crocks) forms)))
      forms))

(defun loop-translate (*loop-source-code* *loop-macro-environment* *loop-universe*)
  (let ((*loop-original-source-code* *loop-source-code*)
	(*loop-source-context* nil)
	(*loop-iteration-variables* nil)
	(*loop-variables* nil)
	(*loop-nodeclare* nil)
	(*loop-named-variables* nil)
	(*loop-declarations* nil)
	(*loop-desetq-crocks* nil)
	(*loop-bind-stack* nil)
	(*loop-prologue* nil)
	(*loop-wrappers* nil)
	(*loop-before-loop* nil)
	(*loop-body* nil)
	(*loop-emitted-body* nil)
	(*loop-after-body* nil)
	(*loop-epilogue* nil)
	(*loop-after-epilogue* nil)
	(*loop-final-value-culprit* nil)
	(*loop-inside-conditional* nil)
	(*loop-when-it-variable* nil)
	(*loop-never-stepped-variable* nil)
	(*loop-names* nil)
	(*loop-collection-cruft* nil))
    (loop-iteration-driver)
    (loop-bind-block)
    (let ((answer `(loop-body
		     ,(nreverse *loop-prologue*)
		     ,(nreverse *loop-before-loop*)
		     ,(nreverse *loop-body*)
		     ,(nreverse *loop-after-body*)
		     ,(nreconc *loop-epilogue* (nreverse *loop-after-epilogue*)))))
      (do () (nil)
	(setq answer `(block ,(pop *loop-names*) ,answer))
	(unless *loop-names* (return nil)))
      (dolist (entry *loop-bind-stack*)
	(let ((vars (first entry))
	      (dcls (second entry))
	      (crocks (third entry))
	      (wrappers (fourth entry)))
	  (dolist (w wrappers)
	    (setq answer (append w (list answer))))
	  (when (or vars dcls crocks)
	    (let ((forms (list answer)))
	      ;;(when crocks (push crocks forms))
	      (when dcls (push `(declare ,@dcls) forms))
	      (setq answer `(,(cond ((not vars) 'locally)
				    (*loop-destructuring-hooks* (first *loop-destructuring-hooks*))
				    (t 'let))
			     ,vars
			     ,@(loop-build-destructuring-bindings crocks forms)))))))
      answer)))


(defun loop-iteration-driver ()
  (do () ((null *loop-source-code*))
    (let ((keyword (car *loop-source-code*)) (tem nil))
      (cond ((not (symbolp keyword))
	     (loop-error "~S found where LOOP keyword expected." keyword))
	    (t (setq *loop-source-context* *loop-source-code*)
	       (loop-pop-source)
	       (cond ((setq tem (loop-lookup-keyword keyword (loop-universe-keywords *loop-universe*)))
		      ;;It's a "miscellaneous" toplevel LOOP keyword (do, collect, named, etc.)
		      (apply (symbol-function (first tem)) (rest tem)))
		     ((setq tem (loop-lookup-keyword keyword (loop-universe-iteration-keywords *loop-universe*)))
		      (loop-hack-iteration tem))
		     ((loop-tmember keyword '(and else))
		      ;; Alternative is to ignore it, ie let it go around to the next keyword...
		      (loop-error "Secondary clause misplaced at top level in LOOP macro: ~S ~S ~S ..."
				  keyword (car *loop-source-code*) (cadr *loop-source-code*)))
		     (t (loop-error "~S is an unknown keyword in LOOP macro." keyword))))))))



(defun loop-pop-source ()
  (if *loop-source-code*
      (pop *loop-source-code*)
      (loop-error "LOOP source code ran out when another token was expected.")))


(defun loop-get-compound-form ()
  (let ((form (loop-get-form)))
    (unless (consp form)
      (loop-error "Compound form expected, but found ~A." form))
    form))

(defun loop-get-progn ()
  (do ((forms (list (loop-get-compound-form))
              (cons (loop-get-compound-form) forms))
       (nextform (car *loop-source-code*)
                 (car *loop-source-code*)))
      ((atom nextform)
       (if (null (cdr forms)) (car forms) (cons 'progn (nreverse forms))))))


(defun loop-get-form ()
  (if *loop-source-code*
      (loop-pop-source)
      (loop-error "LOOP code ran out where a form was expected.")))


(defun loop-construct-return (form)
  `(return-from ,(car *loop-names*) ,form))


(defun loop-pseudo-body (form)
  (cond ((or *loop-emitted-body* *loop-inside-conditional*) (push form *loop-body*))
	(t (push form *loop-before-loop*) (push form *loop-after-body*))))

(defun loop-emit-body (form)
  (setq *loop-emitted-body* t)
  (loop-pseudo-body form))

(defun loop-emit-final-value (form)
  (push (loop-construct-return form) *loop-after-epilogue*)
  (when *loop-final-value-culprit*
    (loop-warn "LOOP clause is providing a value for the iteration,~@
	        however one was already established by a ~S clause."
	       *loop-final-value-culprit*))
  (setq *loop-final-value-culprit* (car *loop-source-context*)))


(defun loop-disallow-conditional (&optional kwd)
  #+(or Genera CLOE) (declare (dbg:error-reporter))
  (when *loop-inside-conditional*
    (loop-error "~:[This LOOP~;The LOOP ~:*~S~] clause is not permitted inside a conditional." kwd)))


;;;; Loop Types


(defun loop-typed-init (data-type)
  (when (and data-type (subtypep data-type 'number))
    (if (or (subtypep data-type 'float) (subtypep data-type '(complex float)))
	(coerce 0 data-type)
	0)))


(defun loop-optional-type (&optional variable)
  ;;No variable specified implies that no destructuring is permissible.
  (and *loop-source-code*			;Don't get confused by NILs...
       (let ((z (car *loop-source-code*)))
	 (cond ((loop-tequal z 'of-type)
		;;This is the syntactically unambigous form in that the form of the
		;; type specifier does not matter.  Also, it is assumed that the
		;; type specifier is unambiguously, and without need of translation,
		;; a common lisp type specifier or pattern (matching the variable) thereof.
		(loop-pop-source)
		(loop-pop-source))
		      
	       ((symbolp z)
		;;This is the (sort of) "old" syntax, even though we didn't used to support all of
		;; these type symbols.
		(let ((type-spec (or (gethash z (loop-universe-type-symbols *loop-universe*))
				     (gethash (symbol-name z) (loop-universe-type-keywords *loop-universe*)))))
		  (when type-spec
		    (loop-pop-source)
		    type-spec)))
	       (t 
		;;This is our sort-of old syntax.  But this is only valid for when we are destructuring,
		;; so we will be compulsive (should we really be?) and require that we in fact be
		;; doing variable destructuring here.  We must translate the old keyword pattern typespec
		;; into a fully-specified pattern of real type specifiers here.
		(if (consp variable)
		    (unless (consp z)
		     (loop-error
			"~S found where a LOOP keyword, LOOP type keyword, or LOOP type pattern expected."
			z))
		    (loop-error "~S found where a LOOP keyword or LOOP type keyword expected." z))
		(loop-pop-source)
		(labels ((translate (k v)
			   (cond ((null k) nil)
				 ((atom k)
				  (replicate
				    (or (gethash k (loop-universe-type-symbols *loop-universe*))
					(gethash (symbol-name k) (loop-universe-type-keywords *loop-universe*))
					(loop-error
					  "Destructuring type pattern ~S contains unrecognized type keyword ~S."
					  z k))
				    v))
				 ((atom v)
				  (loop-error
				    "Destructuring type pattern ~S doesn't match variable pattern ~S."
				    z variable))
				 (t (cons (translate (car k) (car v)) (translate (cdr k) (cdr v))))))
			 (replicate (typ v)
			   (if (atom v) typ (cons (replicate typ (car v)) (replicate typ (cdr v))))))
		  (translate z variable)))))))



;;;; Loop Variables


(defun loop-bind-block ()
  (when (or *loop-variables* *loop-declarations* *loop-wrappers*)
    (push (list (nreverse *loop-variables*) *loop-declarations* *loop-desetq-crocks* *loop-wrappers*)
	  *loop-bind-stack*)
    (setq *loop-variables* nil
	  *loop-declarations* nil
	  *loop-desetq-crocks* nil
	  *loop-wrappers* nil)))


(defun loop-make-variable (name initialization dtype &optional iteration-variable-p)
  (cond ((null name)
	 (cond ((not (null initialization))
		(push (list (setq name (loop-gentemp 'loop-ignore-))
			    initialization)
		      *loop-variables*)
		(push `(ignore ,name) *loop-declarations*))))
	((atom name)
	 (cond (iteration-variable-p
		(if (member name *loop-iteration-variables*)
		    (loop-error "Duplicated LOOP iteration variable ~S." name)
		    (push name *loop-iteration-variables*)))
	       ((assoc name *loop-variables*)
		(loop-error "Duplicated variable ~S in LOOP parallel binding." name)))
	 (unless (symbolp name)
	   (loop-error "Bad variable ~S somewhere in LOOP." name))
	 (loop-declare-variable name dtype)
	 ;; We use ASSOC on this list to check for duplications (above),
	 ;; so don't optimize out this list:
	 (push (list name (or initialization (loop-typed-init dtype)))
	       *loop-variables*))
	(initialization
	 (cond (*loop-destructuring-hooks*
		(loop-declare-variable name dtype)
		(push (list name initialization) *loop-variables*))
	       (t (let ((newvar (loop-gentemp 'loop-destructure-)))
		    (loop-declare-variable name dtype)
		    (push (list newvar initialization) *loop-variables*)
		    ;; *LOOP-DESETQ-CROCKS* gathered in reverse order.
		    (setq *loop-desetq-crocks*
		      (list* name newvar *loop-desetq-crocks*))
		    #+ignore
		    (loop-make-variable name nil dtype iteration-variable-p)))))
	(t (let ((tcar nil) (tcdr nil))
	     (if (atom dtype) (setq tcar (setq tcdr dtype))
		 (setq tcar (car dtype) tcdr (cdr dtype)))
	     (loop-make-variable (car name) nil tcar iteration-variable-p)
	     (loop-make-variable (cdr name) nil tcdr iteration-variable-p))))
  name)


(defun loop-make-iteration-variable (name initialization dtype)
  (loop-make-variable name initialization dtype t))


(defun loop-declare-variable (name dtype)
  (cond ((or (null name) (null dtype) (eq dtype t)) nil)
	((symbolp name)
	 (unless (or (eq dtype t) (member (the symbol name) *loop-nodeclare*))
	   (let ((dtype #-cmu dtype
			#+cmu
			(let ((init (loop-typed-init dtype)))
			  (if (typep init dtype)
			      dtype
			      `(or (member ,init) ,dtype)))))
	     (push `(type ,dtype ,name) *loop-declarations*))))
	((consp name)
	 (cond ((consp dtype)
		(loop-declare-variable (car name) (car dtype))
		(loop-declare-variable (cdr name) (cdr dtype)))
	       (t (loop-declare-variable (car name) dtype)
		  (loop-declare-variable (cdr name) dtype))))
	(t (error "Invalid LOOP variable passed in: ~S." name))))


(defun loop-maybe-bind-form (form data-type)
  (if (loop-constantp form)
      form
      (loop-make-variable (loop-gentemp 'loop-bind-) form data-type)))



(defun loop-do-if (for negatep)
  (let ((form (loop-get-form)) (*loop-inside-conditional* t) (it-p nil))
    (flet ((get-clause (for)
	     (do ((body nil)) (nil)
	       (let ((key (car *loop-source-code*)) (*loop-body* nil) data)
		 (cond ((not (symbolp key))
			(loop-error
			  "~S found where keyword expected getting LOOP clause after ~S."
			  key for))
		       (t (setq *loop-source-context* *loop-source-code*)
			  (loop-pop-source)
			  (when (loop-tequal (car *loop-source-code*) 'it)
			    (setq *loop-source-code*
				  (cons (or it-p (setq it-p (loop-when-it-variable)))
					(cdr *loop-source-code*))))
			  (cond ((or (not (setq data (loop-lookup-keyword
						       key (loop-universe-keywords *loop-universe*))))
				     (progn (apply (symbol-function (car data)) (cdr data))
					    (null *loop-body*)))
				 (loop-error
				   "~S does not introduce a LOOP clause that can follow ~S."
				   key for))
				(t (setq body (nreconc *loop-body* body)))))))
	       (if (loop-tequal (car *loop-source-code*) :and)
		   (loop-pop-source)
		   (return (if (cdr body) `(progn ,@(nreverse body)) (car body)))))))
      (let ((then (get-clause for))
	    (else (when (loop-tequal (car *loop-source-code*) :else)
		    (loop-pop-source)
		    (list (get-clause :else)))))
	(when (loop-tequal (car *loop-source-code*) :end)
	  (loop-pop-source))
	(when it-p (setq form `(setq ,it-p ,form)))
	(loop-pseudo-body
	  `(if ,(if negatep `(not ,form) form)
	       ,then
	       ,@else))))))


(defun loop-do-initially ()
  (loop-disallow-conditional :initially)
  (push (loop-get-progn) *loop-prologue*))

(defun loop-do-finally ()
  (loop-disallow-conditional :finally)
  (push (loop-get-progn) *loop-epilogue*))

(defun loop-do-do ()
  (loop-emit-body (loop-get-progn)))

(defun loop-do-named ()
  (let ((name (loop-pop-source)))
    (unless (symbolp name)
      (loop-error "~S is an invalid name for your LOOP." name))
    (when (or *loop-before-loop* *loop-body* *loop-after-epilogue* *loop-inside-conditional*)
      (loop-error "The NAMED ~S clause occurs too late." name))
    (when *loop-names*
      (loop-error "You may only use one NAMED clause in your loop: NAMED ~S ... NAMED ~S."
		  (car *loop-names*) name))
    (setq *loop-names* (list name nil))))

(defun loop-do-return ()
  (loop-pseudo-body (loop-construct-return (loop-get-form))))


;;;; Value Accumulation: List


(defstruct (loop-collector
	     (:copier nil)
	     (:predicate nil))
  name
  class
  (history nil)
  (tempvars nil)
  dtype
  (data nil))						;collector-specific data


(defun loop-get-collection-info (collector class default-type)
  (let ((form (loop-get-form))
	(dtype (and (not (loop-universe-ansi *loop-universe*)) (loop-optional-type)))
	(name (when (loop-tequal (car *loop-source-code*) 'into)
		(loop-pop-source)
		(loop-pop-source))))
    (when (not (symbolp name))
      (loop-error "Value accumulation recipient name, ~S, is not a symbol." name))
    (unless dtype
      (setq dtype (or (loop-optional-type) default-type)))
    (let ((cruft (find (the symbol name) *loop-collection-cruft*
		       :key #'loop-collector-name)))
      (cond ((not cruft)
	     (push (setq cruft (make-loop-collector
				 :name name :class class
				 :history (list collector) :dtype dtype))
		   *loop-collection-cruft*))
	    (t (unless (eq (loop-collector-class cruft) class)
		 (loop-error
		   "Incompatible kinds of LOOP value accumulation specified for collecting~@
		    ~:[as the value of the LOOP~;~:*INTO ~S~]: ~S and ~S."
		   name (car (loop-collector-history cruft)) collector))
	       (unless (equal dtype (loop-collector-dtype cruft))
		 (loop-warn
		   "Unequal datatypes specified in different LOOP value accumulations~@
		   into ~S: ~S and ~S."
		   name dtype (loop-collector-dtype cruft))
		 (when (eq (loop-collector-dtype cruft) t)
		   (setf (loop-collector-dtype cruft) dtype)))
	       (push collector (loop-collector-history cruft))))
      (values cruft form))))


(defun loop-list-collection (specifically)	;NCONC, LIST, or APPEND
  (multiple-value-bind (lc form) (loop-get-collection-info specifically 'list 'list)
    (let ((tempvars (loop-collector-tempvars lc)))
      (unless tempvars
	(setf (loop-collector-tempvars lc)
	      (setq tempvars (list* (loop-gentemp 'loop-list-head-)
				    (loop-gentemp 'loop-list-tail-)
				    (and (loop-collector-name lc)
					 (list (loop-collector-name lc))))))
	(push `(with-loop-list-collection-head ,tempvars) *loop-wrappers*)
	(unless (loop-collector-name lc)
	  (loop-emit-final-value `(loop-collect-answer ,(car tempvars) ,@(cddr tempvars)))))
      (ecase specifically
	(list (setq form `(list ,form)))
	(nconc nil)
	(append (unless (and (consp form) (eq (car form) 'list))
		  (setq form `(loop-copylist* ,form)))))
      (loop-emit-body `(loop-collect-rplacd ,tempvars ,form)))))


;;;; Value Accumulation: max, min, sum, count.



(defun loop-sum-collection (specifically required-type default-type)	;SUM, COUNT
  (multiple-value-bind (lc form)
      (loop-get-collection-info specifically 'sum default-type)
    (loop-check-data-type (loop-collector-dtype lc) required-type)
    (let ((tempvars (loop-collector-tempvars lc)))
      (unless tempvars
	(setf (loop-collector-tempvars lc)
	      (setq tempvars (list (loop-make-variable
				     (or (loop-collector-name lc)
					 (loop-gentemp 'loop-sum-))
				     nil (loop-collector-dtype lc)))))
	(unless (loop-collector-name lc)
	  (loop-emit-final-value (car (loop-collector-tempvars lc)))))
      (loop-emit-body
	(if (eq specifically 'count)
	    `(when ,form
	       (setq ,(car tempvars)
		     ,(hide-variable-reference t (car tempvars) `(1+ ,(car tempvars)))))
	    `(setq ,(car tempvars)
		   (+ ,(hide-variable-reference t (car tempvars) (car tempvars))
		      ,form)))))))



(defun loop-maxmin-collection (specifically)
  (multiple-value-bind (lc form)
      (loop-get-collection-info specifically 'maxmin *loop-real-data-type*)
    (loop-check-data-type (loop-collector-dtype lc) *loop-real-data-type*)
    (let ((data (loop-collector-data lc)))
      (unless data
	(setf (loop-collector-data lc)
	      (setq data (make-loop-minimax
			   (or (loop-collector-name lc) (loop-gentemp 'loop-maxmin-))
			   (loop-collector-dtype lc))))
	(unless (loop-collector-name lc)
	  (loop-emit-final-value (loop-minimax-answer-variable data))))
      (loop-note-minimax-operation specifically data)
      (push `(with-minimax-value ,data) *loop-wrappers*)
      (loop-emit-body `(loop-accumulate-minimax-value ,data ,specifically ,form))
      )))


;;;; Value Accumulation:  Aggregate Booleans

;;;ALWAYS and NEVER.
;;; Under ANSI these are not permitted to appear under conditionalization.
(defun loop-do-always (restrictive negate)
  (let ((form (loop-get-form)))
    (when restrictive (loop-disallow-conditional))
    (loop-emit-body `(,(if negate 'when 'unless) ,form
		      ,(loop-construct-return nil)))
    (loop-emit-final-value t)))



;;;THERIS.
;;; Under ANSI this is not permitted to appear under conditionalization.
(defun loop-do-thereis (restrictive)
  (when restrictive (loop-disallow-conditional))
  (loop-emit-body `(when (setq ,(loop-when-it-variable) ,(loop-get-form))
		     ,(loop-construct-return *loop-when-it-variable*))))


(defun loop-do-while (negate kwd &aux (form (loop-get-form)))
  (loop-disallow-conditional kwd)
  (loop-pseudo-body `(,(if negate 'when 'unless) ,form (go end-loop))))


(defun loop-do-with ()
  (loop-disallow-conditional :with)
  (do ((var) (val) (dtype)) (nil)
    (setq var (loop-pop-source)
	  dtype (loop-optional-type var)
	  val (cond ((loop-tequal (car *loop-source-code*) :=)
		     (loop-pop-source)
		     (loop-get-form))
		    (t nil)))
    (loop-make-variable var val dtype)
    (if (loop-tequal (car *loop-source-code*) :and)
	(loop-pop-source)
	(return (loop-bind-block)))))


;;;; The iteration driver

(defun loop-hack-iteration (entry)
  (flet ((make-endtest (list-of-forms)
	   (cond ((null list-of-forms) nil)
		 ((member t list-of-forms) '(go end-loop))
		 (t `(when ,(if (null (cdr (setq list-of-forms (nreverse list-of-forms))))
				(car list-of-forms)
				(cons 'or list-of-forms))
		       (go end-loop))))))
    (do ((pre-step-tests nil)
	 (steps nil)
	 (post-step-tests nil)
	 (pseudo-steps nil)
	 (pre-loop-pre-step-tests nil)
	 (pre-loop-steps nil)
	 (pre-loop-post-step-tests nil)
	 (pre-loop-pseudo-steps nil)
	 (tem) (data))
	(nil)
      ;; Note we collect endtests in reverse order, but steps in correct
      ;; order.  MAKE-ENDTEST does the nreverse for us.
      (setq tem (setq data (apply (symbol-function (first entry)) (rest entry))))
      (and (car tem) (push (car tem) pre-step-tests))
      (setq steps (nconc steps (loop-copylist* (car (setq tem (cdr tem))))))
      (and (car (setq tem (cdr tem))) (push (car tem) post-step-tests))
      (setq pseudo-steps (nconc pseudo-steps (loop-copylist* (car (setq tem (cdr tem))))))
      (setq tem (cdr tem))
      (when *loop-emitted-body*
	(loop-error "Iteration in LOOP follows body code."))
      (unless tem (setq tem data))
      (when (car tem) (push (car tem) pre-loop-pre-step-tests))
      (setq pre-loop-steps (nconc pre-loop-steps (loop-copylist* (car (setq tem (cdr tem))))))
      (when (car (setq tem (cdr tem))) (push (car tem) pre-loop-post-step-tests))
      (setq pre-loop-pseudo-steps (nconc pre-loop-pseudo-steps (loop-copylist* (cadr tem))))
      (unless (loop-tequal (car *loop-source-code*) :and)
	(setq *loop-before-loop* (list* (loop-make-desetq pre-loop-pseudo-steps)
					(make-endtest pre-loop-post-step-tests)
					(loop-make-psetq pre-loop-steps)
					(make-endtest pre-loop-pre-step-tests)
					*loop-before-loop*)
	      *loop-after-body* (list* (loop-make-desetq pseudo-steps)
				       (make-endtest post-step-tests)
				       (loop-make-psetq steps)
				       (make-endtest pre-step-tests)
				       *loop-after-body*))
	(loop-bind-block)
	(return nil))
      (loop-pop-source)				; flush the "AND"
      (when (and (not (loop-universe-implicit-for-required *loop-universe*))
		 (setq tem (loop-lookup-keyword
			     (car *loop-source-code*)
			     (loop-universe-iteration-keywords *loop-universe*))))
	;;Latest ANSI clarification is that the FOR/AS after the AND must NOT be supplied.
	(loop-pop-source)
	(setq entry tem)))))


;;;; Main Iteration Drivers


;FOR variable keyword ..args..
(defun loop-do-for ()
  (let* ((var (loop-pop-source))
	 (data-type (loop-optional-type var))
	 (keyword (loop-pop-source))
	 (first-arg nil)
	 (tem nil))
    (setq first-arg (loop-get-form))
    (unless (and (symbolp keyword)
		 (setq tem (loop-lookup-keyword
			     keyword
			     (loop-universe-for-keywords *loop-universe*))))
      (loop-error "~S is an unknown keyword in FOR or AS clause in LOOP." keyword))
    (apply (car tem) var first-arg data-type (cdr tem))))


(defun loop-do-repeat ()
  (let ((form (loop-get-form))
	(type (loop-check-data-type (loop-optional-type) *loop-real-data-type*)))
    (when (and (consp form) (eq (car form) 'the) (subtypep (second form) type))
      (setq type (second form)))
    (multiple-value-bind (number constantp value)
	(loop-constant-fold-if-possible form type)
      (cond ((and constantp (<= value 1)) `(t () () () ,(<= value 0) () () ()))
	    (t (let ((var (loop-make-variable (loop-gentemp 'loop-repeat-) number type)))
		 (if constantp
		     `((not (plusp (setq ,var (1- ,var)))) () () () () () () ())
		     `((minusp (setq ,var (1- ,var))) () () ()))))))))


(defun loop-when-it-variable ()
  (or *loop-when-it-variable*
      (setq *loop-when-it-variable*
	    (loop-make-variable (loop-gentemp 'loop-it-) nil nil))))


;;;; Various FOR/AS Subdispatches


;;;ANSI "FOR x = y [THEN z]" is sort of like the old Genera one when the THEN
;;; is omitted (other than being more stringent in its placement), and like
;;; the old "FOR x FIRST y THEN z" when the THEN is present.  I.e., the first
;;; initialization occurs in the loop body (first-step), not in the variable binding
;;; phase.
(defun loop-ansi-for-equals (var val data-type)
  (loop-make-iteration-variable var nil data-type)
  (cond ((loop-tequal (car *loop-source-code*) :then)
	 ;;Then we are the same as "FOR x FIRST y THEN z".
	 (loop-pop-source)
	 `(() (,var ,(loop-get-form)) () ()
	   () (,var ,val) () ()))
	(t ;;We are the same as "FOR x = y".
	 `(() (,var ,val) () ()))))


(defun loop-for-across (var val data-type)
  (loop-make-iteration-variable var nil data-type)
  (let ((vector-var (loop-gentemp 'loop-across-vector-))
	(index-var (loop-gentemp 'loop-across-index-)))
    (multiple-value-bind (vector-form constantp vector-value)
	(loop-constant-fold-if-possible val 'vector)
      (loop-make-variable
	vector-var vector-form
	(if (and (consp vector-form) (eq (car vector-form) 'the))
	    (cadr vector-form)
	    'vector))
      #+Genera (push `(system:array-register ,vector-var) *loop-declarations*)
      (loop-make-variable index-var 0 'fixnum)
      (let* ((length 0)
	     (length-form (cond ((not constantp)
				 (let ((v (loop-gentemp 'loop-across-limit-)))
				   (push `(setq ,v (length ,vector-var)) *loop-prologue*)
				   (loop-make-variable v 0 'fixnum)))
				(t (setq length (length vector-value)))))
	     (first-test `(>= ,index-var ,length-form))
	     (other-test first-test)
	     (step `(,var (aref ,vector-var ,index-var)))
	     (pstep `(,index-var (1+ ,index-var))))
	(declare (fixnum length))
	(when constantp
	  (setq first-test (= length 0))
	  (when (<= length 1)
	    (setq other-test t)))
	`(,other-test ,step () ,pstep
	  ,@(and (not (eq first-test other-test)) `(,first-test ,step () ,pstep)))))))



;;;; List Iteration


(defun loop-list-step (listvar)
  ;;We are not equipped to analyze whether 'FOO is the same as #'FOO here in any
  ;; sensible fashion, so let's give an obnoxious warning whenever 'FOO is used
  ;; as the stepping function.
  ;;While a Discerning Compiler may deal intelligently with (funcall 'foo ...), not
  ;; recognizing FOO may defeat some LOOP optimizations.
  (let ((stepper (cond ((loop-tequal (car *loop-source-code*) :by)
			(loop-pop-source)
			(loop-get-form))
		       (t '(function cdr)))))
    (cond ((and (consp stepper) (eq (car stepper) 'quote))
	   (loop-warn "Use of QUOTE around stepping function in LOOP will be left verbatim.")
	   (values `(funcall ,stepper ,listvar) nil))
	  ((and (consp stepper) (eq (car stepper) 'function))
	   (values (list (cadr stepper) listvar) (cadr stepper)))
	  (t (values `(funcall ,(loop-make-variable (loop-gentemp 'loop-fn-) stepper 'function)
			       ,listvar)
		     nil)))))


(defun loop-for-on (var val data-type)
  (multiple-value-bind (list constantp list-value) (loop-constant-fold-if-possible val)
    (let ((listvar var))
      (cond ((and var (symbolp var)) (loop-make-iteration-variable var list data-type))
	    (t (loop-make-variable (setq listvar (loop-gentemp)) list 'list)
	       (loop-make-iteration-variable var nil data-type)))
      (multiple-value-bind (list-step step-function) (loop-list-step listvar)
	(declare #+(and (not LOOP-Prefer-POP) (not CLOE)) (ignore step-function))
	;;@@@@ The CLOE problem above has to do with bug in macroexpansion of multiple-value-bind.
	(let* ((first-endtest
		(hide-variable-reference
		 (eq var listvar)
		 listvar
		 ;; the following should use `atom' instead of `endp', per
		 ;; [bug2428]
		 `(atom ,listvar)))
	       (other-endtest first-endtest))
	  (when (and constantp (listp list-value))
	    (setq first-endtest (null list-value)))
	  (cond ((eq var listvar)
		 ;;Contour of the loop is different because we use the user's variable...
		 `(() (,listvar ,(hide-variable-reference t listvar list-step)) ,other-endtest
		   () () () ,first-endtest ()))
		#+LOOP-Prefer-POP
		((and step-function
		      (let ((n (cdr (assoc step-function '((cdr . 1) (cddr . 2)
							   (cdddr . 3) (cddddr . 4))))))
			(and n (do ((l var (cdr l)) (i 0 (1+ i)))
				   ((atom l) (and (null l) (= i n)))
				 (declare (fixnum i))))))
		 (let ((step (mapcan #'(lambda (x) (list x `(pop ,listvar))) var)))
		   `(,other-endtest () () ,step ,first-endtest () () ,step)))
		(t (let ((step `(,var ,listvar)) (pseudo `(,listvar ,list-step)))
		     `(,other-endtest ,step () ,pseudo
		       ,@(and (not (eq first-endtest other-endtest))
			      `(,first-endtest ,step () ,pseudo)))))))))))


(defun loop-for-in (var val data-type)
  (multiple-value-bind (list constantp list-value) (loop-constant-fold-if-possible val)
    (let ((listvar (loop-gentemp 'loop-list-)))
      (loop-make-iteration-variable var nil data-type)
      (loop-make-variable listvar list 'list)
      (multiple-value-bind (list-step step-function) (loop-list-step listvar)
	#-LOOP-Prefer-POP (declare (ignore step-function))
	(let* ((first-endtest `(endp ,listvar))
	       (other-endtest first-endtest)
	       (step `(,var (car ,listvar)))
	       (pseudo-step `(,listvar ,list-step)))
	  (when (and constantp (listp list-value))
	    (setq first-endtest (null list-value)))
	  #+LOOP-Prefer-POP (when (eq step-function 'cdr)
			      (setq step `(,var (pop ,listvar)) pseudo-step nil))
	  `(,other-endtest ,step () ,pseudo-step
	    ,@(and (not (eq first-endtest other-endtest))
		   `(,first-endtest ,step () ,pseudo-step))))))))


;;;; Iteration Paths


(defstruct (loop-path
	     (:copier nil)
	     (:predicate nil))
  names
  preposition-groups
  inclusive-permitted
  function
  user-data)


(defun add-loop-path (names function universe &key preposition-groups inclusive-permitted user-data)
  (unless (listp names) (setq names (list names)))
  ;; Can't do this due to CLOS bootstrapping problems.
  #-(or Genera (and CLOE Source-Bootstrap)) (check-type universe loop-universe)
  (let ((ht (loop-universe-path-keywords universe))
	(lp (make-loop-path
	      :names (mapcar #'symbol-name names)
	      :function function
	      :user-data user-data
	      :preposition-groups (mapcar #'(lambda (x) (if (listp x) x (list x))) preposition-groups)
	      :inclusive-permitted inclusive-permitted)))
    (dolist (name names) (setf (gethash (symbol-name name) ht) lp))
    lp))


;;; Note:  path functions are allowed to use loop-make-variable, hack
;;; the prologue, etc.
(defun loop-for-being (var val data-type)
  ;; FOR var BEING each/the pathname prep-phrases using-stuff...
  ;; each/the = EACH or THE.  Not clear if it is optional, so I guess we'll warn.
  (let ((path nil)
	(data nil)
	(inclusive nil)
	(stuff nil)
	(initial-prepositions nil))
    (cond ((loop-tmember val '(:each :the)) (setq path (loop-pop-source)))
	  ((loop-tequal (car *loop-source-code*) :and)
	   (loop-pop-source)
	   (setq inclusive t)
	   (unless (loop-tmember (car *loop-source-code*) '(:its :each :his :her))
	     (loop-error "~S found where ITS or EACH expected in LOOP iteration path syntax."
			 (car *loop-source-code*)))
	   (loop-pop-source)
	   (setq path (loop-pop-source))
	   (setq initial-prepositions `((:in ,val))))
	  (t (loop-error "Unrecognizable LOOP iteration path syntax.  Missing EACH or THE?")))
    (cond ((not (symbolp path))
	   (loop-error "~S found where a LOOP iteration path name was expected." path))
	  ((not (setq data (loop-lookup-keyword path (loop-universe-path-keywords *loop-universe*))))
	   (loop-error "~S is not the name of a LOOP iteration path." path))
	  ((and inclusive (not (loop-path-inclusive-permitted data)))
	   (loop-error "\"Inclusive\" iteration is not possible with the ~S LOOP iteration path." path)))
    (let ((fun (loop-path-function data))
	  (preps (nconc initial-prepositions
			(loop-collect-prepositional-phrases (loop-path-preposition-groups data) t)))
	  (user-data (loop-path-user-data data)))
      (when (symbolp fun) (setq fun (symbol-function fun)))
      (setq stuff (if inclusive
		      (apply fun var data-type preps :inclusive t user-data)
		      (apply fun var data-type preps user-data))))
    (when *loop-named-variables*
      (loop-error "Unused USING variables: ~S." *loop-named-variables*))
    ;; STUFF is now (bindings prologue-forms . stuff-to-pass-back).  Protect the system from the user
    ;; and the user from himself.
    (unless (member (length stuff) '(6 10))
      (loop-error "Value passed back by LOOP iteration path function for path ~S has invalid length."
		  path))
    (do ((l (car stuff) (cdr l)) (x)) ((null l))
      (if (atom (setq x (car l)))
	  (loop-make-iteration-variable x nil nil)
	  (loop-make-iteration-variable (car x) (cadr x) (caddr x))))
    (setq *loop-prologue* (nconc (reverse (cadr stuff)) *loop-prologue*))
    (cddr stuff)))



;;;INTERFACE:  Lucid, exported.
;;; i.e., this is part of our extended ansi-loop interface.
(defun named-variable (name)
  (let ((tem (loop-tassoc name *loop-named-variables*)))
    (declare (list tem))
    (cond ((null tem) (values (loop-gentemp) nil))
	  (t (setq *loop-named-variables* (delete tem *loop-named-variables*))
	     (values (cdr tem) t)))))


(defun loop-collect-prepositional-phrases (preposition-groups &optional USING-allowed initial-phrases)
  (flet ((in-group-p (x group) (car (loop-tmember x group))))
    (do ((token nil)
	 (prepositional-phrases initial-phrases)
	 (this-group nil nil)
	 (this-prep nil nil)
	 (disallowed-prepositions
	   (mapcan #'(lambda (x)
		       (loop-copylist*
			 (find (car x) preposition-groups :test #'in-group-p)))
		   initial-phrases))
	 (used-prepositions (mapcar #'car initial-phrases)))
	((null *loop-source-code*) (nreverse prepositional-phrases))
      (declare (symbol this-prep))
      (setq token (car *loop-source-code*))
      (dolist (group preposition-groups)
	(when (setq this-prep (in-group-p token group))
	  (return (setq this-group group))))
      (cond (this-group
	     (when (member this-prep disallowed-prepositions)
	       (loop-error
		 (if (member this-prep used-prepositions)
		     "A ~S prepositional phrase occurs multiply for some LOOP clause."
		     "Preposition ~S used when some other preposition has subsumed it.")
		 token))
	     (setq used-prepositions (if (listp this-group)
					 (append this-group used-prepositions)
					 (cons this-group used-prepositions)))
	     (loop-pop-source)
	     (push (list this-prep (loop-get-form)) prepositional-phrases))
	    ((and USING-allowed (loop-tequal token 'using))
	     (loop-pop-source)
	     (do ((z (loop-pop-source) (loop-pop-source)) (tem)) (nil)
	       (when (or (atom z)
			 (atom (cdr z))
			 (not (null (cddr z)))
			 (not (symbolp (car z)))
			 (and (cadr z) (not (symbolp (cadr z)))))
		 (loop-error "~S bad variable pair in path USING phrase." z))
	       (when (cadr z)
		 (if (setq tem (loop-tassoc (car z) *loop-named-variables*))
		     (loop-error
		       "The variable substitution for ~S occurs twice in a USING phrase,~@
		        with ~S and ~S."
		       (car z) (cadr z) (cadr tem))
		     (push (cons (car z) (cadr z)) *loop-named-variables*)))
	       (when (or (null *loop-source-code*) (symbolp (car *loop-source-code*)))
		 (return nil))))
	    (t (return (nreverse prepositional-phrases)))))))


;;;; Master Sequencer Function


(defun loop-sequencer (indexv indexv-type indexv-user-specified-p
			  variable variable-type
			  sequence-variable sequence-type
			  step-hack default-top
			  prep-phrases)
   (let ((endform nil)				;Form (constant or variable) with limit value.
	 (sequencep nil)			;T if sequence arg has been provided.
	 (testfn nil)				;endtest function
	 (test nil)				;endtest form.
	 (stepby (1+ (or (loop-typed-init indexv-type) 0)))	;Our increment.
	 (stepby-constantp t)
	 (step nil)				;step form.
	 (dir nil)				;Direction of stepping: NIL, :UP, :DOWN.
	 (inclusive-iteration nil)		;T if include last index.
	 (start-given nil)			;T when prep phrase has specified start
	 (start-value nil)
	 (start-constantp nil)
	 (limit-given nil)			;T when prep phrase has specified end
	 (limit-constantp nil)
	 (limit-value nil)
	 )
     (when variable (loop-make-iteration-variable variable nil variable-type))
     (do ((l prep-phrases (cdr l)) (prep) (form) (odir)) ((null l))
       (setq prep (caar l) form (cadar l))
       (case prep
	 ((:of :in)
	  (setq sequencep t)
	  (loop-make-variable sequence-variable form sequence-type))
	 ((:from :downfrom :upfrom)
	  (setq start-given t)
	  (cond ((eq prep :downfrom) (setq dir ':down))
		((eq prep :upfrom) (setq dir ':up)))
	  (multiple-value-setq (form start-constantp start-value)
	    (loop-constant-fold-if-possible form indexv-type))
	  (loop-make-iteration-variable indexv form indexv-type))
	 ((:upto :to :downto :above :below)
	  (cond ((loop-tequal prep :upto) (setq inclusive-iteration (setq dir ':up)))
		((loop-tequal prep :to) (setq inclusive-iteration t))
		((loop-tequal prep :downto) (setq inclusive-iteration (setq dir ':down)))
		((loop-tequal prep :above) (setq dir ':down))
		((loop-tequal prep :below) (setq dir ':up)))
	  (setq limit-given t)
	  (multiple-value-setq (form limit-constantp limit-value)
	    (loop-constant-fold-if-possible form indexv-type))
	  (setq endform (if limit-constantp
			    `',limit-value
			    (loop-make-variable
			      (loop-gentemp 'loop-limit-) form indexv-type))))
	 (:by
	   (multiple-value-setq (form stepby-constantp stepby)
	     (loop-constant-fold-if-possible form indexv-type))
	   (unless stepby-constantp
	     (loop-make-variable (setq stepby (loop-gentemp 'loop-step-by-)) form indexv-type)))
	 (t (loop-error
	      "~S invalid preposition in sequencing or sequence path.~@
	       Invalid prepositions specified in iteration path descriptor or something?"
	      prep)))
       (when (and odir dir (not (eq dir odir)))
	 (loop-error "Conflicting stepping directions in LOOP sequencing path"))
       (setq odir dir))
     (when (and sequence-variable (not sequencep))
       (loop-error "Missing OF or IN phrase in sequence path"))
     ;; Now fill in the defaults.
     (unless start-given
       (loop-make-iteration-variable
	 indexv
	 (setq start-constantp t start-value (or (loop-typed-init indexv-type) 0))
	 indexv-type))
     (cond ((member dir '(nil :up))
	    (when (or limit-given default-top)
	      (unless limit-given
		(loop-make-variable (setq endform (loop-gentemp 'loop-seq-limit-))
				    nil indexv-type)
		(push `(setq ,endform ,default-top) *loop-prologue*))
	      (setq testfn (if inclusive-iteration '> '>=)))
	    (setq step (if (eql stepby 1) `(1+ ,indexv) `(+ ,indexv ,stepby))))
	   (t (unless start-given
		(unless default-top
		  (loop-error "Don't know where to start stepping."))
		(push `(setq ,indexv (1- ,default-top)) *loop-prologue*))
	      (when (and default-top (not endform))
		(setq endform (loop-typed-init indexv-type) inclusive-iteration t))
	      (when endform (setq testfn (if inclusive-iteration  '< '<=)))
	      (setq step (if (eql stepby 1) `(1- ,indexv) `(- ,indexv ,stepby)))))
     (when testfn (setq test (hide-variable-reference t indexv `(,testfn ,indexv ,endform))))
     (when step-hack
       (setq step-hack `(,variable ,(hide-variable-reference indexv-user-specified-p indexv step-hack))))
     (let ((first-test test) (remaining-tests test))
       (when (and stepby-constantp start-constantp limit-constantp)
	 (when (setq first-test (funcall (symbol-function testfn) start-value limit-value))
	   (setq remaining-tests t)))
       `(() (,indexv ,(hide-variable-reference t indexv step)) ,remaining-tests ,step-hack
	 () () ,first-test ,step-hack))))


;;;; Interfaces to the Master Sequencer



(defun loop-for-arithmetic (var val data-type kwd)
  (loop-sequencer
    var (loop-check-data-type data-type *loop-real-data-type*) t
    nil nil nil nil nil nil
    (loop-collect-prepositional-phrases
      '((:from :upfrom :downfrom) (:to :upto :downto :above :below) (:by))
      nil (list (list kwd val)))))


(defun loop-sequence-elements-path (variable data-type prep-phrases
				    &key fetch-function size-function sequence-type element-type)
  (multiple-value-bind (indexv indexv-user-specified-p) (named-variable 'index)
    (let ((sequencev (named-variable 'sequence)))
      #+Genera (when (and sequencev
			  (symbolp sequencev)
			  sequence-type
			  (subtypep sequence-type 'vector)
			  (not (member (the symbol sequencev) *loop-nodeclare*)))
		 (push `(sys:array-register ,sequencev) *loop-declarations*))
      (list* nil nil				; dummy bindings and prologue
	     (loop-sequencer
	       indexv 'fixnum indexv-user-specified-p
	       variable (or data-type element-type)
	       sequencev sequence-type
	       `(,fetch-function ,sequencev ,indexv) `(,size-function ,sequencev)
	       prep-phrases)))))


;;;; Builtin LOOP Iteration Paths


#||
(loop for v being the hash-values of ht do (print v))
(loop for k being the hash-keys of ht do (print k))
(loop for v being the hash-values of ht using (hash-key k) do (print (list k v)))
(loop for k being the hash-keys of ht using (hash-value v) do (print (list k v)))
||#

(defun loop-hash-table-iteration-path (variable data-type prep-phrases &key which)
  (check-type which (member hash-key hash-value))
  (cond ((or (cdr prep-phrases) (not (member (caar prep-phrases) '(:in :of))))
	 (loop-error "Too many prepositions!"))
	((null prep-phrases) (loop-error "Missing OF or IN in ~S iteration path.")))
  (let ((ht-var (loop-gentemp 'loop-hashtab-))
	(next-fn (loop-gentemp 'loop-hashtab-next-))
	(dummy-predicate-var nil)
	(post-steps nil))
    (multiple-value-bind (other-var other-p)
	(named-variable (if (eq which 'hash-key) 'hash-value 'hash-key))
      ;;@@@@ named-variable returns a second value of T if the name was actually
      ;; specified, so clever code can throw away the gensym'ed up variable if
      ;; it isn't really needed.
      ;;The following is for those implementations in which we cannot put dummy NILs
      ;; into multiple-value-setq variable lists.
      #-Genera (setq other-p t
		     dummy-predicate-var (loop-when-it-variable))
      (let ((key-var nil)
	    (val-var nil)
	    (bindings `((,variable nil ,data-type)
			(,ht-var ,(cadar prep-phrases))
			,@(and other-p other-var `((,other-var nil))))))
	(if (eq which 'hash-key)
	    (setq key-var variable val-var (and other-p other-var))
	    (setq key-var (and other-p other-var) val-var variable))
	(push `(with-hash-table-iterator (,next-fn ,ht-var)) *loop-wrappers*)
	(when (consp key-var)
	  (setq post-steps `(,key-var ,(setq key-var (loop-gentemp 'loop-hash-key-temp-))
			     ,@post-steps))
	  (push `(,key-var nil) bindings))
	(when (consp val-var)
	  (setq post-steps `(,val-var ,(setq val-var (loop-gentemp 'loop-hash-val-temp-))
			     ,@post-steps))
	  (push `(,val-var nil) bindings))
	`(,bindings				;bindings
	  ()					;prologue
	  ()					;pre-test
	  ()					;parallel steps
	  (not (multiple-value-setq (,dummy-predicate-var ,key-var ,val-var) (,next-fn)))	;post-test
	  ,post-steps)))))


(defun loop-package-symbols-iteration-path (variable data-type prep-phrases &key symbol-types)
  (cond ((or (cdr prep-phrases) (not (member (caar prep-phrases) '(:in :of))))
	 (loop-error "Too many prepositions!"))
	((null prep-phrases) (loop-error "Missing OF or IN in ~S iteration path.")))
  (unless (symbolp variable)
    (loop-error "Destructuring is not valid for package symbol iteration."))
  (let ((pkg-var (loop-gentemp 'loop-pkgsym-))
	(next-fn (loop-gentemp 'loop-pkgsym-next-)))
    (push `(with-package-iterator (,next-fn ,pkg-var ,@symbol-types)) *loop-wrappers*)
    `(((,variable nil ,data-type) (,pkg-var ,(cadar prep-phrases)))
      ()
      ()
      ()
      (not (multiple-value-setq (,(progn
				    ;;@@@@ If an implementation can get away without actually
				    ;; using a variable here, so much the better.
				    #+Genera NIL
				    #-Genera (loop-when-it-variable))
				 ,variable)
	     (,next-fn)))
      ())))

;;;; ANSI Loop

(defun make-ansi-loop-universe (extended-p)
  (let ((w (make-standard-loop-universe
	     :keywords `((named (loop-do-named))
			 (initially (loop-do-initially))
			 (finally (loop-do-finally))
			 (do (loop-do-do))
			 (doing (loop-do-do))
			 (return (loop-do-return))
			 (collect (loop-list-collection list))
			 (collecting (loop-list-collection list))
			 (append (loop-list-collection append))
			 (appending (loop-list-collection append))
			 (nconc (loop-list-collection nconc))
			 (nconcing (loop-list-collection nconc))
			 (count (loop-sum-collection count ,*loop-real-data-type* fixnum))
			 (counting (loop-sum-collection count ,*loop-real-data-type* fixnum))
			 (sum (loop-sum-collection sum number number))
			 (summing (loop-sum-collection sum number number))
			 (maximize (loop-maxmin-collection max))
			 (minimize (loop-maxmin-collection min))
			 (maximizing (loop-maxmin-collection max))
			 (minimizing (loop-maxmin-collection min))
			 (always (loop-do-always t nil))	; Normal, do always
			 (never (loop-do-always t t))	; Negate the test on always.
			 (thereis (loop-do-thereis t))
			 (while (loop-do-while nil :while))	; Normal, do while
			 (until (loop-do-while t :until))	; Negate the test on while
			 (when (loop-do-if when nil))	; Normal, do when
			 (if (loop-do-if if nil))	; synonymous
			 (unless (loop-do-if unless t))	; Negate the test on when
			 (with (loop-do-with)))
	     :for-keywords '((= (loop-ansi-for-equals))
			     (across (loop-for-across))
			     (in (loop-for-in))
			     (on (loop-for-on))
			     (from (loop-for-arithmetic :from))
			     (downfrom (loop-for-arithmetic :downfrom))
			     (upfrom (loop-for-arithmetic :upfrom))
			     (below (loop-for-arithmetic :below))
			     (to (loop-for-arithmetic :to))
			     (upto (loop-for-arithmetic :upto))
			     (by (loop-for-arithmetic :by))
			     (being (loop-for-being)))
	     :iteration-keywords '((for (loop-do-for))
				   (as (loop-do-for))
				   (repeat (loop-do-repeat)))
	     :type-symbols '(array atom bignum bit bit-vector character compiled-function
				   complex cons double-float fixnum float
				   function hash-table integer keyword list long-float
				   nil null number package pathname random-state
				   ratio rational readtable sequence short-float
				   simple-array simple-bit-vector simple-string
				   simple-vector single-float standard-char
				   stream string base-char
				   symbol t vector)
	     :type-keywords nil
	     :ansi (if extended-p :extended t))))
    (add-loop-path '(hash-key hash-keys) 'loop-hash-table-iteration-path w
		   :preposition-groups '((:of :in))
		   :inclusive-permitted nil
		   :user-data '(:which hash-key))
    (add-loop-path '(hash-value hash-values) 'loop-hash-table-iteration-path w
		   :preposition-groups '((:of :in))
		   :inclusive-permitted nil
		   :user-data '(:which hash-value))
    (add-loop-path '(symbol symbols) 'loop-package-symbols-iteration-path w
		   :preposition-groups '((:of :in))
		   :inclusive-permitted nil
		   :user-data '(:symbol-types (:internal :external :inherited)))
    (add-loop-path '(external-symbol external-symbols) 'loop-package-symbols-iteration-path w
		   :preposition-groups '((:of :in))
		   :inclusive-permitted nil
		   :user-data '(:symbol-types (:external)))
    (add-loop-path '(present-symbol present-symbols) 'loop-package-symbols-iteration-path w
		   :preposition-groups '((:of :in))
		   :inclusive-permitted nil
		   :user-data '(:symbol-types (:internal :external)))
    w))


(defparameter *loop-ansi-universe*
	      (make-ansi-loop-universe nil))


(defun loop-standard-expansion (keywords-and-forms environment universe)
  (if (and keywords-and-forms (symbolp (car keywords-and-forms)))
      (loop-translate keywords-and-forms environment universe)
      (let ((tag (gensym)))
	`(block nil (tagbody ,tag (progn ,@keywords-and-forms) (go ,tag))))))


;;;INTERFACE: ANSI
(defmacro loop (&environment env &rest keywords-and-forms)
  #+Genera (declare (compiler:do-not-record-macroexpansions)
		    (zwei:indentation . zwei:indent-loop))
  (loop-standard-expansion keywords-and-forms env *loop-ansi-universe*))

#+allegro
(defun excl::complex-loop-expander (body env)
  (loop-standard-expansion body env *loop-ansi-universe*))
+++ /home/matt/src/nightshade-0.0+/src/code/mach-os.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/mach-os.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/mach.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/mach.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/machdef.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/machdef.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/macros.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/macros.lisp.
+++++++++++++++
  ;; FIX doc?
---------------
+++ /home/matt/src/nightshade-0.0+/src/code/mipsstrops.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/mipsstrops.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/misc.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/misc.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/module.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/module.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/multi-proc.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/multi-proc.lisp.
+++++++++++++++
  can not call process-wait. Since the predicate may be evaluated many
  times by the scheduler it should be relatively fast native compiled code.
---------------
  can not call process-wait. Since the predicate may be evaluated may
  times by the scheduler it should be relative fast native compiled code.
+++ /home/matt/src/nightshade-0.0+/src/code/ntrace.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/ntrace.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/time.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/time.lisp.
+++++++++++++++
	  get-decoded-time encode-universal-time decode-universal-time
 	  universal-to-internal-real-time internal-real-to-universal-time))

---------------
	  get-decoded-time encode-universal-time decode-universal-time))

+++++++++++++++
;;; Universal-To-Internal-Real-Time  --  Public
;;;
(defun universal-to-internal-real-time (universal-time)
  "Return Universal-time in internal real-time format."
  (locally (declare (optimize (speed 3) (safety 0)))
    (let ((seconds (- universal-time unix-to-universal-time)))
      ;; FIX Is the typeing here correct?
      (declare (type (unsigned-byte 32) seconds))
      (or *internal-real-time-base-seconds* (get-internal-real-time))
      (truly-the (unsigned-byte 32)
		 (the (unsigned-byte 32)
		      (* (the (unsigned-byte 32)
			      (- seconds *internal-real-time-base-seconds*))
			 internal-time-units-per-second))))))

;;; Internal-Real-To-Universal-Time  --  Public
;;;
(defun internal-real-to-universal-time (real-time)
  "Return Real-time in universal format."
  (or *internal-real-time-base-seconds* (get-internal-real-time))
  (+ (truncate (/ real-time internal-time-units-per-second))
     *internal-real-time-base-seconds*
     unix-to-universal-time))

---------------
+++++++++++++++
---------------
;;; CURRENT-TIMEZONE -- internal.
;;;
;;; Returns two values:
;;;  - the minuteswest of GMT.
;;;  - T if daylight savings is in effect, NIL if not.
;;;
(alien:def-alien-routine get-timezone c-call:void
  (when c-call:long :in)
  (minutes-west c-call:int :out)
  (daylight-savings-p alien:boolean :out))


+++++++++++++++
  "Returns a single integer for the current time of day in universal time
   format."
---------------
  "Returns a single integer for the current time of
   day in universal time format."
+++++++++++++++
		(minwest dst)
	      (unix:get-timezone (- universal-time unix-to-universal-time))
---------------
		(ignore minwest dst)
	      (get-timezone (- universal-time unix-to-universal-time))
	    (declare (ignore ignore))
+++++++++++++++
				     &optional time-zone dst)
---------------
				     &optional time-zone)
+++++++++++++++
	(+ second (* (+ minute
			(* (+ hours (if dst
					(1- time-zone)
					time-zone))
			   60))
		     60))
	(let* ((minwest-guess
		(unix:get-timezone (- (* hours 60 60)
				      unix-to-universal-time)))
	       (guess (+ minute (* hours 60) minwest-guess))
	       (minwest
		(unix:get-timezone (- (* guess 60)
				      unix-to-universal-time))))
---------------
	(+ second (* (+ minute (* (+ hours time-zone) 60)) 60))
	(let* ((minwest-guess
		(nth-value 1
			   (get-timezone (- (* hours 60 60)
					    unix-to-universal-time))))
	       (guess (+ minute (* hours 60) minwest-guess))
	       (minwest
		(nth-value 1
			   (get-timezone (- (* guess 60)
					    unix-to-universal-time)))))
/home/matt/src/nightshade-0.0+/src/code/loop.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
+++ /home/matt/src/nightshade-0.0+/src/code/osf1-os.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/osf1-os.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/package.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/package.lisp.
+++++++++++++++
;	(loop with (key1 . set1) = current-arg
	(loop for (key1 . set1) = current-arg
---------------
	(loop with (key1 . set1) = current-arg
+++++++++++++++
;;;    Check for name conflict caused by the import and let the user 
---------------
;;;    Check for name conflic caused by the import and let the user 
+++ /home/matt/src/nightshade-0.0+/src/code/parse-time.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/parse-time.lisp.
+++++++++++++++
    (weekday)))

---------------
))

+++++++++++++++
;;; Deal-with-dow sets the decoded-time values to match the day of week.

;;; FIX confirm that this works when day is adjusted past the last day of
;;; the month.
(defun deal-with-dow (form-value parsed-values)
  (let ((dotw (decoded-time-dotw parsed-values)))
    (setf (decoded-time-dotw parsed-values) form-value)
    ;; Increase day to the required day of the week.
    (incf (decoded-time-day parsed-values)
	  (- (if (< form-value dotw)
		 (+ form-value 7)
		 form-value)
	     dotw))))

---------------
+++++++++++++++
	(weekday (deal-with-dow form-value parsed-values))
---------------
	(weekday (setf (decoded-time-dotw parsed-values) form-value))
+++ /home/matt/src/nightshade-0.0+/src/code/pathname.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/pathname.lisp.
+++++++++++++++
;; mimiced using structures for efficiency.

---------------
;; mimiced using structures for efficency.

+++++++++++++++
  "Accessor for the pathname's type."
---------------
  "Accessor for the pathname's name."
+++ /home/matt/src/nightshade-0.0+/src/code/pmax-disassem.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/pmax-disassem.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/pmax-machdef.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/pmax-machdef.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/pmax-vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/pmax-vm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/ppc-vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/ppc-vm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/pprint.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/pprint.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/pred.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/pred.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/print.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/print.lisp.
+++++++++++++++
	   ;; If it's a number, character, or interned symbol, we do not want
---------------
	   ;; If it a number, character, or interned symbol, we do not want
+++ /home/matt/src/nightshade-0.0+/src/code/profile.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/profile.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/purify.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/purify.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/query.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/query.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/rand-mt19937.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/rand-mt19937.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/rand.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/rand.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/reader.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/reader.lisp.
+++++++++++++++
  ;; of these functions is called with appropriate arguments whenever any
---------------
  ;; of these functions called with appropriate arguments whenever any
+++++++++++++++
#|
(defun read-delimited-list-from-string (string end-char
					       &key (start 0) end
					       recursive-p)
  "The characters of string are successively given to the lisp reader and
   the objects built by the reader is returned as a list.  Macro chars will
   take effect."
  (declare (string string))
  (with-array-data ((string string :offset-var offset)
		    (start start)
		    (end (or end (length string))))
    (unless read-from-string-spares
      (push (internal-make-string-input-stream "" 0 0)
	    read-from-string-spares))
    (let ((stream (pop read-from-string-spares)))
      (setf (string-input-stream-string stream) string)
      (setf (string-input-stream-current stream) start)
      (setf (string-input-stream-end stream) end)
      (unwind-protect
	  (values (read-delimited-list end-char stream recursive-p)
		  (- (string-input-stream-current stream) offset))
	(push stream read-from-string-spares)))))
|#

---------------
+++ /home/matt/src/nightshade-0.0+/src/code/remote.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/remote.lisp.
+++++++++++++++
;;; Execute the body remotely.  Subforms are executed locally in the lexical
;;; envionment of the macro call.  No values are returned.
;;;
(defmacro remote (wire-form &body forms)
  "Evaluates the given forms remotely.  No values are returned, as the
remote evaluation is asynchronous."
---------------
;;; Execute the body remotly. Subforms are executed locally in the lexical
;;; envionment of the macro call. No values are returned.
;;;
(defmacro remote (wire-form &body forms)
  "Evaluates the given forms remotly. No values are returned, as the remote
evaluation is asyncronus."
+++ /home/matt/src/nightshade-0.0+/src/code/room.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/room.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/rt-machdef.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/rt-machdef.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/rt-vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/rt-vm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/run-program.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/run-program.lisp.
+++++++++++++++
(defun %spawn (program args env pty-name stdin stdout stderr)
  "Fork Program, setting up the standard streams to Stdin, Stdout and
   Stderr."
  (let ((pid (unix:unix-fork)))
    (or (zerop pid) (return-from %spawn pid))

    ;; Put the process in a unique process group.
    #+hpux
    (unix:unix-setsid)
    #+(or linux svr4)
    (unix:unix-setpgrp 0 0)
    #-(or linux svr4 hpux)
    (unix:unix-setpgrp 0 (unix:unix-getpid))

    (when pty-name
      ;; Make the process part of some other pty.
      (let ((fd (unix:unix-open "/dev/tty" unix:o_rdwr 0)))
	(when (> fd 0)
	  (alien:with-alien ((alien-zero c-call:int 0))
	    (unix:unix-ioctl fd unix:TIOCNOTTY
			     (alien:alien-sap (alien:addr alien-zero))))
	  (unix:unix-close fd)))
      (let ((fd (unix:unix-open pty-name unix:o_rdwr 0)))
	(unix:unix-dup2 fd 0)
	(unix:unix-dup2 fd 1)
	(unix:unix-dup2 fd 2)
	(unix:unix-close fd)))

    ;; Set up standard streams.
    (if (>= stdin 0) (unix:unix-dup2 stdin 0))
    (if (>= stdout 0) (unix:unix-dup2 stdout 1))
    (if (>= stderr 0) (unix:unix-dup2 stderr 2))

    ;; Close all other file descriptors.
    (loop
      for fd downfrom (1- #+svr4 (unix:unix-sysconf
				  #| FIX |# unix:_SC_OPEN_MAX)
			  #-svr4 (unix:unix-getdtablesize))
      to 3 do
      (unix:unix-close fd))

    ;; Exec the program.
    (unix:unix-execve program args env)

    ;; Exec failed, so try /bin/sh.
    (unix:unix-execve "/bin/sh"
		      (cons "sh" (cons program (cdr args)))
		      env)

    ;; Shell exec failed, exit with error.
    (unix:unix-exit 1)))

#|
(%spawn "/home/matt/src/tests/c/parsing" nil nil nil 0 0 0)
(%spawn "/home/matt/src/tests/c/parsing" nil *environment-list* nil 0 0 0)
(%spawn "/home/matt/bin/test" nil nil nil 0 0 0)
(%spawn "/home/matt/bin/test" nil *environment-list* nil 0 0 0)

(ed::with-pop-up-display (stream)
	(ext::run-program "/home/matt/src/tests/c/parsing" nil :output stream))

(ed::with-pop-up-display (stream)
	(ext::run-program "/home/matt/src/tests/c/parsing" nil
			  :input t
			  :output t))

(let ((cookie (list 0)))
  (multiple-value-bind (pty-name)
		       (open-pty t cookie)
    (ed::message "pty-name: ~S" pty-name)
    (%spawn "/home/matt/src/tests/c/parsing" nil nil pty-name 0 0 0)))

(ed::with-pop-up-display (stream)
	(ext::run-program "/home/matt/bin/test" nil :output stream))
|#

---------------
(alien:def-alien-routine spawn c-call:int
  (program c-call:c-string)
  (argv (* c-call:c-string))
  (envp (* c-call:c-string))
  (pty-name c-call:c-string)
  (stdin c-call:int)
  (stdout c-call:int)
  (stderr c-call:int))


+++++++++++++++
  "Run-program creates a new process and runs the unix program in the
---------------
  "Run-program creates a new process and runs the unix progam in the
+++++++++++++++
		   (let ((child-pid
			  (without-gcing
			   (%spawn pfile args env pty-name
				   stdin stdout stderr))))
		     (or child-pid
			 (error "Failed to fork child process: ~A"
				(unix:get-unix-error-msg)))
		     (setf proc (make-process :pid child-pid
					      :%status :running
					      :pty pty-stream
					      :input input-stream
					      :output output-stream
					      :error error-stream
					      :status-hook status-hook
					      :cookie cookie))
		     (push proc *active-processes*))))))))
---------------
		    (with-c-strvec (argv args)
		      (with-c-strvec
			  (envp (mapcar #'(lambda (entry)
					    (concatenate
					     'string
					     (symbol-name (car entry))
					     "="
					     (cdr entry)))
					env))
			(let ((child-pid
			       (without-gcing
				(spawn pfile argv envp pty-name
				       stdin stdout stderr))))
			  (when (< child-pid 0)
			    (error "Could not fork child process: ~A"
				   (unix:get-unix-error-msg)))
			  (setf proc (make-process :pid child-pid
						   :%status :running
						   :pty pty-stream
						   :input input-stream
						   :output output-stream
						   :error error-stream
						   :status-hook status-hook
						   :cookie cookie))
			     (push proc *active-processes*))))))))))
+++ /home/matt/src/nightshade-0.0+/src/code/sap.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/sap.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/save.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/save.lisp.
+++++++++++++++
      `("Nightshade "
---------------
      `("CMU Common Lisp "
+++++++++++++++
(setf (getf *herald-items* :subsystems)
      '(terpri "Loaded subsystems:"))

---------------
(setf (getf *herald-items* :bugs)
      '("Send questions to cmucl-help@cons.org. and bug reports to cmucl-imp@cons.org."
	terpri
	"Loaded subsystems:"))

+++ /home/matt/src/nightshade-0.0+/src/code/scavhook.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/scavhook.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/search-list.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/search-list.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/seq.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/seq.lisp.
+++++++++++++++
	  map-into split
          identity))

	  
---------------
	  map-into
          identity)) ; Yep, thet's whar it is.

	  
+++++++++++++++
		 end key)
  "Returns the zero-origin index of the first element in SEQUENCE
   satisfying the test (default is EQL) with the given ITEM."
---------------
		  end key)
  "Returns the zero-origin index of the first element in SEQUENCE
   satisfying the test (default is EQL) with the given ITEM"
+++++++++++++++
		  (vector-search sequence2 sequence1))))


;;;; Split.

(defun split (sequence separator &key (start 0) end)
  "Split the portion of Sequence from Start to End at Separators.  Return a
   list of the resulting subsequences."
  (let ((result))
    (loop for pos = (position separator sequence :start start :end end)
          do
      (or pos
	  (return-from split
		       (nreverse (push (subseq sequence
					       start) result))))
      (push (subseq sequence start pos) result)
      (setq start (1+ pos)))))
---------------
		  (vector-search sequence2 sequence1))))
+++ /home/matt/src/nightshade-0.0+/src/code/serve-event.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/serve-event.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/setf-funs.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/setf-funs.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/sgi-vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/sgi-vm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/sharpm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/sharpm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/signal.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/signal.lisp.
+++++++++++++++
(defmacro define-signal-handler (name what
				      &optional (function 'error)
				                (exit-hemlock t))
  (let ((call `(,function ,(concatenate 'simple-string what " at #x~x.")
			  (with-alien ((scp (* sigcontext) scp))
			    (sap-int (vm:sigcontext-program-counter scp))))))
    `(defun ,name (signal code scp)
       (declare (ignore signal code)
		(type system-area-pointer scp)
		(optimize (inhibit-warnings 3)))
       ,(if exit-hemlock
	    (cons 'system:without-hemlock call)
	    call))))

(define-signal-handler sigint-handler "Interrupted" break nil)
---------------
(defmacro define-signal-handler (name what &optional (function 'error))
  `(defun ,name (signal code scp)
     (declare (ignore signal code)
	      (type system-area-pointer scp)
	      (optimize (inhibit-warnings 3)))
     (system:without-hemlock
      (,function ,(concatenate 'simple-string what " at #x~x.")
		 (with-alien ((scp (* sigcontext) scp))
		   (sap-int (vm:sigcontext-program-counter scp)))))))

(define-signal-handler sigint-handler "Interrupted" break)
+++ /home/matt/src/nightshade-0.0+/src/code/sort.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/sort.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/sparc-machdef.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/sparc-machdef.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/sparc-svr4-vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/sparc-svr4-vm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/sparc-vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/sparc-vm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/stream.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/stream.lisp.
+++++++++++++++
;;; must be an n-bin method.
---------------
;;; myst be an n-bin method.
+++ /home/matt/src/nightshade-0.0+/src/code/string.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/string.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/struct.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/struct.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/sunos-os.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/sunos-os.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/symbol.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/symbol.lisp.
+++++++++++++++
(defun gensym (&optional (thing "G"))  ; FIX what is thing?
---------------
(defun gensym (&optional (thing "G"))
+++++++++++++++
	(declare (optimize (speed 3) (safety 0) (inhibit-warnings 3)))
---------------
	(declare (optimize (speed 3) (safety 0)(inhibit-warnings 3)))
+++ /home/matt/src/nightshade-0.0+/src/code/sysmacs.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/sysmacs.lisp.
/home/matt/src/nightshade-0.0+/src/code/ftp.lisp only present in /home/matt/src/nightshade-0.0+/src/code/.
+++ /home/matt/src/nightshade-0.0+/src/code/tty-inspect.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/tty-inspect.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/type-boot.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/type-boot.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/type-init.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/type-init.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/type.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/type.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/typedefs.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/typedefs.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/unix-glibc2.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/unix-glibc2.lisp.
+++++++++++++++
	  execgrp readoth writeoth execoth readall writeall execall
	  unix-fchmod unix-chown unix-fchown
---------------
	  execgrp readoth writeoth execoth unix-fchmod unix-chown unix-fchown
+++++++++++++++
	  get-timezone unix-gettimeofday
---------------
	  unix-gettimeofday
+++++++++++++++
;;; Like syscall, but if it fails, signal an error instead of returning error
---------------
;;; Like syscall, but if it fails, signal an error instead of returing error
+++++++++++++++
	    (gr-name   c-string) ;; group name
---------------
	    (gr-name c-string)   ;; group name
+++++++++++++++
(defun unix-gethostbyaddr (addr length type)
---------------
(defun unix-gethostbyaddr(addr length type)
+++++++++++++++
  "Executes the Unix execve system call.  If the system call succeeds, lisp
---------------
  "Executes the Unix execve system call.  If the system call suceeds, lisp
+++++++++++++++
  ;; FIX return?
---------------
+++++++++++++++
		    tiocgpgrp
		    (alien:alien-sap (alien:addr alien-pgrp)))
---------------
		     tiocgpgrp
		     (alien:alien-sap (alien:addr alien-pgrp)))
+++++++++++++++
					       (function c-string)))))
---------------
					     (function c-string)))))
+++++++++++++++
		      (cast (slot utsname 'domainname) c-string))
---------------
		     (cast (slot utsname 'domainname) c-string))
+++++++++++++++
   times on a specified file.  NIL and an error number are
---------------
   times on a specified file.  NIL and an error number is
+++++++++++++++
   descriptors.  See the FIX UNIX Programmer's Manual for more
---------------
   descriptors.  See the UNIX Programmer's Manual for more
+++++++++++++++
;; FIX (unix-chmod "xx" "a+w") would be cool too
---------------
+++++++++++++++
      readall           Read by all.
      writeall          Write by all.
      execoth           Execute (search directory) by all.
  
---------------
+++++++++++++++
(defun get-timezone (time)
  "Return minutes west of UTC and a daylight saving flag.  If daylight
   saving information is available the flag is positive during daylight
   saving and 0 outside daylight saving, else the flag is -1."
  (with-alien ((timet (array time-t 1))  ; FIX (timet time-t (make-alien time-t time))? (then timet a pointer)
	       (local (struct tm))
	       (utc (struct tm)))
    (setf (deref timet 0) time)
    (if (zerop
	 (sap-int
	  (alien-sap
	   (alien-funcall (extern-alien "localtime_r"
					(function (* void)
						  (* time-t) (* (struct tm))))
			  (addr (deref timet 0)) (addr local)))))
	(error "get-timezone localtime_r failed."))
    (if (zerop
	 (sap-int
	  (alien-sap
	   (alien-funcall (extern-alien "gmtime_r"
					(function (* void)
						  (* time-t) (* (struct tm))))
			  (addr (deref timet 0)) (addr utc)))))
	(error "get-timezone gmtime_r failed."))
    (let ((minutes-west (- (+ (slot utc 'tm-min)
			      (* (slot utc 'tm-hour) 60))
			   (+ (slot local 'tm-min)
			      (* (slot local 'tm-hour) 60)))))
      (if (eq (mod (1+ (slot utc 'tm-wday)) 7) (slot local 'tm-wday))
	  (decf minutes-west (* 24 60))
	  (if (eq (slot utc 'tm-wday) (mod (1+ (slot utc 'tm-wday)) 7))
	      (incf minutes-west (* 24 60))))
      (values minutes-west (slot local 'tm-isdst)))))

#|
(get-timezone (- (get-universal-time) lisp::unix-to-universal-time))
(unix-localtime (- (get-universal-time) lisp::unix-to-universal-time))
(unix-gmtime (- (get-universal-time) lisp::unix-to-universal-time))
|#

(defun unix-get-minutes-west (secs)
  (multiple-value-bind (minutes dst) (get-timezone secs)
    (declare (ignore dst))
    (values minutes)))

(defun unix-get-timezone (secs)
  (multiple-value-bind (minutes dst) (get-timezone secs)
    (declare (ignore minutes))
---------------
(def-alien-routine get-timezone c-call:void
  (when c-call:long :in)
  (minutes-west c-call:int :out)
  (daylight-savings-p alien:boolean :out))

(defun unix-get-minutes-west (secs)
  (multiple-value-bind (ignore minutes dst) (get-timezone secs)
    (declare (ignore ignore) (ignore dst))
    (values minutes)))
  
(defun unix-get-timezone (secs)
  (multiple-value-bind (ignore minutes dst) (get-timezone secs)
    (declare (ignore ignore) (ignore minutes))
+++++++++++++++
(defun unix-getitimer (which)
---------------
(defun unix-getitimer(which)
+++++++++++++++
		which (alien-sap (addr itvn))(alien-sap (addr itvo))))))  ;; FIX )(

---------------
		which (alien-sap (addr itvn))(alien-sap (addr itvo))))))

+++++++++++++++
(defconstant writeall (logior writeown
			      writegrp
			      writeoth)
  "Write by all.")
(defconstant readall (logior readown
			     readgrp
			     readoth)
  "Read by all.")
(defconstant execall (logior execown
			     execgrp
			     execoth)
  "Execute (search directory) by all.")

---------------
+++ /home/matt/src/nightshade-0.0+/src/code/unix.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/unix.lisp.
+++++++++++++++
;; Don't use this now: we (FIX ?)
---------------
;; Don't use this now: we 
+++ /home/matt/src/nightshade-0.0+/src/code/vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/vm.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/weak.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/weak.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/wire.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/wire.lisp.
+++ /home/matt/src/nightshade-0.0+/src/code/x86-vm.lisp
--- /home/matt/src/cmucl-2002-08-23-19h00-clean/src/code/x86-vm.lisp.
/home/matt/src/nightshade-0.0+/src/code/defstruct.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/package.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/exports.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/error.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/format.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/filesys.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/generic-site.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/list.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/lispinit.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/symbol.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/macros.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/pathname.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/save.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/reader.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/print.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/struct.lisp.CKP only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/seq.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/unix-glibc2.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/unix.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/numbers.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/format-time.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/multi-proc.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/run-program.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/setf-funs.lisp.CKP only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/unix.lisp.CKP only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/c-call.lisp.CKP only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/gencgc.lisp only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/gc.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/c-call.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/array.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/gencgc.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/alieneval.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/base64.lisp only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/parse-time.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/byte-interp.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/remote.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/time.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/gc.lisp.mostly-static-test.bak only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/profile.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/ftp.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/fd-stream.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/internet.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/calendar.lisp only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/signal.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/bit-bash.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/stream.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/calendar.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/base64.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
/home/matt/src/nightshade-0.0+/src/code/eval.lisp.BAK only present in /home/matt/src/nightshade-0.0+/src/code/.
