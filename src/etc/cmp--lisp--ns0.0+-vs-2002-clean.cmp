-*- flush-trailing-whitespace: nil -*-

Config only present in :src/nightshade-0.0+/src/lisp/.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.FreeBSD
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.FreeBSD.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.FreeBSD_gencgc
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.FreeBSD_gencgc.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.NetBSD
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.NetBSD.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.NetBSD_gencgc
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.NetBSD_gencgc.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.OpenBSD
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.OpenBSD.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.OpenBSD_gencgc
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.OpenBSD_gencgc.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.alpha_linux
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.alpha_linux.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.alpha_osf1
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.alpha_osf1.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.hp700_ux90
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.hp700_ux90.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.linux
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.linux.
+++ /home/matt/src/nightshade-0.0+/src/lisp/lisp.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/lisp.c.
+++++++++++++++
	    core = *++argptr;
	    if (core == NULL)
	      {
		fprintf(stderr, "-core must be followed by the name of the core file to use.\n");
		exit(1);
---------------
            core = *++argptr;
            if (core == NULL)
	      {
		fprintf(stderr, "-core must be followed by the name of the core file to use.\n");
                exit(1);
+++++++++++++++
	    char *str = *++argptr;
            if (str == NULL)
	      {
		fprintf(stderr, "-dynamic-space-size must be followed by the size to use in MBytes.\n");
		exit(1);
---------------
            char *str = *++argptr;
            if (str == NULL)
	      {
                fprintf(stderr, "-dynamic-space-size must be followed by the size to use in MBytes.\n");
                exit(1);
+++++++++++++++
		fprintf(stderr, "-dynamic-space-size must be no greater than %d MBytes.\n",
			DYNAMIC_SPACE_SIZE / (1024 * 1024));
		exit(1);
---------------
                fprintf(stderr, "-dynamic-space-size must be no greater than %d MBytes.\n",
			DYNAMIC_SPACE_SIZE / (1024 * 1024));
                exit(1);
+++++++++++++++
		  }
---------------
		}
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.parisc_mach
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.parisc_mach.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.pmax_mach
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.pmax_mach.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.sgi_52
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.sgi_52.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.sun4_mach
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.sun4_mach.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.sun4_solaris_gcc
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.sun4_solaris_gcc.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.sun4_solaris_sunc
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.sun4_solaris_sunc.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.sun4c_41
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.sun4c_41.
+++ /home/matt/src/nightshade-0.0+/src/lisp/FreeBSD-os.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/FreeBSD-os.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/FreeBSD-os.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/FreeBSD-os.h.
lisp.c.BAK only present in :src/nightshade-0.0+/src/lisp/.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Linux-os.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Linux-os.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Linux-os.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Linux-os.h.
+++++++++++++++
// FIX next two lines from pd-cmucl-clean (ie 2006 cvs)
#include <fpu_control.h>
#define setfpucw(cw) {fpu_control_t cw_tmp=cw;_FPU_SETCW(cw_tmp);} 
//#define setfpucw(cw)	asm("fldcw %0" : : "m" (cw))

---------------
#define setfpucw(cw)	asm("fldcw %0" : : "m" (cw))

+++ /home/matt/src/nightshade-0.0+/src/lisp/NetBSD-os.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/NetBSD-os.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/NetBSD-os.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/NetBSD-os.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/OpenBSD-os.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/OpenBSD-os.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/OpenBSD-os.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/OpenBSD-os.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/WARNING.files
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/WARNING.files.
+++ /home/matt/src/nightshade-0.0+/src/lisp/alloc.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/alloc.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/alloc.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/alloc.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/alpha-arch.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/alpha-arch.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/alpha-assem.S
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/alpha-assem.S.
+++ /home/matt/src/nightshade-0.0+/src/lisp/alpha-lispregs.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/alpha-lispregs.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/alpha-nm
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/alpha-nm.
+++ /home/matt/src/nightshade-0.0+/src/lisp/alpha-validate.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/alpha-validate.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/arch.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/arch.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/backtrace.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/backtrace.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/breakpoint.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/breakpoint.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/breakpoint.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/breakpoint.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/cgc.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/cgc.c.
+++++++++++++++
/* cgc.c -*- Mode: C -*-
---------------
/* cgc.c -*- Mode: C; comment-column: 40; -*-
+++ /home/matt/src/nightshade-0.0+/src/lisp/cgc.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/cgc.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/core.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/core.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/coreparse.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/coreparse.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/dynbind.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/dynbind.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/dynbind.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/dynbind.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/gc.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/gc.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/gc.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/gc.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/gencgc.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/gencgc.c.
+++++++++++++++
// FIX  (FIX assumes #define LISPOBJ(thing) thing)
void *alien_nil = (void*) NIL;

// FIX
void* hack_ptr(void* obj) { return PTR((int)obj); }

// FIX
os_vm_prot_t os_vm_prot_read = OS_VM_PROT_READ;
os_vm_prot_t os_vm_prot_write = OS_VM_PROT_WRITE;
os_vm_prot_t os_vm_prot_execute = OS_VM_PROT_EXECUTE;
os_vm_prot_t os_vm_prot_all = OS_VM_PROT_ALL;

---------------
+++++++++++++++
//unsigned gencgc_verbose = 2;

---------------
+++++++++++++++
int from_space;
//static int from_space;
int new_space;
//static int new_space;

---------------
static int from_space;
static int new_space;

+++++++++++++++
//static void *heap_base = NULL;
void *heap_base = NULL;

---------------
static void *heap_base = NULL;

+++++++++++++++
//inline void *page_address(int page_num)
void *page_address(int page_num)
---------------
inline void *page_address(int page_num)
+++++++++++++++
//static struct generation generations[NUM_GENERATIONS + 1];
struct generation generations[NUM_GENERATIONS + 1];

---------------
static struct generation generations[NUM_GENERATIONS + 1];

+++++++++++++++
//static int  last_free_page;
int  last_free_page;

---------------
static int  last_free_page;


+++++++++++++++
   * they need to be saved and reset for C.
---------------
   * they need to the saved and reset for C.
+++++++++++++++
//static int  gc_alloc_generation;
int  gc_alloc_generation;

---------------
static int  gc_alloc_generation;

+++++++++++++++
//static int record_new_objects = 0;
int record_new_objects = 0;
//static int new_areas_ignore_page;
int new_areas_ignore_page;
---------------
static int record_new_objects = 0;
static int new_areas_ignore_page;
+++++++++++++++
//static struct new_area (*new_areas)[];
struct new_area (*new_areas)[];
//static int new_areas_index;
int new_areas_index;
int max_new_areas;

/* Add a new area to new_areas. */
//static void add_new_area(int first_page, int offset, int size)
void add_new_area(int first_page, int offset, int size)
---------------
static struct new_area (*new_areas)[];
static int new_areas_index;
int max_new_areas;

/* Add a new area to new_areas. */
static void add_new_area(int first_page, int offset, int size)
+++++++++++++++
 * When done the alloc_region is setup so that the next quick alloc
---------------
 * When done the alloc_region its setup so that the next quick alloc
+++++++++++++++
  // FIX
  //fprintf(stderr, "alloc_region: %x\n", alloc_region);

---------------
+++++++++++++++
int (*sizetab[256])(lispobj *where);
//static int (*sizetab[256])(lispobj *where);

struct weak_pointer *weak_pointers;
//static struct weak_pointer *weak_pointers;
struct scavenger_hook *scavenger_hooks = (struct scavenger_hook *) NIL;
//static struct scavenger_hook *scavenger_hooks = (struct scavenger_hook *) NIL;

---------------
static int (*sizetab[256])(lispobj *where);

static struct weak_pointer *weak_pointers;
static struct scavenger_hook *scavenger_hooks = (struct scavenger_hook *) NIL;

+++++++++++++++
     * to within the code area of the code object.
---------------
     * to within the code adea of the code object.
+++++++++++++++
//static int valid_dynamic_space_pointer(lispobj *pointer)
int valid_dynamic_space_pointer(lispobj *pointer)
---------------
static int valid_dynamic_space_pointer(lispobj *pointer)
+++++++++++++++
//static void unprotect_oldspace(void)
void unprotect_oldspace(void)
---------------
static void unprotect_oldspace(void)
+++++++++++++++
void verify_space(lispobj*start, size_t words)
//static void verify_space(lispobj*start, size_t words)
---------------
static void verify_space(lispobj*start, size_t words)
+++++++++++++++
// FIX
void verify_space1(int page, size_t words)
{
  verify_space(page_address(page), words);
}

---------------
+++++++++++++++
//static void verify_generation(int  generation)
void verify_generation(int  generation)
---------------
static void verify_generation(int  generation)
+++++++++++++++
#if 1
int verify_generation1(int i, int last_page, int region_unboxed, int generation)
{
//  int i;
//
//   for (i = 0; i < last_free_page; i++) {
//     if (PAGE_ALLOCATED(i)
// 	&& page_table[i].bytes_used != 0
// 	&& PAGE_GENERATION(i) == generation) {
//       int last_page;
//       int region_unboxed = PAGE_UNBOXED(i);

      /* This should be the start of a contiguous block */
      gc_assert(page_table[i].first_object_offset == 0);

      /*
       * Need to find the full extent of this contiguous block in case
       * objects span pages.
       */

      /*
       * Now work forward until the end of this contiguous area is
       * found.
       */
      for (last_page = i; ; last_page++)
	/* Check if this is the last page in this contiguous block */
	if (page_table[last_page].bytes_used < PAGE_SIZE
	    /* Or it is PAGE_SIZE and is the last in the block */
	    || !PAGE_ALLOCATED(last_page + 1)
	    || ((PAGE_UNBOXED(last_page + 1)) ? 1 : 0) != region_unboxed
	    || page_table[last_page + 1].bytes_used == 0
	    || PAGE_GENERATION(last_page + 1) != generation
	    || page_table[last_page + 1].first_object_offset == 0)
	  break;

         verify_space(page_address(i),
 		      (page_table[last_page].bytes_used +
 		      PAGE_SIZE * (last_page - i)) / 4);

	return last_page;

//       i = last_page;
//     }
//   }
}
#endif

---------------
+++++++++++++++
void os_protect1(int page, os_vm_size_t len, os_vm_prot_t protection)
{
  // page_start = (void *) page_address(i);
  os_protect(page_address(page), len, protection);
}

//void write_protect_generation_pages1(int i)
void write_protect_generation_pages1(void* page_start, int i)
{
//   int i;
// 
//   gc_assert(generation < NUM_GENERATIONS);
// 
//   for (i = 0; i < last_free_page; i++)
//     if (PAGE_ALLOCATED(i) && !PAGE_UNBOXED(i)
// 	&& page_table[i].bytes_used != 0
// 	&& PAGE_GENERATION(i) == generation)  {
//      void *page_start;

//      page_start = (void *) page_address(i);
	fprintf(stderr, "==== was .%x.\n", page_start);
	fprintf(stderr, "==== would have been .%x.\n", page_address(i));

      os_protect(page_start, PAGE_SIZE, OS_VM_PROT_READ | OS_VM_PROT_EXECUTE);

//       /* Note the page as protected in the page tables */
//       page_table[i].flags |= PAGE_WRITE_PROTECTED_MASK;
//     }
// 
//   if (gencgc_verbose > 1)
//     fprintf(stderr, "Write protected %d of %d pages in generation %d.\n",
// 	    count_write_protect_generation_pages(generation),
// 	    count_generation_pages(generation),
// 	    generation);
}

#if 1
---------------
+++++++++++++++
//static void write_protect_generation_pages(int generation)
void write_protect_generation_pages(int generation)
---------------
static void write_protect_generation_pages(int generation)
+++++++++++++++
#endif

---------------
+++++++++++++++
//static void	garbage_collect_generation(int generation, int raise)
void	garbage_collect_generation(int generation, int raise)
---------------
static void	garbage_collect_generation(int generation, int raise)
+++++++++++++++
// FIX used in save.c
---------------
+++++++++++++++
#if 1
void	collect_garbage2(unsigned last_gen, int gen, int raise)
{
  int i;

  int gen_to_wp;

#if 0
  int gen = 0;
  int raise;

#if 0 // FIX
  fprintf(stderr, "boxed_region: %x\n", &boxed_region);
  fprintf(stderr, "unboxed_region: %x\n", &unboxed_region);
#endif

---------------
/*
 * GC all generations below last_gen, raising their objects to the
 * next generation until all generations below last_gen are empty.
 * Then if last_gen is due for a GC then GC it. In the special case
 * that last_gen==NUM_GENERATIONS, the last generation is always
 * GC'ed. The valid range for last_gen is: 0,1,...,NUM_GENERATIONS.
 *
 * The oldest generation to be GCed will always be
 * gencgc_oldest_gen_to_gc, partly ignoring last_gen if necessary.
 */
void	collect_garbage(unsigned last_gen)
{
  int gen = 0;
  int raise;
  int gen_to_wp;
  int i;

+++++++++++++++
	     || (gen <= gencgc_oldest_gen_to_gc /* FIX just checked? */ && raise
		 && generations[gen].bytes_allocated > generations[gen].gc_trigger
		 && gen_av_mem_age(gen) > generations[gen].min_av_mem_age)));
#endif
---------------
	     || (gen <= gencgc_oldest_gen_to_gc && raise
		 && generations[gen].bytes_allocated > generations[gen].gc_trigger
		 && gen_av_mem_age(gen) > generations[gen].min_av_mem_age)));

+++++++++++++++
#endif

#if 0
//void	call_garbage_collect_generation(int gen, int raise)
void	call_garbage_collect_generation(unsigned last_gen, int gen, int raise)
{
    garbage_collect_generation(gen,raise);
}
#endif

#if 1
//void	collect_garbage1(unsigned last_gen)
void	collect_garbage1(unsigned last_gen, int gen, int raise)
{
#if 0
  int i;

  int gen_to_wp;

  int gen = 0;
  int raise;

  boxed_region.free_pointer = current_region_free_pointer;

  /* Check last_gen */
  if (last_gen > NUM_GENERATIONS) {
    fprintf(stderr, "** collect_garbage: last_gen = %d. Doing a level 0 GC.\n",
	    last_gen);
    last_gen = 0;
  }

  /* Flush the alloc regions updating the tables. */
  gc_alloc_update_page_tables(0,&boxed_region);
  gc_alloc_update_page_tables(1,&unboxed_region);

  /* Verify the new objects created by lisp code. */
  if (pre_verify_gen_0) {
    fprintf(stderr, "Pre-Checking generation 0\n");
    verify_generation(0);
  }

  if (gencgc_verbose > 1)
    print_generation_stats(0);

  scavenger_hooks = NIL;

  do {
    /* Collect the generation */

    /* Never raise the oldest generation. */
    if (gen >= gencgc_oldest_gen_to_gc)
      raise = 0;
    else 
      /* Raise if: gen < last_gen */
      if (gen < last_gen)
	raise = 1;
      else
	/* Only raise if the age is >= the trigger age. */
	if (generations[gen].num_gc >= generations[gen].trigger_age)
	  raise = 1;
	else
	  raise = 0;

    if (gencgc_verbose > 1)
      fprintf(stderr, "Starting GC of generation %d with raise=%d alloc=%d trig=%d GCs=%d\n",
	      gen,
	      raise,
	      generations[gen].bytes_allocated,
	      generations[gen].gc_trigger,
	      generations[gen].num_gc);

    /*
     * If an older generation is being filled then update its memory age.
     */
    if (raise == 1)
      generations[gen + 1].cum_sum_bytes_allocated += generations[gen + 1].bytes_allocated;
#endif
    garbage_collect_generation(gen,raise);

    /* Reset the memory age cum_sum */
    generations[gen].cum_sum_bytes_allocated = 0;

    if (gencgc_verbose > 1) {
      fprintf(stderr, "GC of generation %d finished:\n", gen);
      print_generation_stats(0);
    }
#if 0
    gen++;

  }
  while (gen <= gencgc_oldest_gen_to_gc
	 && (gen < last_gen
	     || (gen <= gencgc_oldest_gen_to_gc /* FIX just checked? */ && raise
		 && generations[gen].bytes_allocated > generations[gen].gc_trigger
		 && gen_av_mem_age(gen) > generations[gen].min_av_mem_age)));

  /*
   * Now if gen-1 was raised all generations before gen are empty.If
   * it wasn't raised then all generations before gen-1 are empty.
   *
   * Now objects within this gen's pages cannot pointer to younger
   * generations unless they are written to. This can be exploited by
   * write protecting the pages of gen; then when younger generations
   * are GCed only the page written need scanning.
   */
  if (raise)
    gen_to_wp = gen;
  else
    gen_to_wp = gen - 1;

  /*
   * Not much point in WPing pages in generation 0 as it is never
   * scavenged (except promoted pages).
   */
  if (gen_to_wp > 0 && enable_page_protection) {
    /* Check that they are all empty */
    for (i = 0; i < gen_to_wp; i++)
      if (generations[i].bytes_allocated != 0)
	fprintf(stderr, "*** trying to write prot. gen. %d when gen. %d is not empty\n",
		gen_to_wp, i);

    write_protect_generation_pages(gen_to_wp);
  }

  /*
   * Set gc_alloc back to generation 0. The current regions should be
   * flushed after the above GCs.
   */
  gc_assert(boxed_region.free_pointer - boxed_region.start_addr == 0);
  gc_alloc_generation = 0;

  update_x86_dynamic_space_free_pointer();

  current_region_free_pointer = boxed_region.free_pointer;
  current_region_end_addr = boxed_region.end_addr;

  /* Call the scavenger hook functions */
  {
    struct scavenger_hook *sh;
    for (sh = (struct scavenger_hook *) PTR((int) scavenger_hooks);
	 sh != (struct scavenger_hook *) PTR(NIL);) {
      struct scavenger_hook *sh_next = (struct scavenger_hook *) PTR((int) sh->next);
#if 0
      fprintf(stderr, "Scav hook %x; next %x; calling scav hook fn %x\n",
	      sh, sh_next, sh->function);
#endif
      funcall0(sh->function);
      sh->next = NULL;
      sh = sh_next;
    }
    scavenger_hooks = (struct scavenger_hook *) NIL;
  }
#endif
}
#endif

void	call_gc_alloc_update_page_tables()
{
  gc_alloc_update_page_tables(0,&boxed_region);
  gc_alloc_update_page_tables(1,&unboxed_region);
}

#if 1
/*
 * GC all generations below last_gen, raising their objects to the
 * next generation until all generations below last_gen are empty.
 * Then if last_gen is due for a GC then GC it. In the special case
 * that last_gen==NUM_GENERATIONS, the last generation is always
 * GC'ed. The valid range for last_gen is: 0,1,...,NUM_GENERATIONS.
 *
 * The oldest generation to be GCed will always be
 * gencgc_oldest_gen_to_gc, partly ignoring last_gen if necessary.
 */
void	collect_garbage(unsigned last_gen)
{
  int i;

  int gen_to_wp;
  int gen = 0;
  int raise;

  boxed_region.free_pointer = current_region_free_pointer;

  /* Check last_gen */
  if (last_gen > NUM_GENERATIONS) {
    fprintf(stderr, "** collect_garbage: last_gen = %d. Doing a level 0 GC.\n",
	    last_gen);
    last_gen = 0;
  }

  /* Flush the alloc regions updating the tables. */
  gc_alloc_update_page_tables(0,&boxed_region);
  gc_alloc_update_page_tables(1,&unboxed_region);

  /* Verify the new objects created by lisp code. */
  if (pre_verify_gen_0) {
    fprintf(stderr, "Pre-Checking generation 0\n");
    verify_generation(0);
---------------
/*
 * The is called by purify when it is finished. All live objects will
 * have been moved to the RO and Static heaps. The dynamic space will
 * need a full re-initialisation. Do not bother having purify flush
 * the current allocation region, as the page_tables are re-initialised,
 * and every page is zeroed to be sure.
 */

void	gc_free_heap(void)
{
  int page;

  if (gencgc_verbose > 1)
    fprintf(stderr, "Free heap\n");

  for (page = 0; page < dynamic_space_pages; page++)
    /* Skip Free pages which should already be zero filled. */
    if (PAGE_ALLOCATED(page)) {
      void *page_start, *addr;

      /*
       * Mark the page free. The other slots are assumed invalid when
       * it is unallocated and bytes_used is 0 and it should not be
       * write protected - except that the generation is used for the
       * current region but it sets that up.
       */
      page_table[page].flags &= ~PAGE_ALLOCATED_MASK;
      page_table[page].bytes_used = 0;

      /* Zero the page. */
      page_start = (void *) page_address(page);

      /* First remove any write protection */
      os_protect(page_start, PAGE_SIZE, OS_VM_PROT_ALL);
      page_table[page].flags &= ~PAGE_WRITE_PROTECTED_MASK;

      os_invalidate(page_start, PAGE_SIZE);
      addr = os_validate(page_start, PAGE_SIZE);
      if(addr == NULL || addr != page_start)
	fprintf(stderr, "gc_zero: page moved, 0x%08x ==> 0x%08x!\n",
		page_start, addr);
    } else if (gencgc_zero_check_during_free_heap && page < 16384) {
      int *page_start;
      unsigned i;

      /* Double check that the page is zero filled. */
      gc_assert(!PAGE_ALLOCATED(page));
      gc_assert(page_table[page].bytes_used == 0);

      page_start = (int *) page_address(page);

      for(i = 0; i < 1024; i++)
	if (page_start[i] != 0)
	  fprintf(stderr, "** Free region not zero @ %x\n", page_start + i);
    }

  bytes_allocated = 0;

  /* Initialise the generations. */
  for (page = 0; page < NUM_GENERATIONS; page++) {
    generations[page].alloc_start_page = 0;
    generations[page].alloc_unboxed_start_page = 0;
    generations[page].alloc_large_start_page = 0;
    generations[page].alloc_large_unboxed_start_page = 0;
    generations[page].bytes_allocated = 0;
    generations[page].gc_trigger = 2000000;
    generations[page].num_gc = 0;
    generations[page].cum_sum_bytes_allocated = 0;
+++++++++++++++
  scavenger_hooks = NIL;

  do {
    /* Collect the generation */

    /* Never raise the oldest generation. */
    if (gen >= gencgc_oldest_gen_to_gc)
      raise = 0;
    else 
      /* Raise if: gen < last_gen */
      if (gen < last_gen)
	raise = 1;
      else
	/* Only raise if the age is >= the trigger age. */
	if (generations[gen].num_gc >= generations[gen].trigger_age)
	  raise = 1;
	else
	  raise = 0;

    if (gencgc_verbose > 1)
      fprintf(stderr, "Starting GC of generation %d with raise=%d alloc=%d trig=%d GCs=%d\n",
	      gen,
	      raise,
	      generations[gen].bytes_allocated,
	      generations[gen].gc_trigger,
	      generations[gen].num_gc);

    /*
     * If an older generation is being filled then update its memory age.
     */
    if (raise == 1)
      generations[gen + 1].cum_sum_bytes_allocated += generations[gen + 1].bytes_allocated;

    garbage_collect_generation(gen,raise);

    /* Reset the memory age cum_sum */
    generations[gen].cum_sum_bytes_allocated = 0;

    if (gencgc_verbose > 1) {
      fprintf(stderr, "GC of generation %d finished:\n", gen);
      print_generation_stats(0);
    }

    gen++;
  }
  while (gen <= gencgc_oldest_gen_to_gc
	 && (gen < last_gen
	     || (gen <= gencgc_oldest_gen_to_gc /* FIX just checked? */ && raise
		 && generations[gen].bytes_allocated > generations[gen].gc_trigger
		 && gen_av_mem_age(gen) > generations[gen].min_av_mem_age)));

  /*
   * Now if gen-1 was raised all generations before gen are empty.If
   * it wasn't raised then all generations before gen-1 are empty.
   *
   * Now objects within this gen's pages cannot pointer to younger
   * generations unless they are written to. This can be exploited by
   * write protecting the pages of gen; then when younger generations
   * are GCed only the page written need scanning.
   */
  if (raise)
    gen_to_wp = gen;
  else
    gen_to_wp = gen - 1;

  /*
   * Not much point in WPing pages in generation 0 as it is never
   * scavenged (except promoted pages).
   */
  if (gen_to_wp > 0 && enable_page_protection) {
    /* Check that they are all empty */
    for (i = 0; i < gen_to_wp; i++)
      if (generations[i].bytes_allocated != 0)
	fprintf(stderr, "*** trying to write prot. gen. %d when gen. %d is not empty\n",
		gen_to_wp, i);

    write_protect_generation_pages(gen_to_wp);
  }

  /*
   * Set gc_alloc back to generation 0. The current regions should be
   * flushed after the above GCs.
   */
  gc_assert(boxed_region.free_pointer - boxed_region.start_addr == 0);
  gc_alloc_generation = 0;

  update_x86_dynamic_space_free_pointer();

  current_region_free_pointer = boxed_region.free_pointer;
  current_region_end_addr = boxed_region.end_addr;

  /* Call the scavenger hook functions */
  {
    struct scavenger_hook *sh;
    for (sh = (struct scavenger_hook *) PTR((int) scavenger_hooks);
	 sh != (struct scavenger_hook *) PTR(NIL);) {
      struct scavenger_hook *sh_next = (struct scavenger_hook *) PTR((int) sh->next);
#if 0
      fprintf(stderr, "Scav hook %x; next %x; calling scav hook fn %x\n",
	      sh, sh_next, sh->function);
#endif
      funcall0(sh->function);
      sh->next = NULL;
      sh = sh_next;
    }
    scavenger_hooks = (struct scavenger_hook *) NIL;
  }

}
#endif


/*
 * The is called by purify when it is finished. All live objects will
 * have been moved to the RO and Static heaps. The dynamic space will
 * need a full re-initialisation. Do not bother having purify flush
 * the current allocation region, as the page_tables are re-initialised,
 * and every page is zeroed to be sure.
 */

void	gc_free_heap(void)
{
  int page;

  if (gencgc_verbose > 1)
    fprintf(stderr, "Free heap\n");

  for (page = 0; page < dynamic_space_pages; page++)
    /* Skip Free pages which should already be zero filled. */
    if (PAGE_ALLOCATED(page)) {
      void *page_start, *addr;

      /*
       * Mark the page free. The other slots are assumed invalid when
       * it is unallocated and bytes_used is 0 and it should not be
       * write protected - except that the generation is used for the
       * current region but it sets that up.
       */
      page_table[page].flags &= ~PAGE_ALLOCATED_MASK;
      page_table[page].bytes_used = 0;

      /* Zero the page. */
      page_start = (void *) page_address(page);

      /* First remove any write protection */
      os_protect(page_start, PAGE_SIZE, OS_VM_PROT_ALL);
      page_table[page].flags &= ~PAGE_WRITE_PROTECTED_MASK;

      os_invalidate(page_start, PAGE_SIZE);
      addr = os_validate(page_start, PAGE_SIZE);
      if(addr == NULL || addr != page_start)
	fprintf(stderr, "gc_zero: page moved, 0x%08x ==> 0x%08x!\n",
		page_start, addr);
    } else if (gencgc_zero_check_during_free_heap && page < 16384) {
      int *page_start;
      unsigned i;

      /* Double check that the page is zero filled. */
      gc_assert(!PAGE_ALLOCATED(page));
      gc_assert(page_table[page].bytes_used == 0);

      page_start = (int *) page_address(page);

      for(i = 0; i < 1024; i++)
	if (page_start[i] != 0)
	  fprintf(stderr, "** Free region not zero @ %x\n", page_start + i);
    }

  bytes_allocated = 0;

  /* Initialise the generations. */
  for (page = 0; page < NUM_GENERATIONS; page++) {
    generations[page].alloc_start_page = 0;
    generations[page].alloc_unboxed_start_page = 0;
    generations[page].alloc_large_start_page = 0;
    generations[page].alloc_large_unboxed_start_page = 0;
    generations[page].bytes_allocated = 0;
    generations[page].gc_trigger = 2000000;
    generations[page].num_gc = 0;
    generations[page].cum_sum_bytes_allocated = 0;
  }

  if (gencgc_verbose > 1)
    print_generation_stats(0);

---------------
+++++++++++++++
 * filled. E.g. the most significant word of a 2 word bignum in
 * move-from-unsigned.
 *
 * The check for a GC trigger is only performed when the current
 * region is full, so in most cases it's not needed.  Further maybe-gc
---------------
 * filled. E.g. the MS word of a 2 word bignum in move-from-unsigned.
 *
 * The check for a GC trigger is only performed when the current
 * region is full, so in most cases it's not needed. Further maybe-gc
+++ /home/matt/src/nightshade-0.0+/src/lisp/gencgc.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/gencgc.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/globals.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/globals.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/globals.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/globals.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/hppa-arch.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/hppa-arch.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/hppa-assem.S
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/hppa-assem.S.
+++ /home/matt/src/nightshade-0.0+/src/lisp/hppa-assem.s
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/hppa-assem.s.
+++ /home/matt/src/nightshade-0.0+/src/lisp/hppa-lispregs.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/hppa-lispregs.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/hppa-validate.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/hppa-validate.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/hpux-nm
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/hpux-nm.
+++ /home/matt/src/nightshade-0.0+/src/lisp/hpux-os.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/hpux-os.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/hpux-os.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/hpux-os.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/interr.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/interr.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/interr.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/interr.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/interrupt.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/interrupt.c.
+++++++++++++++
/* Interrupt handling magic. */

---------------
/* Interrupt handing magic. */

+++ /home/matt/src/nightshade-0.0+/src/lisp/interrupt.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/interrupt.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/irix-asm-munge.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/irix-asm-munge.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/irix-nm
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/irix-nm.
+++ /home/matt/src/nightshade-0.0+/src/lisp/irix-os.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/irix-os.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/irix-os.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/irix-os.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/linux-nm
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/linux-nm.
+++ /home/matt/src/nightshade-0.0+/src/lisp/linux-stubs.S
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/linux-stubs.S.
+++++++++++++++
 doe(gmtime_r)
---------------
+++++++++++++++
 doe(localtime_r)
---------------
+++++++++++++++
---------------
/*  doe(gmtime_r) */
+++++++++++++++
---------------
/*  doe(localtime_r) */
+++ /home/matt/src/nightshade-0.0+/src/lisp/lisp.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/lisp.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/lispregs.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/lispregs.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/mach-os.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/mach-os.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/mach-os.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/mach-os.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/mips-arch.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/mips-arch.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/mips-assem.S
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/mips-assem.S.
+++ /home/matt/src/nightshade-0.0+/src/lisp/mips-lispregs.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/mips-lispregs.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/mips-validate.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/mips-validate.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/monitor.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/monitor.c.
+++++++++++++++
#if 0
#include "gc.h"
#endif
#include "search.h"
#include "purify.h"
#if 0
---------------
#include "gc.h"
#include "search.h"
#include "purify.h"
+++++++++++++++
#endif

---------------
+++++++++++++++
static cmd /* gc_cmd, */ print_context_cmd;
---------------
static cmd gc_cmd, print_context_cmd;
+++++++++++++++
    /* {"gc", "collect garbage (caveat collector).", gc_cmd}, */
---------------
    {"gc", "collect garbage (caveat collector).", gc_cmd},
+++++++++++++++
#if 0
---------------
+++++++++++++++
#endif

---------------
+++ /home/matt/src/nightshade-0.0+/src/lisp/monitor.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/monitor.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/os-common.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/os-common.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/os.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/os.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/osf1-os.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/osf1-os.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/osf1-os.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/osf1-os.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/parse.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/parse.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/parse.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/parse.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/print.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/print.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/print.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/print.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/purify.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/purify.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/purify.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/purify.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/regnames.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/regnames.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/undefineds.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/undefineds.h.
+++++++++++++++
F(gmtime_r)
---------------
+++++++++++++++
F(localtime_r)
---------------
+++ /home/matt/src/nightshade-0.0+/src/lisp/save.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/save.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/save.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/save.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/search.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/search.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/search.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/search.h.
#lisp.c# only present in :src/nightshade-0.0+/src/lisp/.
+++ /home/matt/src/nightshade-0.0+/src/lisp/solaris-nm
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/solaris-nm.
+++ /home/matt/src/nightshade-0.0+/src/lisp/solaris-os.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/solaris-os.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/sparc-arch.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/sparc-arch.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/sparc-assem.S
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/sparc-assem.S.
+++ /home/matt/src/nightshade-0.0+/src/lisp/sparc-lispregs.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/sparc-lispregs.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/sparc-validate.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/sparc-validate.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/sunos-os.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/sunos-os.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/sunos-os.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/sunos-os.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/undefineds.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/undefineds.c.
cgc.c.BAK only present in :src/nightshade-0.0+/src/lisp/.
+++ /home/matt/src/nightshade-0.0+/src/lisp/validate.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/validate.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/validate.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/validate.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/vars.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/vars.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/vars.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/vars.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/version.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/version.c.
+++ /home/matt/src/nightshade-0.0+/src/lisp/x86-arch.c
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/x86-arch.c.
+++++++++++++++
 * it. Skip the code, then if the code is an error-trap or
---------------
 * it. Skip the code, then if the code if an error-trap or
+++++++++++++++
// FIX
//	((char*) context->sc_pc)++;
	context->sc_pc++;
---------------
	((char*) context->sc_pc)++;
+++++++++++++++
// FIX
//      (char*) context->sc_pc -= 1;
      context->sc_pc -= 1;
---------------
      (char*) context->sc_pc -= 1;
+++++++++++++++
// FIX
//      (char*) context->sc_pc -= 1;
      context->sc_pc -= 1;
---------------
      (char*) context->sc_pc -= 1;
+++ /home/matt/src/nightshade-0.0+/src/lisp/x86-assem.S
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/x86-assem.S.
+++ /home/matt/src/nightshade-0.0+/src/lisp/x86-lispregs.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/x86-lispregs.h.
+++ /home/matt/src/nightshade-0.0+/src/lisp/x86-validate.h
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/x86-validate.h.
lisp.map only present in :src/nightshade-0.0+/src/lisp/.
cgc.c.CKP only present in :src/nightshade-0.0+/src/lisp/.
internals.h only present in :src/nightshade-0.0+/src/lisp/.
Config.linux_gencgc.orig only present in :src/nightshade-0.0+/src/lisp/.
Config.linux_gencgc.BAK only present in :src/nightshade-0.0+/src/lisp/.
Linux-os.h.BAK only present in :src/nightshade-0.0+/src/lisp/.
x86-arch.c.BAK only present in :src/nightshade-0.0+/src/lisp/.
version only present in :src/nightshade-0.0+/src/lisp/.
+++ /home/matt/src/nightshade-0.0+/src/lisp/GNUmakefile
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/GNUmakefile.
+++++++++++++++
---------------
	socket.c runprog.c time.c \
+++++++++++++++
	$(CC) -MM -E ${DEPEND_FLAGS} ${CFLAGS} ${CPPFLAGS} $^ > ,depends
---------------
	$(CC) -MM -E ${DEPEND_FLAGS} ${CFLAGS} ${CPPFLAGS} $? > ,depends
interrupt.c.BAK only present in :src/nightshade-0.0+/src/lisp/.
gencgc.c.BAK only present in :src/nightshade-0.0+/src/lisp/.
GNUmakefile.BAK only present in :src/nightshade-0.0+/src/lisp/.
undefineds.h.BAK only present in :src/nightshade-0.0+/src/lisp/.
Config.linux_gc only present in :src/nightshade-0.0+/src/lisp/.
linux-stubs.S.BAK only present in :src/nightshade-0.0+/src/lisp/.
monitor.c.BAK only present in :src/nightshade-0.0+/src/lisp/.
Config.linux_gc.BAK only present in :src/nightshade-0.0+/src/lisp/.
gencgc.c.pre-static-test.bak only present in :src/nightshade-0.0+/src/lisp/.
gencgc.c.static-test.bak only present in :src/nightshade-0.0+/src/lisp/.
+++ /home/matt/src/nightshade-0.0+/src/lisp/Config.linux_gencgc
--- :src/cmucl-2002-08-23-19h00-clean/src/lisp/Config.linux_gencgc.
+++++++++++++++
CPPFLAGS = -D__NO_CTYPE -I. -I$(PATH2) -I$(PATH1) -I- -I/usr/X11R6/include
---------------
CPPFLAGS = -I. -I$(PATH2) -I$(PATH1) -I- -I/usr/X11R6/include
gencgc.h.BAK only present in :src/nightshade-0.0+/src/lisp/.
purify.c.BAK only present in :src/nightshade-0.0+/src/lisp/.
