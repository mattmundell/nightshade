;;; nightshade/src/code/filesys.lisp.orig (ie 0.0+)  vs  cmucl-2002-08-23-19h00-clean/src/code/filesys.lisp
;;; ie additions made for 0.0+ to the cmucl cvs base of 0.0+
Comparison of filesys-G142 and filesys-G143.

**** Buffer filesys-G142:
          rename-file delete-file file-write-date file-author
	  file-mode))

(use-package "EXTENSIONS")

(in-package "EXTENSIONS")
(export '(print-directory print-files complete-file ambiguous-files
	  default-directory file-writable unix-namestring
	  map-files list-files))
**** Buffer filesys-G143:
          rename-file delete-file file-write-date file-author))

(use-package "EXTENSIONS")

(in-package "EXTENSIONS")
(export '(print-directory complete-file ambiguous-files default-directory
			  file-writable unix-namestring))
***************

**** Buffer filesys-G142:
;;;; Wildcard matching.

**** Buffer filesys-G143:
;;;; Wildcard matching stuff.

***************

**** Buffer filesys-G142:
      (enumerate-matches (name pathname nil
			       :verify-existance for-input
**** Buffer filesys-G143:
      (enumerate-matches (name pathname nil :verify-existance for-input
***************

**** Buffer filesys-G142:
      (error 'simple-file-error
**** Buffer filesys-G143:
      (error 'simple-file-error
***************

**** Buffer filesys-G142:
**** Buffer filesys-G143:
;;;    Delete the file, Man.
;;;
***************

**** Buffer filesys-G142:
  "Return file's creation (FIX modified?) date in universal format, or NIL
   if it doesn't exist.  An error of type file-error is signaled if file is
   a wild pathname"
  (if (wild-pathname-p file)
      (error 'simple-file-error
**** Buffer filesys-G143:
  "Return file's creation date, or NIL if it doesn't exist.
 An error of type file-error is signaled if file is a wild pathname"
  (if (wild-pathname-p file)
      (error 'simple-file-error
***************

**** Buffer filesys-G142:
;;; File-Mode  --  Public
;;;
(defun file-mode (file)
  "Returns the file mode, or nil on failure.  Signals an error of type
   file-error if file doesn't exist, or file is a wild pathname."
  (if (wild-pathname-p file)
      (error 'simple-file-error
	     :pathname file
	     "Bad place for a wild pathname.")
      (let ((name (unix-namestring (pathname file) t)))
	(unless name
	  (error 'simple-file-error
		 :pathname file
		 :format-control "~S doesn't exist."
		 :format-arguments (list file)))
	(multiple-value-bind (res dev ino mode)
			     (unix:unix-stat name)
	  (declare (ignore dev ino))
	  (if res mode)))))


;;;; DIRECTORY.

;;; ENUMERATE-NAMES  --  internal.
;;;
(defun enumerate-names (pathname &optional all follow-links backups recurse)
  "Returns a list of pathnames for Pathname." ;; FIX options
  (let ((results nil))
    (enumerate-search-list
     (pathname (merge-pathnames pathname
				(make-pathname :name :wild
					       :type :wild
					       :version :wild)))
     (enumerate-matches (name pathname nil :follow-links follow-links)
	(when (and (or backups
		       (if (or (char= (schar name (1- (length name))) #\~)
 			       (string= (pathname-type name) "BAK")
 			       (string= (pathname-type name) "CKP"))
			   nil
			   t))
		   (or all
		       (let ((slash (position #\/ name :from-end t)))
			 (or (null slash)
			     (= (1+ slash) (length name))
			     (char/= (schar name (1+ slash)) #\.)))))
	  (push name results))))
    (when recurse
      (dolist (name results)
	(when (eq (unix:unix-file-kind name) :directory)
	  (setq results
		(append results
			(enumerate-names (concatenate 'string name "/")
					 all follow-links backups t))))))
    results))
; (defun enumerate-names (pathname &optional all follow-links backups recurse &key test)
;   "Returns a list of pathnames for Pathname." ;; FIX options
;   (let ((results nil))
;     (enumerate-search-list
;      (pathname (merge-pathnames pathname
; 				(make-pathname :name :wild
; 					       :type :wild
; 					       :version :wild)))
;      (enumerate-matches (name pathname nil :follow-links follow-links)
; 	(when (and (or backups
; 		       (char/= (schar name (1- (length name))) #\~))
; 		   (or all
; 		       (let ((slash (position #\/ name :from-end t)))
; 			 (or (null slash)
; 			     (= (1+ slash) (length name))
; 			     (char/= (schar name (1+ slash)) #\.))))
; 		   ;; FIX speed?
; 		   (if test (funcall test name) t))
; 	  (push name results))))
;     (when recurse
;       (dolist (name results)
; 	(when (eq (unix:unix-file-kind name) :directory)
; 	  (setq results
; 		(append results
; 			(enumerate-names (concatenate 'string name "/")
; 					 all follow-links backups t :test test))))))
;     results))

(defun map-files (pathname function
		  &key (all t) follow-links (backups t) recurse)
  "Call Function on each file and directory in Pathname.
   Keys:
      all           if true include hidden files (files starting with a .)
      follow-links  if true follow symbolic links
      backups       if true include backup files (files ending in: ~ BAK CKP)
      recurse       if true recurse into subdirectories."
  (enumerate-search-list
   (pathname (merge-pathnames (directory-namestring pathname)
			      (make-pathname :name :wild
					     :type :wild
					     :version :wild)))
   (enumerate-matches (name pathname nil :follow-links follow-links)
     (when (and (or backups
		    (if (or (char= (schar name (1- (length name))) #\~)
			    (string= (pathname-type name) "BAK")
			    (string= (pathname-type name) "CKP"))
			nil
			t))
		(or all
		    (let ((slash (position #\/ name :from-end t)))
		      (or (null slash)
			  (= (1+ slash) (length name))
			  (if (char= (schar name (1+ slash)) #\.) nil t)))))
       (funcall function name))
     (if (and recurse (eq (unix:unix-file-kind name) :directory))
	 (map-files (concatenate 'string name "/") function
		    :all all :follow-links follow-links
		    :backups backups :recurse t)))))

(defun list-files (pathname &optional (predicate #'identity)
			    &key (all t) follow-links (backups t) recurse)
  "Return a list of all files and directories in Pathname that match Predicate.
   Keys:
      all           if true include hidden files (files starting with a .)
      follow-links  if true follow symbolic links
      backups       if true include backup files (files ending in a ~)
      recurse       if true recurse into subdirectories.
   Predicate is called on the file name."
  (let ((results ()))
    (enumerate-search-list
     (pathname (merge-pathnames (directory-namestring pathname)
				(make-pathname :name :wild
					       :type :wild
					       :version :wild)))
     (enumerate-matches (name pathname nil :follow-links follow-links)
	(when (and (or backups
		       (if (or (char= (schar name (1- (length name))) #\~)
			       (string= (pathname-type name) "BAK")
			       (string= (pathname-type name) "CKP"))
			   nil
			   t))
		   (or all
		       (let ((slash (position #\/ name :from-end t)))
			 (or (null slash)
			     (= (1+ slash) (length name))
			     (if (char= (schar name (1+ slash)) #\.) nil t))))
		   (funcall predicate name))
	  (push name results))
	(if (and recurse (eq (unix:unix-file-kind name) :directory))
	    (let ((files (list-files (concatenate 'string name "/") predicate
				     :all all :follow-links follow-links
				     :backups backups :recurse t)))
	      (if files
		  (setq results (append files results)))))))
    results))

;;; DIRECTORY  --  public.
;;;
(defun directory (pathname &key (all t) (check-for-subdirs t)
			   (truenamep t) (follow-links t) (backups t)
			   (recurse nil))
**** Buffer filesys-G143:

;;;; DIRECTORY.

;;; DIRECTORY  --  public.
;;;
(defun directory (pathname &key (all t) (check-for-subdirs t)
			   (truenamep t) (follow-links t))
***************

**** Buffer filesys-G142:
   not followed.  If BACKUPS is true then backup files (files ending in ~) are
   also listed.  If RECURSE is true then pathnames of subdirectories are included,
   recursively."
  (let ((*ignore-wildcards* t))
    (mapcar #'(lambda (name)
		(let ((name (if (and check-for-subdirs
				     (eq (unix:unix-file-kind name)
					 :directory))
				(concatenate 'string name "/")
				name)))
		  (if truenamep (truename name) (pathname name))))
	    (sort (delete-duplicates (enumerate-names pathname
						      all follow-links
						      backups recurse)
				     :test #'string=) #'string<))))

**** Buffer filesys-G143:
   not followed."
  (let ((results nil))
    (enumerate-search-list
	(pathname (merge-pathnames pathname
				   (make-pathname :name :wild
						  :type :wild
						  :version :wild)))
      (enumerate-matches (name pathname nil :follow-links follow-links)
	(when (or all
		  (let ((slash (position #\/ name :from-end t)))
		    (or (null slash)
			(= (1+ slash) (length name))
			(char/= (schar name (1+ slash)) #\.))))
	  (push name results))))
    (let ((*ignore-wildcards* t))
      (mapcar #'(lambda (name)
		  (let ((name (if (and check-for-subdirs
				       (eq (unix:unix-file-kind name)
					   :directory))
				  (concatenate 'string name "/")
				  name)))
		    (if truenamep (truename name) (pathname name))))
	      (sort (delete-duplicates results :test #'string=) #'string<)))))

***************

**** Buffer filesys-G142:
;;;
(defun print-directory (pathname &optional stream &key all verbose return-list
				 (backups t) (recurse nil) coldefs)
  "Like Directory, but prints a terse, multi-coloumn directory listing
   instead of returning a list of pathnames.  When :all is supplied and
   non-nil, then Unix dot files are included too (as ls -a).  When :verbose
   is supplied and non-nil, then a long listing of miscellaneous
   information is output one file per line.  When :backups is supplied and
   true then backup files (files ending in ~) are included.  If :coldefs is
   nil outputs in the usual column format, otherwise outputs in the column
   format described by :coldefs."
  (let ((*standard-output* (out-synonym-of stream))
	(pathname pathname)
	(contents (directory pathname
			     :all all :check-for-subdirs (if verbose nil t)
			     :truenamep nil :backups backups :recurse recurse)))
    (if verbose
	(print-directory-verbose pathname contents all return-list coldefs)
	(print-directory-formatted pathname contents all return-list))))

;;; PRINT-FILES is exported from the EXTENSIONS package.
;;;
(defun print-files (files &optional stream &key verbose return-list coldefs)
  "Print the list of files FILES like Print-Directory prints a pathname.
   FILES may be a list of lists, where the first element is the file name
   and the rest is extra information (typically used by a column
   definition)."
  (let ((*standard-output* (out-synonym-of stream))
 	(pathname "/"))  ;; FIX maybe find longest common path
    (if verbose
	(print-directory-verbose pathname files nil return-list coldefs)
	(print-directory-formatted pathname files nil return-list return-list))))

;;; PRINT-MODE is internal.
;;;
(defun print-mode (mode)
  (macrolet ((frob (bit name &optional sbit sname negate)
	       `(if ,(if negate
			 `(not (logbitp ,bit mode))
			 `(logbitp ,bit mode))
		    ,(if sbit
			 `(if (logbitp ,sbit mode)
			      (write-char ,sname)
			      (write-char ,name))
			 `(write-char ,name))
		    (write-char #\-))))
    (frob 15 #\d nil nil t)
    (frob 8 #\r)
    (frob 7 #\w)
    (frob 6 #\x 11 #\s)
    (frob 5 #\r)
    (frob 4 #\w)
    (frob 3 #\x 10 #\s)
    (frob 2 #\r)
    (frob 1 #\w)
    (frob 0 #\x)))

(defun print-directory-verbose (pathname contents all return-list coldefs)
  (declare (ignore all)) ;; FIX is all for something?
  (let ((result nil)
	(dir-len (1+ (or (position #\/ (unix-namestring pathname)
				   :from-end t
				   :end (length (unix-namestring pathname))
				   :test #'char=)
			 -1))))
    (format t "v Directory of ~A :~%" (namestring pathname))
    (if coldefs
	;;; Print according to column definitions.
	(if (listp coldefs)
	    (dolist (file-or-more contents)
	      (let* ((file (if (listp file-or-more)
			       (car file-or-more)
			       file-or-more))
		     (namestring (unix-namestring file))
		     (tail (subseq namestring dir-len)))
		(multiple-value-bind
		    (reslt dev-or-err ino mode nlink uid gid rdev size atime mtime)
		    (unix:unix-lstat namestring)
		  (declare (ignore ino gid rdev atime)
			   (fixnum uid mode))
		  (if reslt
		      (progn
			(dolist (coldef coldefs)
			  (typecase coldef
			    (string (princ coldef))
			    (number
			     ;; Assume file-or-more is a list.
			     (princ (nth coldef file-or-more)))
			    (keyword
			     (case coldef
			       (:mode  (print-mode mode))
			       (:nlink (format t "~2D" nlink))
			       (:uid   (format t "~8A" (or (lookup-login-name uid) uid)))
			       (:size  (format t "~8D" size))
			       (:date  (format t "~12A"
					       (multiple-value-bind (sec min hour date month year)
								    (get-decoded-time)
						 (declare (ignore sec min hour date month))
						 (decode-universal-time-for-files mtime year))))
			       (:name
				(if (= (logand mode unix:s-ifmt) unix:s-iflnk)
				    ;; FIX could print min part of link path
				    (let ((link (unix:unix-readlink namestring)))
				      (format t "~A~:[~;/~] --> ~A"
					      tail
					      (eq (unix:unix-file-kind link) :directory)
					      link))
				    (format t "~A~@[/~]"
					    tail
					    (= (logand mode unix:s-ifmt) unix:s-ifdir))))))))
			(terpri)
			(when return-list
			  (push (if (= (logand mode unix:s-ifmt) unix:s-ifdir)
				    (pathname (concatenate 'string namestring "/"))
				    file)
				result)))
		      (format t "Couldn't stat ~A -- ~A.~%"
			      tail
			      (unix:get-unix-error-msg dev-or-err))))))
	    (error "COLDEFS must be a list."))
	;;; Print the usual column format directly.
	(dolist (file contents)
	  (let* ((namestring (unix-namestring file))
		 (tail (subseq namestring dir-len)))
	    (multiple-value-bind
		(reslt dev-or-err ino mode nlink uid gid rdev size atime mtime)
		(unix:unix-lstat namestring)
	      (declare (ignore ino gid rdev atime)
		       (type (or fixnum null) uid mode))
	      (cond (reslt
		     ;;
		     ;; Print characters for file modes.
		     (print-mode mode)
		     ;;
		     ;; Print the rest.
		     (multiple-value-bind (sec min hour date month year)
					  (get-decoded-time)
		       (declare (ignore sec min hour date month))
		       (format t " ~2D ~8A ~8D ~12A ~A~@[/~]"
			       nlink
			       (or (lookup-login-name uid) uid)
			       size
			       (decode-universal-time-for-files mtime year)
			       tail
			       (= (logand mode unix:s-ifmt) unix:s-ifdir))
		       (if (= (logand mode unix:s-ifmt) unix:s-iflnk)
			   ;; FIX could print min part of link path
			   (let ((link (unix:unix-readlink namestring)))
			     (format t "~:[~;/~] --> ~A~%"
				     (eq (unix:unix-file-kind link) :directory)
				     link))
			   (format t "~%"))))
		    (t
		     (format t "Couldn't stat ~A -- ~A.~%"
			       tail
			       (unix:get-unix-error-msg dev-or-err))))
	      (when return-list
		(push (if (and mode
			       (or (= (logand mode unix:s-ifmt) unix:s-ifdir)
				   (and (= (logand mode unix:s-ifmt) unix:s-iflnk)
					(eq (unix:unix-file-kind
					     (unix:unix-readlink namestring))
					    :directory))))
			  (pathname (concatenate 'string namestring "/"))
			  file)
		      result))))))
**** Buffer filesys-G143:
;;;
(defun print-directory (pathname &optional stream &key all verbose return-list)
  "Like Directory, but prints a terse, multi-coloumn directory listing
   instead of returning a list of pathnames.  When :all is supplied and
   non-nil, then Unix dot files are included too (as ls -a).  When :vervose
   is supplied and non-nil, then a long listing of miscellaneous
   information is output one file per line."
  (let ((*standard-output* (out-synonym-of stream))
	(pathname pathname))
    (if verbose
	(print-directory-verbose pathname all return-list)
	(print-directory-formatted pathname all return-list))))

(defun print-directory-verbose (pathname all return-list)
  (let ((contents (directory pathname :all all :check-for-subdirs nil
			     :truenamep nil))
	(result nil))
    (format t "Directory of ~A :~%" (namestring pathname))
    (dolist (file contents)
      (let* ((namestring (unix-namestring file))
	     (tail (subseq namestring
			   (1+ (or (position #\/ namestring
					     :from-end t
					     :test #'char=)
				   -1)))))
	(multiple-value-bind
	    (reslt dev-or-err ino mode nlink uid gid rdev size atime mtime)
	    (unix:unix-stat namestring)
	  (declare (ignore ino gid rdev atime)
		   (fixnum uid mode))
	  (cond (reslt
		 ;;
		 ;; Print characters for file modes.
		 (macrolet ((frob (bit name &optional sbit sname negate)
			      `(if ,(if negate
					`(not (logbitp ,bit mode))
					`(logbitp ,bit mode))
				   ,(if sbit
					`(if (logbitp ,sbit mode)
					     (write-char ,sname)
					     (write-char ,name))
					`(write-char ,name))
				   (write-char #\-))))
		   (frob 15 #\d nil nil t)
		   (frob 8 #\r)
		   (frob 7 #\w)
		   (frob 6 #\x 11 #\s)
		   (frob 5 #\r)
		   (frob 4 #\w)
		   (frob 3 #\x 10 #\s)
		   (frob 2 #\r)
		   (frob 1 #\w)
		   (frob 0 #\x))
		 ;;
		 ;; Print the rest.
		 (multiple-value-bind (sec min hour date month year)
				      (get-decoded-time)
		   (declare (ignore sec min hour date month))
		   (format t "~2D ~8A ~8D ~12A ~A~@[/~]~%"
			   nlink
			   (or (lookup-login-name uid) uid)
			   size
			   (decode-universal-time-for-files mtime year)
			   tail
			   (= (logand mode unix:s-ifmt) unix:s-ifdir))))
		(t (format t "Couldn't stat ~A -- ~A.~%"
			   tail
			   (unix:get-unix-error-msg dev-or-err))))
	  (when return-list
	    (push (if (= (logand mode unix:s-ifmt) unix:s-ifdir)
		      (pathname (concatenate 'string namestring "/"))
		      file)
		  result)))))
***************

**** Buffer filesys-G142:
(defun print-directory-formatted (pathname result all return-list)
**** Buffer filesys-G143:
(defun print-directory-formatted (pathname all return-list)
***************

**** Buffer filesys-G142:
	(dir-len (1+ (or (position #\/ (unix-namestring pathname)
				   :from-end t
				   :end (length (unix-namestring pathname))
				   :test #'char=)
			 -1))))
**** Buffer filesys-G143:
	(result (directory pathname :all all :truenamep nil)))
***************

**** Buffer filesys-G142:
	     (slash-name (subseq name dir-len))
**** Buffer filesys-G143:
	     (length (length name))
	     (end (if (and (plusp length)
			   (char= (schar name (1- length)) #\/))
		      (1- length)
		      length))
	     (slash-name (subseq name
				 (1+ (or (position #\/ name
						   :from-end t
						   :end end
						   :test #'char=)
					 -1))))
***************

**** Buffer filesys-G142:
	     (cond ((null good-files)
		    (setf files good-files))   ;; FIX why? added via pd-attempt
**** Buffer filesys-G143:
	     (cond ((null good-files))
***************

**** Buffer filesys-G142:
;;;
**** Buffer filesys-G143:
;;;
***************

Done.
