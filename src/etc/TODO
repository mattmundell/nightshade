towards a public domain computer					-*- outline -*-
--------------------------------

	allow reuse of the work in any way
	  leaving any moral and ethical choice,judgement to the user
	working together, sharing everything
	ease reuse, for example of small [generic] parts

* todo

full pd
	where is the full pd?
	    only continue when full pd possible
		revert to 17f
			on "open source" os from company?
				think only works on machine arch from same co
		or 18a on old gnu/linux
			need glibc1 distro/image/machine
		n:src/etc/public-domain-via
			 code:numbers.lisp
				 ;;; ISQRT  --  Public
				 ;;;
				 ;;;    From discussion on comp.lang.lisp and Akira Kurihara.
			 pprint.lisp
				 William Lott.  Algorithm stolen from Richard Waters' XP.
					old-sys xp.lisp
						ok to copy algo?
							an mit report describes the functions
					;------------------------------------------------------------------------;
					;                    Written by Richard C. Waters                        ;
					;       Copyright (c) Massachusetts Institute of Technology, 1989        ;
					;------------------------------------------------------------------------;
		mh
			transcribe from orig
				check extent of other addns
			         mh.lisp  insert-mime-part  ; FIX uip/mhn.c h/mhn.h
	    clean general-info/ and docs/ refs to  pcl
											   clx?
		----------------------------
		revision 1.22
		date: 2000-05-22 18:43:09 +0100;  author: dtc;  state: Exp;  lines: +106 -1
		New implementation of the function rationalize, from Raymond Toy based
		on an algorithm from Bruno Haible.
		----------------------------
			float.lisp
			maybe revert this to revert haible doc requirement
	clean :doc/nightshade
    consistent comments,docs,msgs
		maybe easier to automate
			eg reader reads,stores comments, printer outputs in a style
				(towards ~ continual/lazy source optimization)
		docs
			arg names all same
			    ARG `function' `Command' *var* `Ed Var'
			always describe fun in docstring
				std seems doc public function in docstring, internal funcs w comment
					think rather all in docstring and note in ed interface if internal
				--
				;;; FRAME-CATCHES -- Public.
				;;;
				(defun frame-catches (frame)
				  "Returns an a-list mapping catch tags to code-locations.  These are
			   s/b?
				;;; Public.
				;;;
				(defun frame-catches (frame)
				  "Returns an a-list mapping catch tags to code-locations.  These are
		(in-package :extensions)  or  (in-package "EXTENSIONS")?
		why exports.lisp?
		package doc duplicated in package def in exports.lisp and in header of file defining pkg
			maybe merge w manual
		;;; Format-Time - External.   public interface internal
		magic
		pronouns
		positive sense
		imperitive
	check
		ed
			----------------------------
			revision 1.4
			date: 1996-05-08 15:56:40 +0100;  author: ram;  state: Exp;  lines: +11 -2
			branches:  1.4.2;
			Patch from Jeurgen Weiss to translate-key-event which makes it deal better with
			european keyboards.
			----------------------------
	    src/doc/internals/dave-memory-layout.mss (left out anyway)
publish binary
	try on jef laptop
		mh first?
		syncing additions?
rest of ed naming
rename cl to lisp
clean tools:
clean compiler:
check doc:styles special
--
often reading keywords maybe dodgily
		(let ((exp (let ((*package* *keyword-package*))
			 (read-from-string exp))))
add equiv of manual
	very quickly, maybe just collect docstrings
~literate program manual  ie merge into source
	doc packages
doc.lisp  merge interp,gen cases
		 	  look into allowing , anywhere
	 	  compile cv.lisp (hangs)
(define clear (x)
  "Set X to ()."
  (setq X ()))
(last "abc") and other seqs?
	(char x (length x))
appendf?  (like push-back)
describe labels somewhere, esp that jumps to labels jump out of var bindings, e.g.
	(let ((s 1))
	  (labels ((a ()
			 s)
		   (b ()
			 (let ((s 2))
			   (a))))
		(b)))
  returns 1
  when to use a label?
flet
	an flet defnd function should stick around (perhaps via a declare/declaim)
	  in case body does an eval which calls the function
format time
	(format-time () :style '(:day "_" :month "_" :year) ...
	(format-time () :style '("~D_~M_~Y") ...
	(format () "~dT_~mT_~yT" ...
	(format () "~T(d_m_y)" (get-universal-time))
	e.g. mh.lisp
		(format stream "Date: ~A" (format-time () :style :rfc1123 :print-weekday ()))
		(progn (format stream "Date: ") (format-time stream :style :rfc1123 :print-weekday ()))
		s/b
		(format stream "Date: ~Ts" :rfc1123 (get-universal-time)) ; Time-style
		(format stream "Date: ~Ns" :rfc1123)                      ; Now-style
doc lang
	sharp macros
	:doc/nightshade
docs
	scribe  (make-dispatch-macro-character #\@ t)?
code/sunset.lisp
parse-time.lisp  dow incr day past end of month
take out (replace?) monitor
may be simpler to write these if every needed
  (some maybe from orig cmucl anyway)
	merge in pd from c-l.net  :src/alexandria,anaphora
		cl-telnet  contains code from araneida which is bsd-licensed
	merge in cl-utilities
	   note each licence in html doc, eg split-sequence
		This code was written various people, and the license is unknown. Since
		multiple people worked on it collaboratively and none of them seem interested
		in keeping their intellectual property rights to it, I'll assume that it is in
		the public domain (since the process that produced it seems like the very
		essence of public domain). If this is incorrect, please contact me so we can
		get it straightened out.
		split-sequence.lisp
		;; cl-utilities note: the license of this file is unclear, and I don't
		;; even know whom to contact to clarify it. If anybody objects to my
		;; assumption that it is public domain, please contact me so I can do
		;; something about it. Previously I required the split-sequence
		 ; package as a dependency, but that was so unwieldy that it was *the*
		;; sore spot sticking out in the design of cl-utilities. -Peter Scott
		 rest seem ok in code
	/home/matt/src/ftp.cs.cmu.edu/afs/cs.cmu.edu/project/clisp/old-system/systems/code/macromemo.lisp
seq.lisp split  cmp filesys.lisp split-at-slashes
replace dependencies on copyrighted code
	replace external library dependencies
		maths lib
			libc6-dev provides /usr/lib/libm.a
				why linked?
				code:irrat.lisp
		c lib
			maybe skalibs? eg for translation reference
			isolate uses of unix pkg  eg dired.lisp (use filesys.lisp fncs?)
				towards replacing unix interface
		cc
			move c into lisp
				maybe start w interrupt.c  e.g. install_handler
				purify.lisp  Rewritten in C by William Lott.
				gencgc
					first attempt left in 0.0+
				switch to cgc.c? only x86, same as gencgc
	replace unix parts
		lisp build scripts  (almost done)
		`make' system
			move c into lisp
			in dir Build.lisp lists rules; make w function build or cmd Build
					;; perhaps defrule just defines a function, maybe in a pkg
					(defvar files '("cv.tex" ...))
					(load "build-publish.lisp") ; defines generic publishing rules
					(defrule cv.tex (cv.lisp "File with spaces")
						;; FIX ensure cv.lisp loaded
						(~cv-to-latex "cv.tex"))
					(defrule clean ()
						(delete-files files))
				maybe read re other newer make systems
		lisp equivs of unix tools
			parse
				cmp w reader, byacc
					maybe good token-based version/option
						(ie parses only tokens sep'd w whitespace)
				speed
					*marks* optnl
					create node afterwrds?
					boyer-moore?
				backw
				use in dired search
				Srch [R]  case  c-u? (for hidden files) c-uc-u? then for hidden,case? c-uc-uc-u?
					  what about backup files?
					  maybe c-u results in prompts for all of these
						  fold case, search hidden, search backup
			head, tail...
			tar, compression
				compress is public domain, lwz patent has expired
				many compression algo's
			cron
		dict interface  pd version incl data
		dictd, dict client
		add system services i.e. replace unix kernel
data
	dicts  moby thes, jargon file, ...
		   orig source of gcide?
		   le dico?
	all knowledge
		distributed shared ~peer hosting
		wikiknowledge, infoanarchy data, wikip pd refs, us gov sites, ibiblio
			organised as a whole
	integrate public domain ~database
		distributed
		nuttal encyclopedia, infoanarchy wiki, 1911 encycl
		dict
			copyright on original source of gcide?
		pd french dict, pd lojban words
graphics, images
    vector graphics mixed w text
    http://www.w3.org/Graphics  for svg
    terminal graphics eg `graph -T tek < data' on an xterm
	img formats
		http://www.dcs.ed.ac.uk/home/mxr/gfx/2d-hi.html  (maybe old)
		:pkgs/lisp/skippy.lisp  (now that gif patent has ended)
	http://www.cca.org/vector/
		vector graphics terminals
	from text-term howto
	  Many text terminals can display bit-mapped images, but not in color.
	  Unfortunately, the popular image formats used on the Internet are not
	  supported.  The protocols for terminal graphics include: Tektronix
	  Vector Graphics, ReGIS (DEC), Sixel (DEC), and NAPLPS (North American
	  Presentation Level Protocol Syntax).
	drawing interface, then a logo  maybe two moon slivers that make a ()
run cmucl/retroforth on a simple public domain architecture
	MIT ran a project in the early 1980s that produced a "Scheme Chip". For
	details check out ''' Design of a Lisp-based processor ''' by Guy Lewis
	Steele, Jr. and Gerald Jay Sussman, Communications of the ACM
	23(11):628--645, November 1980. and ''' The Scheme-81 architecture - system
	and chip ''' by John Batali, Edmund Goodhue, Chris Hanson, Howie Shrobe,
	Richard M. Stallman, and Gerald Jay Sussman. In Proceedings, Conference on
	Advanced Research in VLSI, pages 69--77. Paul Penfield, Jr., editor. Artech
	House, 610 Washington Street, Dedham MA, 1982.
consider lojban
    which spoken langs are verb-first like lisp?
		Examples of languages with VSO word order include the Gaelic branch of the
		Celtic language family (namely Irish, Scottish Gaelic and Manx), related Welsh
		(the only VSO Brythonic language), Ancient Egyptian, Aramaic, Biblical Hebrew,
															 ^^^^^^^^ of jesus
		Pangasinan, Phoenician, Canaanite, Ge'ez, Classic Maya, Tagalog, Hawaiian,
	    ^^^^^^^^^^ alive        ^^ hewbrew?
		Mˆ€‚ori, and Tongan.
		.
		Even though Arabic originally had VSO word order, it is now usually more
		understood with SVO, especially Egyptian Arabic and Moroccan Arabic.

    integrate w :doc/system

    letters ordered  most common first

    The language is a set of descriptions of state.
    The language can describe a state, including all possible changes
    that the state can undergo.
	; dimension for function vibe, needs to think through handling if
    The language can describe the evaluation of objects.  Objects can be
    symbols or structures.  A structure is a grouping of one or more
	; or lists which evaluate as functions, w stack-like arg eval
    optionally named objects.  A symbol is a reference to another object.
    Evaluation of a symbol produces the referred object.  Evaluation of
    a structure produces the structure.

	;; ~ structures and symbols?
    The integers are structures of two symbols, universe and empty.  For
    example 1 is a structure of a structure of a symbol which is universe,
    and 3 is a structure of a structure of two symbols both universe.

    Sequences of evaluation can be shared in functions.
    Argument evaluation, closures.


* language,library ideas,notes

    hil is latin for true  false? is false required?
	how bout just n/f? (like t)  or () which already works (usually for lists)
	why scheme uses #t #f? easier to spot?
	what does lojban use?
	(~complement (page-large-object-p first-page))
	for
	(if (page-large-object-p first-page) nil t)
	  {now (fi (page-large-object-p first-page))}
	(- all true)?  (- all all)

	"is set" instead of "is true"
	consider love,clear for ()

    (>< (<>  (greater-than-or-less-than
    epsilon, zero   list terminator, end, false   always, forever, ever

	recycle instd of delete,remove
		add to trash, recycle trash

    always, multi-return-protect, <throw-protect>, always-after
      instead of unwind-protect

	how to return from a lambda?
	add (return) to ret from current fun?
		ie implied (block () ...) around function body
	maybe a way to refer to current function
		(return-from (this) t)  ; (return t) would return from a love block
			this this-function this-block

	eq take multiple args

	change let to be like let*
		(let ((a 1) (b a))        old  (let* ((a 1) (b a))
	    (let ((b a) (a 1))        old  (let ((a 1) (b a))
			side-effects may require the order

	;; two ways the same, due to t,f?
	(if  (if a (eq a b) t)         d)
	(if  (or (eq a nil) (eq a b))  d)

	eq char= string=
	eq char-eq string-eq
	= char= string=

	consider a let-replacing push,pop, eg
		(push (read-line in))
		(if (top) (write-line (pop)))
	  with compiler optim equiv to let
	  maybe  block ends clear any excess pushes, and excess pops an error

	how to eval the first , with the first `
		``(a ,(b) ,(c))

	"value" instd of "object"  eg db.lisp  find-object
							   tty-display-object

	destructuring-bind  split-bind?  bind-many?  multi-bind?
	multiple-value-bind  *let?  mlet?  multi-bind?

	(defmacro split (sequence &rest separators &key start end)
		seems nicer than reqring seqarators to be a list
		only gives "odd num of kwrds" error

		consider &-- as in shell options
		   (f :key1 a :-- :key1 arg2)  ; 2nd :key1 just an arg
		   keywords seem like infix notation

	nesting strings
		{string with {nested string}}
		"string with \"nested string\""

		{string {sub {nested} first} end}
		"string \"sub \\\"nested\\\" first\" end"

	ed macros are like another language

	might be useful if <,... returned the first arg
		(or (< (file-size pathname) 99999)
			">9999")

    keyword as func name?  (:f arg)
	maybe epsilon function name, eg ( arg arg2 :keyword val), (:keyword val)

    ;; FIX logand  bit logic (vs maths logic)  (maybe bitand instead?)

	keyword args
		should be let-bound specials instead?
			performance?
				maybe possible to optimize into lex binding in most cases

** conditionals

    if+,i+,*f instd of when? or+,o+,*r instd of unless? (like let*) maybe if*,or*
	   these look like arithmetic ops
	(when a b)
	(a a b)      ; a for and, maybe and*, an*, a*  ..+ ..1

	(fi x) == (fi x t) == (if x () t)
		(if x) == (if x t) == t
		(if)   == (if t) == (if t t) == t
		should the lang use all the combinations of ~parts?

	(fi x (a) (b)) == (if x (b) (a))
	(fi x (a)) == (if x () (a))
			   == (or x (a))
	(f1 x (a) (b)) == (or x (progn (a) (b)))
				   == (o1 x (a) (b))
	(1f x (a) (b)) == (if x (progn (a) (b)))
				   == (when x (a) (b))
	               == (and x (progn (a) (b)))

		consistent conditional syntax
			and, if, when                 a* ao a1        and if and*
			or, fi, unless				  o* oa o1		  or fi fi*
					either, nehw (when backwards)
			cond
			case

			(xxx a (a) (b))

	(when a b)   (nehw a)

	(unless a b)
	(o a b)      ; o for or, maybe or*, o*  ..+ ..1
	(cond (a b) ((..) c) (t d))
	(or* (a b) ((..) c) (t d))

	(if a b c)
	(a (o a c f) b)   ; a and, o or, f false
	     ;; FIX how to return the c?
	     (a (o a (values f c)) b)   ; a and, o or
					; f ends a which rets 2nd val (c)
	     (a (eq (o a c) c) b)   ; a for and, o for or  if eq rets val
	(and* (a b) ((..) c) (t d))  ; like cond, tests each case
				     ; rets ~ multiple
	(or* (a b) (t c))

    replace if w cond?
    (if x a b)  (cond (x a) (t b))  (cond (x a) b)  (if (x a) (t b))

	replace and w if?
	(and a b c)
	(if a (if b (if c c)))  c evald 2x

	replace if w and?
	(if a b c)
	(or (and a (progn b t)) c)

** iteration

		do-* loop
		recursion labels iterate
			tail recursion
		map*

		can map* be equivalently replaced by other loop construct?

		do* should be do-*?

		replace do w modified loop? (and rename loop do)            ~ scheme uses heavy recursion
		(do ((for x t :then f)        ; (let i 0 f)
		 (for i 0 :to 10 :count)  ; (let i 0 :to 10 :count)
					  ; (let ((i 0 10 :count)))?
		 (while x)
		 (return t))
		   body)
		(do t body)  for  (loop body)
		(do (for x 0 10) body)      (do (x 0 10) body) (do (:list list)
		dolist?
			 (do ((for ele :in list)) ...)
			 (do ((list ele list)) ...)
			 (dolist (ele list) ...)
			 (do ((list list)) ...)  elements bound to var $ or $_ $1
			 (do (list list) ...)    elements bound to var $ or $_ $1 $A it
		from hem macros.lisp
		;; FIX structure like do  FIX use (loop while ... do
		; (defmacro while (cond &rest body)
		;   `(do () ((if ,cond nil t))
		;      ,@body))
		; (ed::defindent "while" 1)

** format, strings

	string special is /  "ab\"c\"" => ab"c"
						 "ab\n" => abn
	format special is ~
		should be same?
		string should allow more special chars, like newline?

	format strings are like another language
		(format () "x: ~A and y: ~2D, ~@[(y < x)~]" x y (> x y)
	  could use lisp instead
		(format () "x: " x " and y: " (D y 2) ", " (if (> x y) "(y < x)"))
	  even in the string
		(format () "x: ~x and y: ~(D y 2), ~(if (> x y) \"(y < x)\")")
		(format () "x: ~x and y: ~(D y 2), ~(if (> x y) '(y < x)')")    special '
		(format () "x: ~x and y: ~(D y 2), ~(if (> x y) "(y < x)")")    reader string parsing


		(format "int: " (D i) ", any " (A var) ", " (A var) (%)
				"looping: " (loop for i in '(1 2 3) do (D i) (A ", ")))
															 ^^^^^^^^sux

		(format "int: ~D, any ~(A var), ~(A var) ~%
				looping: ~{'(1 2 3) (D $) (A ", ")})

		(format "int: ~D, any ~A, ~A~%looping: ~{~D, ~}"
				i var var '(1 2 3))

			seems like current format style will always be neater

				are there other novel styles?

    add (format nil "x: ~$x")   ; like (format nil "x: ~A" x)     ; similar perl
        (format nil "x: ~$S$x") ; how to ~S like above

** evaluation, macros

    deflaz  (think lazy may usually mean evaluated, just as late as psbl)
	    (whereas these args are optionally evaluated)
	    deftrans defmacro defun2 defclosure defclos defcl define def
	    defspec defsf defsp
	    defclo

        name all such functions similarly
	at least highlight all same (as special forms currently highltd)

	+ ability to pass these functions around

(deflaz when (cond &rest body)
   (if ,cond ,body))

(deflaz eval (form)
   ,form)

(deflaz when (cond &rest body)
   (if (eval cond) (eval (cons 'progn body))))

(defmacro when (cond &rest body)
   `(if ,cond (progn ,@body)))

(defun a (b c d)
   (,b c ,d))       ; evaluates d "twice", evaluates b to produce the function name/symbol

(declaim (inline when))
(deflaz when (cond &rest body)
   (if ,cond ,(cons 'progn body)))    ; evaluate cond "twice", eval result of eval of (cons ...)


** handlers

  1 (handler-bind ((editor-top-level-catcher #'identity))
    (catch 'editor-top-level-catcher
    (signal 'editor-top-level-catcher nil))
    (throw 'editor-top-level-catcher nil))

	     (block ed-x
	       (handler-bind
	           ((editor-top-level-catcher #'(lamdba () (return-from ed-x)))))
	         ...
	         (signal 'editor-top-level-catcher nil)...

	      s/b~

	      (catch-condition 'editor-top-level-catcher
		...
		(throw ~(make-condition 'editor-top-level-catcher) nil)...

	should be able to catch,throw conditions?
	and signal symbols?
	    then maybe replc throw w signal
		throw returns the stack to a catcher
	          whereas signal just runs the handler code

  2	(handler-case
	   ((a () ...)
	    (b () ...))
	  form*)

	    so that cases at top like handler-bind
               and can have many forms in case (form*) instd of one

  3  why handler-case handlers form* while handler-bind handlers functions?

** type conversion, dynamic typing

  (+ 4 "5")
  	  should the 5 perhaps be read from the string automatically?
		  is an attempt at some sort of behaviour better than
			an error for every case?

  (defun f (a b)
	(declare (int b))
	...)
  (f 1 "2")

  consider reducing type specification eg prefer equal to char=,string=

  should 1 be always eq 1?  (vs equal)
	  ie should the integers only be considered eq if they are the same instance
	  how does that fit into a clean system?
	  is there a case for integer instances?
	  should there be instance comparison at all?

** streams

  search in streams   (search "foo" stream)  ;ret pos?
					  (find #\a stream)      (find "aa" stream)?
					  (position #\a stream)    "
					 some optns may be hard/weird, like :from-end
	  ed buffer operations ~duplicate this (for buffers)

* longer term

~ generalized functions (as in clos)
    (~overloading?)
	check oo systems such as clos,smalltalk

	maybe an eg: call member on a string-table (currently call getstring)

~run-time modification of structure (ie the definition of the structure)
    eg to change node insert function
    (defstruct (s) a)
    (symbol-function s)
    (symbol-structure s)

files as a type of variable
    so map a var name to memory on disk
    instd of mapping a file name to the set of blocks

	like persistant memory system

tracer, meta, <word for thinking about thinking>, higher-order, inspect
   (name for tracing tool)

consider expression-level comment  '((a 1) {b 2) (c 3))  ; "{" comments (b 2)
