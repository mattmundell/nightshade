public domain computation, communication and information -*- outline -*-
--------------------------------------------------------

    based on ease of copying
	allow reuse of the work in any way
	    leaving any moral and ethical choice,judgement to the user
		giving entirely,everything, building on what has been given
	working together, sharing everything
	ease reuse, for example of small [generic] parts
	reduce the legal weight on the project
	strengthen the weakest

	moonshine
    belladonna
    mindhouse mindhome

* entirely public domain

	finish n:src/etc/public-domain-via
		finish log scan
		contact maintainer for addresses
	doubt
	    what about algorithms copied from books?
			such as knuth
			    e.g. two-arg-gcd in code:numbers.lisp and *truncate in code:bignum.lisp
			can the implementation be considered a derivation of the work in book:
				- if it is a near-exact translation to the programming lang?
				- if the book algo is used as an outline (maybe roughly initially)?
				- if the programmer simply learns the algorithm from the example in the book?
			  when the designer of the algorithm writes down the algorithm, where does
				the idea of the algorithm end and the copy of the algorithm start?
			  when someone who knows the algorithm writes down the algorithm, where does
				the idea of the algorithm end and the copy of the algorithm start?
		pprint.lisp
			William Lott.  Algorithm stolen from Richard Waters' XP.
			   old-sys xp.lisp
				   ok to copy algo?
					   an mit report describes the functions
					   hazy terrain, may be considered a derived work
									   if william read the xp source?
			   ;------------------------------------------------------------------------;
			   ;                    Written by Richard C. Waters                        ;
			   ;       Copyright (c) Massachusetts Institute of Technology, 1989        ;
			   ;------------------------------------------------------------------------;
		   maybe just rewrite it?
		serve-event.lisp 522
			;; Doesn't work -- ACK
			;(setf (handler-active handler) t)
			who is ACK?  Akira Kurihara?  reverted only log of Akira
	revert rest of sys to public domain
		ok to refer to perm lic'd works?
			maybe ask byacc author (Robert Corbett)
				result could be considered a derived work
		ok to work on perm lic'd work?
			maybe ask sqllite author
	maybe chat to pdksh author
    ask cryptopp552 author Wei re lisp porting of entire library

    archive mh, pd c, pdtar on website?
	    public domain software directory


* backups

only daily build clean tree if changed

incl builder

** tangent trees

/home/mattm/src/shadow/nightshade/
/home/mattm/src/shadow/nightshade.orig

* consistency

    consistent comments,docs,msgs
		maybe easier to automate
			eg reader reads,stores source incl comments
			   printer outputs in a particular style,organisation
			   edit a/many function/var def(s) in a buffer in a special mode
				   save saves as alternative (like editing in a vc dir)
				   ~build replaces existing (like building local and committing vc)
				(towards ~ continual/lazy source optimization)
		;;; End of xxx.lisp.
		docs
			flush first line of para
			/home/matt/src/nightshade/src/compiler/mips/random-doc.txt
			arg names all same
			    $arg `function' `Command' *var* *Ed Var*  "quoted text"  "Buffer Name"  Buffer Name
			(reconsider) always describe fun in docstring
				std seems public in docstring, internal in comment
					rather all in docstring (ed can show public/internal)
			    ;;; name  --  Public.
	                ^^^^ in case following comment is long
			many c: fun docs are comments above fun
				comments for how it works, ie descriptions of code, the way it is implemented
				doc string for what it takes, returns, and any side effects
					ie ~ what it does from a callers perspective

				downside is that doc strings make sys bigger
					big downside for small systems
					with big sys like c: makes whole much bigger
						maybe editor can get doc comment from src?
	    doc all
			doc when adding test
			doc must contain
				all args  $arg format
			    return value
				errors, conditions
				with marked up *vars* `functions' *Commands* as above
				and refs to [doc nodes]
		(in-package :extensions)  or  (in-package "EXTENSIONS")?
		why exports.lisp?
			maybe affects cold load
		package doc duplicated in package def in exports.lisp and in header of file defining pkg
			maybe merge w manual
		;;; Format-Time - External.   public interface internal
		magic
		pronouns  we
		positive sense
		imperitive
		~clip instd of kill
		    cut, clip, copy, chop  save-ring (save is for files)
			text/region ring  could have more than text eventually
		quit,exit for abort  cancel

  goto function (meta-g f)  vs  find file (meta-x f)
	  should be ~ find file and find function

  #t () #f '() '#t?

* clean, tidy, neat, organised

* tests

heed all warnings
check doc when adding test
reconsider randomness
    tests must be reproducible
        maybe log seed
	tests must cover any previous error cases they caught
		maybe if a random test shows a new error, add a fixed test of that error
	the idea is that running the tests once (eventually) gaurantees that all cases are checked
        maybe gaurantee that the random tests cover all cases
			then why need randomness?
				maybe for stress testing
				maybe for initial quick mostly-covered testing
					possible takes longer to setup random test, eg deftest:create-tree took ages
				more likely to show up new test cases
					more important than gauranteed complete coverage testing?
	even reconsider use of random-string,pathname and pick-new-*
		maybe use test-string,pathname-1..n instead
		maybe run test in a temp dir
			implies too much of the base system
integrate :nightshade.work-pre-aon-2007-01-02-merge/src/tests/
compiler tests
    srctrans.lisp:1946 onwards
code/filesys.lisp/print-directory,files
    why some fail second time around?

update tests  (deftest mh:symbol-name (.. mh-symbol-name ..) ...)

* next

public domain
clean docs
	clean :doc/nightshade
clean build warnings
drop lisp cl nicks
clean contrib
turn this into online release plan (quickly, for better direction)  ../etc/TODO
    integrate w docn, publish all
	quick introduce project planning tool?
		steps, time estimates, dependencies, critical path
clean doc refs to  pcl (rename?), clx?
warnings,errs when sys building
- null
file checksums in case of disk error  eg distrib archive
--
often reading keywords maybe dodgily
		(let ((exp (let ((*package* *keyword-package*))
			 (read-from-string exp))))
    reading symbols
		(intern (format nil "C~{~:[A~;D~]~}R"
				(mapcar #'(lambda (x) (logbitp x j)) b))))
		(intern "FOO" *keyword-package*)
doc.lisp  merge interp,gen cases
		 	  look into allowing , anywhere
	 	  compile cv.lisp (hangs)
(last "abc") and other seqs?
	(char x (length x))
	(car "abc")
appendf?  (like push-back)
(with-output-to-mark (out (current-point))
  (print-directory ":temp/" out))
=========================================================== nightshade 2 if full pd

full tests, entire coverage
    start with fs
		move it out to fs package first?
- dylan from c:
error handling
	maybe better use of predefined conditions on error
flet
	an flet defnd function should stick around (perhaps via a declare/declaim)
	  in case body does an eval which calls the function
		ignorable
    (flet ((a ..) (b ..)) ..)
       should a be visible in b?
parse-time  Tue, 07 Aug 2007 17:14:38 +06-30
			Mon, 6 Aug 2007 22:56:56 -05-30
format time
	(format-time () :style '(:day "_" :month "_" :year) ...
	(format-time () :style '("~D_~M_~Y") ...
	(format () "~dT_~mT_~yT" ...
	(format () "~T(d_m_y)" (get-universal-time))
	e.g. mh.lisp
		(format stream "Date: ~A" (format-time () :style :rfc1123 :print-weekday ()))
		(progn (format stream "Date: ") (format-time stream :style :rfc1123 :print-weekday ()))
		s/b
		(format stream "Date: ~Ts" :rfc1123 (get-universal-time)) ; Time-style
		(format stream "Date: ~Ns" :rfc1123)                      ; Now-style
code/sunset.lisp
parse-time.lisp  dow incr day past end of month
seq.lisp split  cmp filesys.lisp split-at-slashes
(defun (setf documentation) (string name doc-type)  instd of ~defsetf
search /doc/*/copyright "public domain"

replace dependencies on copyrighted code
	replace external library dependencies
		maths lib
			libc6-dev provides /usr/lib/libm.a
				why linked?
				code:irrat.lisp
		c lib
			maybe skalibs? eg for translation reference
			all calls to c   call_into_c   (define-vop (call-out)
				printf via debug_print  called in c:*/print.lisp
				isolate uses of unix pkg  eg dired.lisp (use filesys.lisp fncs?)
					towards replacing unix interface
		c compiler
			move c into lisp
				maybe start w interrupt.c  e.g. install_handler
				purify.lisp  Rewritten in C by William Lott.
				gencgc
					first attempt left in 0.0+
				switch to cgc.c? only x86, same as gencgc
				take out (replace?) monitor
	replace unix parts
		lisp backup scripts
		lisp build scripts  (almost done)
		build system
			move c into lisp
		lisp equivs of unix tools
			(sudo (symlink-file ...))
			dd
			~Shell History
				buffer of previous cmds, enter to rerun, e to edit as new
			serial terminal interface,control  terminal.lisp?
			short versions of funcs for quick scripts
				(sh for (run-shell-command
				(mkdir for (make-directory
				(cp, mv, ln ...
				piping? redirection? ~streams ~~implied
					maybe meta-x meta-x runs all given "piped" (a) (b)  => a | b
						implied progn, with implicit stream ~stdin   *standard-input* is implicit
			stty  rompsite  tcsaflush
			parse (defparser section below)
			head, tail...
			find
			cp  recursive for backups
			rm, chmod...
			tar, compression
				compress is public domain, lwz patent has expired
				there are many compression algo's
			cron
			smtp server  with mh mime
			socat
			libs
				strtok  split   docs for these
		lisp equivs of unix tools
			mouse hider
		dict interface  pd version incl data
		dictd, dict client
		add system services i.e. replace unix kernel
		http://www.iana.org/assignments/port-numbers
cnc
	http://www.linuxcnc.org/
		based on ENC, which is pd   where is ENC?
			mail and ask?
data
	dicts  moby thes, jargon file, ...
		   orig source of gcide?
		   le dico?
	all knowledge
		distributed shared ~peer hosting
		wikiknowledge, infoanarchy data, wikip pd refs, us gov sites, ibiblio
			organised as a whole
			http://www.infoanarchy.org/
			http://www.infoanarchy.org/wiki/index.php/Main_Page
		part of language
	integrate public domain ~database
		distributed
		nuttal encyclopedia, infoanarchy wiki, 1911 encycl
		dict
			copyright on original source of gcide?
		pd french dict, pd lojban words
clean up find-a-pty
include proofs in devel environment
graphics, images
    vector graphics mixed w text
    http://www.w3.org/Graphics  for svg
    terminal graphics eg `graph -T tek < data' on an xterm
	img formats
		http://www.dcs.ed.ac.uk/home/mxr/gfx/2d-hi.html  (maybe old)
		:pkgs/lisp/skippy.lisp  (now that gif patent has ended)
	http://www.cca.org/vector/
		vector graphics terminals
	from text-term howto
	  Many text terminals can display bit-mapped images, but not in color.
	  Unfortunately, the popular image formats used on the Internet are not
	  supported.  The protocols for terminal graphics include: Tektronix
	  Vector Graphics, ReGIS (DEC), Sixel (DEC), and NAPLPS (North American
	  Presentation Level Protocol Syntax).
	drawing interface, then a logo  maybe two moon slivers that make a ()
benchmarks
run cmucl/retroforth on a simple public domain architecture
	wikip mentions a scheme processor designed at mit ~1980; authors on papers
	  included steele, sussman and stallman
more public domain programs
	cad lisp  gpl, cl dir mentioned pd support lib
		http://rgrjr.dyndns.org/icancad/
	3d rendering (using clx)
		http://www.thoughtstuff.com/rme/viewing.lisp
consider lojban
    which spoken langs are verb-first like lisp?
		Examples of languages with VSO word order include the Gaelic branch of the
		Celtic language family (namely Irish, Scottish Gaelic and Manx), related Welsh
		(the only VSO Brythonic language), Ancient Egyptian, Aramaic, Biblical Hebrew,
															 ^^^^^^^^ of jesus
		Pangasinan, Phoenician, Canaanite, Ge'ez, Classic Maya, Tagalog, Hawaiian,
	    ^^^^^^^^^^ alive        ^^ hewbrew?
                   philipines, other Malayo-Polynesian langs also verb-first
		Mˆ€‚ori, and Tongan.
		.
		Even though Arabic originally had VSO word order, it is now usually more
		understood with SVO, especially Egyptian Arabic and Moroccan Arabic.

    integrate w :doc/system

    letters ordered  most common first

* system ideas

	consider indicating dirs solely on trailing pathname slash
		to allow files and dirs of same name
		maybe merge the two somehow

* webpage website

reference hemlock in desription?  at least in documentation
convert to doc
check snapshot
ask isp re hosting
	using space
	  eg doc 3Mb
	  previous releases
	  on other hand popping mail so using min for that
	www.nightshade.org
online source code browsing
	online ed interface?
update screenshots (maybe incl desktop shot with many xterms)
consider fixed-width font

* documentation

all eg unix cmds prepend prompt $, all lisp prepend *, note in [Documentation Conventions]

finish generating docs
	build  type error on build (enable defparser to see)
	       maybe mv commands,vars to code:
	finish descriptions  doc group?
	item  paragraphs (instd of just lines)
	{*:...}
	docstring  paragraphs
			   docnode formatting
	offset code and quotations (just make anything offset verbatim?)

[ The Evaluator ]    eval
[ The Listener  ]    read-print-eval loop

lisp/ni node   :keywords  ~ special reader form

learning, prerequisite (general,local knowledge), order of concepts
    what is a continuation?  icr

doc setfs somehow

macros  first line a paragraph w syntax

doc each [public] struct

doc function returns, consider special markup $$return Description.
   same for errors

doc nodes  consider per-package

Apropos  add doc nodes

lang tutorial  super quick to do, for the experienced

describe labels somewhere
    part of lang?
	esp describe that jumps to labels jump out of var bindings, e.g.
	  (let ((s 1))
		(labels ((a ()
				  s)
				 (b ()
				  (let ((s 2))
				   (a))))
		  (b)))
  returns 1
	  (let ((s 1)) (defun a () s) (defun b () (let ((s 2)) (a))) (b))  => 1
	  (let ((s 1)) (defun a () s) (defun b () (let ((s 2)) (a))) (let ((s 3)) (b)))  => 1
	  (progn (declaim (special s)) (let ((s 1)) (defun a () s) (defun b () (let ((s 2)) (a))) (b)))  => 2
	just due to lexical binding
  when to use a label?  some description in compiler man nodes
  c-g d  on labels goto def
  c-h f labels?

add equiv of manual

	very quickly

	clean merged-in parts
		pageref, xref
		compiler notes
		\code{}

	[sys usage]
	    consider doc'ing via pkgs, and threading lightly thru pkgs in node

	structure slot doc should be in struct def, instd of via setf after struct
	    (defstruct (process)
		  (output :doc "Stream from child's output or ()"))


	  or maybe
	    (defstruct (process)
	      "Stream from child's output or ()"
		  output)


	[ Function Index ]
	[ Variable Index ]
	[ Type Index     ]
	[ Concept Index  ]
		automate these?

	sort out syntax
	           TODO (link:)
                   [[file] etc:TODO]
                   [file:etc:TODO [TODO list]]
		* list
		** description
	doc packages
	integrate package,function,var docs
	    {package:lisp}
	    {function:cons}
	    {variable:*print-circle*}
		{command:Extended Command}    inline
		[command:Extended Command]    link
		[http://www.ni.org [home]]    link
	generic?
	    {(documentation *print-circle* 'variable)} ; include lisp
		[(docn-link "Introduction")]
		[(docn-section "Sec 1")]
	    {(docn-link documentation *print-circle* 'variable)}
	link doc.lisp (eg to output all to html)
	doc lang
		:doc/common-lisp
	:doc/nightshade  at least editor notes
	scribe  (make-dispatch-macro-character #\@ t)?
	internals
		fasl.tex
		In good shape.

		object.tex
		Fairly good, but should probably be integrated with description of primitives
		in vm.tex.

		front.tex
		Needs updating cleanup scan.  Not too bad.

		middle.tex
		Need VMR overview.  New names for GTN/LTN?  Needs general cleanup, but not too
		bad.  NLX and stack are the worst.

		back.tex
		Pack and assembler need more info.  General cleanup.


		compiler-overview.tex
		Adapt introductory material from /../fred/usr/ram/comp.mss, pap:talk.mss
		Division between ICR overview and ICR convert needs work.

		debugger.tex
		Needs much work.  Merge much info from debug-info and debug-int.  Duplicating a
		fair amount of stuff in the source may make sense where, since this is a part
		of the system that is generally interesting.  And also, a part that people
		building on CMU CL might want to understand.

		glossary.tex
		Finish, integrate w/ main text?

		interpreter.tex
		Very sketchy and tentative.  Needs to be fleshed out from the code.

		retargeting.tex
		Very rough.  Needs to be merged with parts of vm.tex (call vops).  Needs some
		additional text.  Documentation of assembler, and all other exported
		interfaces.  (Generate defined VOP descriptions from the core, keyed to files?)

		vm.tex
		This file should probably cease to exist, going into object, retargeting and
		introductory material.  [Also other scrap in stuff/]


		[VMR and ICR overview also needed...]

		architecture.tex
		Missing sections on startup code, compiling, building.

		environment.tex
		Needs to be written: type system and info database interfaces.

		interface.tex
		Needs to be written: source paths and error message utilities.

		lowlev.tex
		Needs to be written.  All manner of low-level stuff: memory layout and
		management, core file format, C interface, low-level debugging (and ldb.)

		
		Several different audiences:
		 -- Curious compiler implementors (not a big priority.  Downplay academic
			aspects, i.e. comparisons to other techniques, analysis of limitations,
			future work...)  Compiler part can be more academic, and include some
			justifications of other design decisions.
		 -- System maintainers.
		 -- People retargeting the compiler.
		 -- People bringing up the system in a new environment.

		Sys arch part:
			Package + file structure [system.txt]
			system building [compiling.txt]
				bootstrapping & cross compiling

		Compiler design:
			Overview (mirror structure of rest of the part)
			ICR data structure
			Front end [front.tex]
			Basic VMR data structures (no back-end stuff)
			Middle end [middle.tex]
			Back end + data structures [back.tex]

			Error system interface
			Source tracking

    		maybe include significant entrypoints, to ease following the code from phase to phase

			mv icr docnode under front heading
				maybe, icr docnode seems to overview general use of icr
				maybe mv vmr node up instead

		Compiler retargeting:
			VM definition concepts [porting.txt, mail.txt, retargeting.tex]
				SCs, SBs, primitive-types
			Defining VOPS
				time specification
			defining
			and using the assembler
			Required VOPs [internal.txt, lowlev.txt, vm.mss]
			Standard primitives [vm.mss] (broken down by type, parallels object format
			section structure.)
			Customizing VMR conversion
				multiple hardware
				constant operands
				VM specific transforms
				special-case IR2 convert methods

		Run-time system:
			type system
			info database
			Data format [object.tex]
			Debugger:
			Info format [debug.txt]
			Stack parsing [debug.txt]
			Breakpoints
			Internal errors
			Signals
			Memory management: [William]
				heap Layout
				stacks
				GC
			misc implementation stuff: foreign call, assembly routines [lowlev.txt]
			LDB and low-level debugging
			core file format  [William]
			fasl format [fasl.tex]

* interface

    kbrd macros (== interface (ie buffer,windows,bindings)) like another language (as in way of describing)
		merge with lang,interface somehow?
		these are translated into lisp and input sequences

* parser defparser

consider implementing the reader with defparser
cmp w reader, byacc
	maybe good token-based version/option
		(ie parses only tokens sep'd w whitespace)
speed
	*marks* optnl
	create node afterwrds?
	boyer-moore?
backw
use in dired search
Srch [R]  case  c-u? (for hidden files) c-uc-u? then for hidden,case? c-uc-uc-u?
	  what about backup files?
	  maybe c-u results in prompts for all of these
		  fold case, search hidden, search backup
:alphanumeric,:char
	maybe just require caller to implement always
		slower
			then improve generation

* compiler

why must the ~primitives be explicitly left to the compiler
    ie anything that immediately,only recurses eg c:numers.lisp byte'
	is it better to
        include a fuller implementation in the library and to
	    override definitions in the compiler where necessary?
		    eg the ldb-test source transform could be the def in code:numbers.lisp
            maybe for overriding the idea is that the library knows better
				maybe hindered by catering for many compilers?

		seems def-source-transform in c: means inlined

    related to reducing the ~lang to one or a few primitives

defclo
   how to name let vars in the function?
       #gn generates a unique symbol (at read time?)
		   (let* ((#g1 ,arg1)
				  (#g2 (+ #g1 4)))
			  (incf #g1 ,arg2))
   how to handle multiple args eg once-only?
       should the arg parsing,manip be coded as runtime behaviour
           so the once-only (if (null.. is part of the rest of the fun defn
		   could the compiler then "expand" (partially evaluate) that code at compile time,
             given that the arguments can be evaluated once at compile time?
			   maybe it would help to describe what the args should be
				   (once-only ((specs &many (var value-expr)) &body body)
				   other langs (maybe ml) define functions multiple times
                       (def once-only (() &body body) ...
                       (def once-only (&many (var value-expr) &body body) ...
   more similar? general case?
   downside hard to see arg-processing code vs resulting runtime code

** err when compiled?

(defun replace-newlines (string)
  "Replace newlines in $string with spaces and return $string."
  (loop for ch across string for i = 0 then (1+ i) do
    (if (char= ch #\newline) (setf (char string i) #\space)))
  string)


* language,library ideas,notes

	rename lang  lisp too close to list  ni? nish?

	consider renaming funcall to call
	    maybe call means call to c/foreign

	reconsider #'
		syntax must be as simple as possible
			even a small thing like having to sometimes add # on the front of a symbol (and '(lambda..))
			  is another weight on the programmer
		can tell from context?

    applicative  reconsider

    to-file
	(defmacro to-file ((pathname FIX args append?) &body body)
	  `(with-open-file (*standard-output* pathname :direction :output)
		 ,body))

		*standard-output* synonym  *stdout* *out* out *o* *o
			ok 'cause most functions assume stdout

	consider making all forms readable, eg string-table, already so?

	return-buffer  i.e. return the space to the space manager
	return-function

	    kinda clashes with
			(return-from ..
			(return)

			release-buffer
				too much like software release

	consider with instd of let
		to match with-* macros

    hil is latin for true  false? is false required?
	how bout just n/f? (like t)  or () which already works (usually for lists)
	why scheme uses #t #f? easier to spot? frees the symbol?
	what does lojban use?
	(~complement (page-large-object-p first-page))
	for
	(if (page-large-object-p first-page) nil t)
	  {now (fi (page-large-object-p first-page))}
	(- all true)?  (- all all)

	"is set" instead of "is true"
	consider love,clear for ()

	(setf v)  should clearf v

    (>< (<>  (greater-than-or-less-than
    epsilon, zero   list terminator, end, false   always, forever, ever

	recycle instd of delete,remove
		add to trash, recycle trash

    always, multi-return-protect, <throw-protect>, always-after
      instead of unwind-protect

	how to return from a lambda?  (return-from ?)
	add (return) to ret from current fun?
		ie implied (block () ...) around function body
	maybe a way to refer to current function
		(return-from (this) t)  ; (return t) would return from a love block
			this this-function this-block

	assoc=

	eq take multiple args

	case-folded string  (string= {variable:} "Variable") => t

	prhps (' instead of '  and (` instead of `  and (, instead of ,
		ie make syntax totally regular
		what about #? (# ?
		also (" string with spaces) for "string with spaces"?
			maybe #"string with spaces"

	change let to be like let*
		(let ((a 1) (b a))        old  (let* ((a 1) (b a))
	    (let ((b a) (a 1))        old  (let ((a 1) (b a))
			side-effects may require the order

	;; two ways the same, due to t,f?
	(if  (if a (eq a b) t)         d)
	(if  (or (eq a nil) (eq a b))  d)

	eq char= string=
	eq char-eq string-eq
	= char= string=

	consider a let-replacing push,pop, eg
		(push (read-line in))
		(if (top) (write-line (pop)))
	  with compiler optim equiv to let
	  maybe  block ends clear any excess pushes, and excess pops an error

	how to eval the first , with the first `
		``(a ,(b) ,(c))

	"value" instd of "object"  eg db.lisp  find-object
							   tty-display-object

	destructuring-bind  split-bind?  bind-many?  multi-bind?
	multiple-value-bind  *let?  mlet?  multi-bind?  *with?  with-many
		(let (((a b) (fnc-w-multi-ret))) body)

	(defmacro split (sequence &rest separators &key start end)
		seems nicer than reqring seqarators to be a list
		only gives "odd num of kwrds" error

		consider &-- as in shell options
		   (f :key1 a :-- :key1 arg2)  ; 2nd :key1 just an arg
		   keywords seem like infix notation

	nesting strings
		{string with {nested string}}
		"string with \"nested string\""

		{string {sub {nested} first} end}
		"string \"sub \\\"nested\\\" first\" end"

	might be useful if <,... returned the first arg
		(or (< (file-size pathname) 99999)
			">9999")

    keyword as func name?  (:f arg)
	maybe epsilon function name, eg ( arg arg2 :keyword val), (:keyword val)

    ;; FIX logand  bit logic (vs maths logic)  (maybe bitand instead?)

	keyword args
		should be let-bound specials instead?
			performance?
				maybe possible to optimize into lex binding in most cases

** conditionals

	does `when' have meaning separate from `if'?

	maybe indent when,if the same

    if+,i+,*f instd of when? or+,o+,*r instd of unless? (like let*) maybe if*,or*
	   these look like arithmetic ops
	(when a b)
	(a a b)      ; a for and, maybe and*, an*, a*  ..+ ..1

	(fi x) == (fi x t) == (if x () t)
		(if x) == (if x t) == t
		(if)   == (if t) == (if t t) == t
		should the lang use all the combinations of ~parts?

	(fi x (a) (b)) == (if x (b) (a))
	(fi x (a)) == (if x () (a))
			   == (or x (a))
	(f1 x (a) (b)) == (or x (progn (a) (b)))
				   == (o1 x (a) (b))
	(1f x (a) (b)) == (if x (progn (a) (b)))
				   == (when x (a) (b))
	               == (and x (progn (a) (b)))

		consistent conditional syntax
			and, if, when                 a* ao a1        and if and*
			or, fi, unless				  o* oa o1		  or fi fi*
					either, nehw (when backwards)
			cond
			case

			(xx a (a) (b))

	(when a b)   (nehw a)

	(unless a b)
	(o a b)      ; o for or, maybe or*, o*  ..+ ..1
	(cond (a b) ((..) c) (t d))
	(or* (a b) ((..) c) (t d))

	(if a b c)
	(a (o a c f) b)   ; a and, o or, f false
	     ;; FIX how to return the c?
	     (a (o a (values f c)) b)   ; a and, o or
					; f ends a which rets 2nd val (c)
	     (a (eq (o a c) c) b)   ; a for and, o for or  if eq rets val
	(and* (a b) ((..) c) (t d))  ; like cond, tests each case
				     ; rets ~ multiple
	(or* (a b) (t c))

    replace if w cond?
    (if x a b)  (cond (x a) (t b))  (cond (x a) b)  (if (x a) (t b))

	replace and w if?
	(and a b c)
	(if a (if b (if c c)))  c evald 2x

	replace if w and?
	(if a b c)
	(or (and a (progn b t)) c)

*** case, typecase

  (case a
    ((1 2) 3))

    whereas

  (typecase a
    ((or string pathname) 3))
      ^^

** iteration looping repetition

    (while () () body)
    (while () symbol body)              (while () t body)
    (while symbol-other-than-() body)   (while t body)
										then expect (while (car x) body)

	(do () ((eq end t)))
	=> (while () (keep-going return))
    or (wh () (keep-going return))

	(<inverse-of-do> () ((eq keep-going t)))
	=> (until () (end))
    or (un () (end return))


	recursion, tags (jumping)
		in scheme is all iteration via recursion?

	do-*
	recursion labels iterate
		tail recursion
	map*
    loop

	can map* be equivalently replaced by other loop construct?

	do* should be do-*?

	replace do w modified loop? (and rename loop do)
		~ scheme uses heavy recursion
			labels, iterate
		c: uses loop eg srctran.lisp
	(do ((for x t :then f)        ; (let i 0 f)
	 (for i 0 :to 10 :count)  ; (let i 0 :to 10 :count)
				  ; (let ((i 0 10 :count)))?
	 (while x)
	 (return t))
	   body)
	(do t body)  for  (loop body)
	(do (for x 0 10) body)      (do (x 0 10) body) (do (:list list)
	dolist?  is it right to have per-type iteration?
		 (do ((for ele :in list)) ...)
		 (do ((list ele list)) ...)
		 (dolist (ele list) ...)
		 (do ((list list)) ...)  elements bound to var $ or $_ $1
		 (do (list list) ...)    elements bound to var $ or $_ $1 $A it
		 (do ((:list ele list)
			  (index 0 (1+ index)) ... )
		 (do ((:list ele list)
 			  (:times index 0)) ... )

** format, strings

	string special is /  "ab\"c\"" => ab"c"
						 "ab\n" => abn
	format special is ~
		should be same?
		string should allow more special chars, like newline?

	format strings are like another language
		(format () "x: ~A and y: ~2D, ~@[(y < x)~]" x y (> x y)
	  could use lisp instead
		(format () "x: " x " and y: " (D y 2) ", " (if (> x y) "(y < x)"))
	  even in the string
		(format () "x: ~x and y: ~(D y 2), ~(if (> x y) \"(y < x)\")")
		(format () "x: ~x and y: ~(D y 2), ~(if (> x y) '(y < x)')")    special '
		(format () "x: ~x and y: ~(D y 2), ~(if (> x y) "(y < x)")")    reader string parsing


		(format "int: " (D i) ", any " (A var) ", " (A var) (%)
				"looping: " (loop for i in '(1 2 3) do (D i) (A ", ")))
															 ^^^^^^^^sux

		(format "int: ~D, any ~(A var), ~(A var) ~%
				looping: ~{'(1 2 3) (D $) (A ", ")})

		(format "int: ~D, any ~A, ~A~%looping: ~{~D, ~}"
				i var var '(1 2 3))

			seems like current format style will always be neater

				are there other novel styles?

    add (format nil "x: ~$x")   ; like (format nil "x: ~A" x)     ; similar perl
        (format nil "x: ~$S$x") ; how to ~S like above

** evaluation, macros

    deflaz  (think lazy may usually mean evaluated, just as late as psbl)
	    (whereas these args are optionally evaluated)
	    deftrans defmacro defun2 defclosure defclos defcl define def
	    defspec defsf defsp
	    defclo

        name all such functions similarly
	at least highlight all same (as special forms currently highltd)

	+ ability to pass these functions around

(deflaz when (cond &rest body)
   (if ,cond ,body))

(deflaz eval (form)
   ,form)

(deflaz when (cond &rest body)
   (if (eval cond) (eval (cons 'progn body))))

(defmacro when (cond &rest body)
   `(if ,cond (progn ,@body)))

(defun a (b c d)
   (,b c ,d))       ; evaluates d "twice", evaluates b to produce the function name/symbol

(declaim (inline when))
(deflaz when (cond &rest body)
   (if ,cond ,(cons 'progn body)))    ; evaluate cond "twice", eval result of eval of (cons ...)


** handlers

  1 (handler-bind ((editor-top-level-catcher #'identity))
    (catch 'editor-top-level-catcher
    (signal 'editor-top-level-catcher nil))
    (throw 'editor-top-level-catcher nil))

	     (block ed-x
	       (handler-bind
	           ((editor-top-level-catcher #'(lamdba () (return-from ed-x)))))
	         ...
	         (signal 'editor-top-level-catcher nil)...

	      s/b~

	      (catch-condition 'editor-top-level-catcher
		...
		(throw ~(make-condition 'editor-top-level-catcher) nil)...

	should be able to catch,throw conditions?
	and signal symbols?
	    then maybe replc throw w signal
		throw returns the stack to a catcher
	          whereas signal just runs the handler code

  2	(handler-case
	   ((a () ...)
	    (b () ...))
	  form*)

	    so that cases at top like handler-bind
               and can have many forms in case (form*) instd of one

;; FIX handler-case seems to be run after stack returned
;;       (whereas handler-bind runs with the stack at the point of error)
;;       eg have to handler-bind around %command-loop in ed to get backtrace

	  so makes sense to have cases afterwards

  3  why handler-case handlers form* while handler-bind handlers functions?

** type conversion, dynamic typing

  (+ 4 "5")
  	  should the 5 perhaps be read from the string automatically?
		  is an attempt at some sort of behaviour better than
			an error for every case?

  (defun f (a b)
	(declare (int b))
	...)
  (f 1 "2")

  consider reducing type specification eg prefer equal to char=,string=

  should 1 be always eq 1?  (vs equal)
	  ie should the integers only be considered eq if they are the same instance
	  how does that fit into a clean system?
	  is there a case for integer instances?
	  should there be instance comparison at all?

  created struct node  want car to work on node
					   and strings,vectors...

** modifying existing functions,macros in packages optionally loaded

modifying for eg for type-specific behaviour

  eg do-lines macro loops over every line in stream

	  in ed must loop over every line in buffer if given buffer

		  pass buffer as stream

** streams

  search in streams   (search "foo" stream)  ;ret pos?
					  (find #\a stream)      (find "aa" stream)?
					  (position #\a stream)    "
					 some optns may be hard/weird, like :from-end
	  ed buffer operations ~duplicate this (for buffers)

** parallel processing, multitasking, concurrent light weight processes

mentioned in comment under Scope and Purpose in [VM Introduction]

	;;;; consider
	;;;
	;;; want things to run at the same time, and to share variables

	(let ((*test* 2))
	  (parn
		(progn
		  (setq *test* 3)
		  (ed:message "*test* is ~A in orig" *test*))
		(progn
		  (format t "*test*")
		  (sleep 1)
		  (ed:message "*test* is ~A after 1" *test*)
		  (sleep 3)
		  (ed:message "*test* is ~A after 3" *test*))))

	(parn
	 (%command-loop)
	 (timer-handler))


	;;; implemented as
	;;;
	;;; schedular  timer interrupt
	;;;  single mem space
	;;;  light weight processes
	;;;    lisp context  lisp stack? bindings?
	;;;    par splits a proc into many procs
	;;;      bindings before par shared

  vs mp processes (:src/tests/lisp/mp.lisp)

* building

- even older building
ensure build/lisp links are right and doc'd
should be features.lisp somewhere

clear function binding of a symbol how?


* editor

** first

public domain

copy from work to aon and back only transfered distrib files
  eg interface,motif left in :src/nightshade.work-pre-aon-2007-01-02-merge/

read-file /mnt/mattm/cspcz..list2
check write-file big eg /mnt/mattm/cspcz

directory :absolute
 * (in-directory ":tmp/" (directory "z/"))
 (#p"/home/mattm/temp/z/a" #p"/home/mattm/temp/z/b/")
 * (in-directory ":tmp/" (directory "z/" :truenamep ()))
 (#p"/home/mattm/temp/z/z/a" #p"/home/mattm/temp/z/z/b/")

** treats

flesh out code:shell.lisp
cd to dir, rm that dir, start
diary c-m-a,e move to prev,next entry
finding (defun lisp::do-do-body
intern todos below  Simpler Items
list keyboard macros

** nb for work

    mail
		mail to prompt
		work reply-to,from when re work
			rply  depends on  folder of msg, sender
			send  depends on current network
	cvs, svn
		 cancel during commit
		 which have been updated?
		 update single line
		 ~ refresh on file write ~hook  (to show mod)
		 conflicts?
	cmp highlighting
	compile  hi   rtio/uspace.h: In function...    hilights too much
				  err on certain output
	         goto ref w multiple files (seems ~ only goes to one)
				 works for simple :src/test eg
	way to work on remote machine  ssh edit,dired + remote cmds
		/home/mattm/a:xx   when in /home/mattm/ dired error trying to ftp to host "a"
		lisp slaves?
		root@thoth:/etc/cfengine/cfagent.conf  ; user,absolute
		(run-program "ls" :host gateway)       ; ssh
		(run-program "//gateway/usr/bin/ls")   ; ssh (absolute?)
		(run-program "//gateway:ls")           ; ssh (relative to user home)
		(run-program "//gateway!ls")           ; ssh (relative to gateway PATH)
		(run-program "ssh://gateway//x!ls")     ; x via gateway?
		--
		//root@thoth/etc/cfengine/cfagent.conf   ; absolute
		//root@thoth:cfagent.conf   ; relative
		:cfagent.conf               ; relative to local user home
		//root@thoth!cfagent.conf   ; relative to thoth PATH
		ssh://thoth:cfagent.conf    ; explicit protocol, relative to user home
		http://machine.domain/f.ext
		ftp://user@x/file.ext
		etc;AUTHORS 				; search list
		//thoth/etc;AUTHORS 		; search list on remote machine
	terminal interface
	auto-switch to root with confirm
	some way of merging work dir to home dir

** vaguely ok for everyday work for an experienced (probably emacsen) user

stability

dired hang when negative (? arg?)
add remote directory
err in minib splits minib
locate  c-g before cmd finishes
flush-t-w option buffer,mode
dired versions  eg :src/mh/mh-6.8.3
mail XXX
	# first on line in mail body
    assure mail in via log? log buffer?
    need better drafts,trash releasing system  maybe rm if ,,,, or higher
	searching in headers buffers
      control-r,s
    control-l in headers buffers  fetch more
	send with correct timezone
	www parts/whole  www bindings (www minor mode?)
	complet
		with pnt directly after "To:"
		hard to just write a space, maybe tab / alt-spce / alt-enter to complet
    when refresh and empty must clear old msgs (~?  eg send last draft)
		could rotate buffers or show empty buf
    edit draft, open another, edits gone
		ok if save, buffer still gone (~reused?) save save (?)
			prompt to save old one?
    c-g during send  draft gone
	imap
	clean older tests (mh:with-fresh-state)
Auto Inflate Files
	similar Content-Type: text/enriched
		eg /home/matt/doc/retrospect/year-level-overview
	maybe read,write filters according to content type
		File Type Handlers  (where the translation is before read and after write)
								rather translate to a temp file
			;; similar list already in dired bound to z
			(("Z" compress-read compress-write)
			 ("gz" gz-read gz-write))
		Content Handlers  (where the translation is after read and before write)
			(("text/enriched"  ;; mime name, as in mh attach handling
			  . convert-enriched))
www interface
    forms, anchors
info readers
    err when call next ref in leaf node buffer
    index, goto node, searching, menu
many lang modes  asm (pd egs), forth, shell, changelog, tex
    indent
    context highlighting
	fill
	sg,x,html
		indent  skip over tags in comments
		        <tag/>  xml?

backup to isp  prhps tramp-like
    pd ftp info/sw
    ftp://user@x.domain/
    (pathname "user@localhost:/")
    (read-file (pathname "localhost:/") (current-point))

** more

mail
  	incoming mail filtering
	headers  threading
	tests  smtp,pop  :tmp/mh
    #forw [] +folder 1 22
SIGWINCH
backspace,rubout  x,term
m-x Tail,Head  related replacing shell
    maybe just handle via buffer  (ie buffer only loads what it needs from disk)
	account for code:shell.lisp  maybe same name and same pipe mech
when file created switch to mode according to type
vc comparison  g to update
buffers with () names  should be able to kill with control-x k
top level domain commands
finish easy way to transfer addns
    manifest  fetch remote  merge
    merge version stamps instd of time stamps
sometimes diary ckp to 0 size (think maybe from show-diary-entries)
dired file type  y   chown
ed:: msg  (format t "...")  (f t "...") (out "") (err  (mess
(defun test () "doc string") should return ()
xterm, linux console, check rxvt
Search  flag to search inside compressed files
ascii.lisp  highlighter
when doc reader macro is compiled ~ set file relative to target:
    instead of relative to truename
M-x M-x  Editor Eval   M-x M-x M-x  Shell Command   wraparound
    first recursive Ext Cmd (and Ed Eval)
tab width (aka for spaces per tab)
Shell Command  completion
top-level index
   Main (main?)
   /             dired the root of the filesystem
   home:         dired the home of the current user
   info          read documentation, help    (rename away from info)
   packages      browse installed packages
   config        configure
   app menu      shell, root shell, www, mail, netnews, help, ftp,telnet,smtp,
				 irc,im, games,
				 contacts, calendar, bufed, sys proc ed, diary
	             (packages install to here)
   ~desktop?     use ~/Desktop/?
   recent documents, apps
menu  config (like variable persistence)
improve irc
maybe jabber
may need sftp at some point
Edit Editor Variable Definition
	perhaps a transform on defevar that adds: (setf (variable-source 'spaces-per-tab) #pt)
		(defun e2 (a b) (if (> a 3) (+ a b) (- a b)))
		(c::defknown ed::e2 (a b) t)
		(c:deftransform ed::e2 ((a b) * * :when :both) '((progn 3)))
editor inspection with stepping
  goto source of call to byte,interp func
fullscreen mode (only the buffer, hide minibuffer and mode lines)
dired c  cp to new dir  when old dir children symlink to old dir  :tmp/a -> :tmp/a2
list matching lines is much like search  ~ make consistent
drop :value nil
replc (current-directory uses w ~ buffer-pathname
hi other occurences when query replace
	maybe also mode for hi all occurences when hi-marked
fill
key-event,keytran  to code:	  also spell pkg? (~spell*.lisp)
only append kill if very next cmd
	catch case
$ /usr/local/bin/ni filename   should open filename? vs nightshade rqrs -edit
	ne
ni man pg  weird chars
           update date,version with version
auto filling that adjusts to leading indentation
	(ie if 1st 2 lines of para indented same for rest)
equiv socat
equiv shell |
	streams, using easy with-* macros?
		with-open-file  to-file  from-file  to-from-file?
        shell does  function | function
					function > data,storage(,function?)
	generic user interface
		find $A -name \*.lisp | xargs du -ch | grep "abc"
			lisp:
			 m-x: list/group files | Disk Usage | Search Result
		find . -name a\*.c | xargs grep "abc"
			~Group Search
		the buffer is the stream, mayb use an implicit buffer or (current-stream)?
man  buffer name "Man Page name number"
macro doc in c-hf  eg defconstant
also auto set buffer package accordingly if defpackage first form in file
meta-ctrl-x revert
render line jump when switch win with trailing space on line
u straight fs ops in dired for relative dired-file pathnames
	eg "Copy File"
Buff Changes  "also contains" msg
			  always use disk version (instd of ckp)
lock file with symlink when modified?
rotate buffers  sometimes seems to rotate forward when should be back
					maybe after find file

mv to location of revert when reverting
Byte Compile commands
set buffer pkg  completion  would only work if package existed  optn completion?
(setq *error-output*
      (make-editor-output-stream (buffer-end-mark edi::*message-buffer*)))
naming
	edit sys procs
	edit dir
	find file		   edit file
	edit packages
	find-object        edit-value?
	browse folders
	manage packages
spell  i insert into personal dict permanently
c-uc-f /home/matt/src/nightshade/build/lisp/lisp:
sometimes "bad address" on build
	and on slaves
isearch
	history
	c-l during stays in search
bufed  ~ improve layout ~ long lines
       keep posn on refresh
cmp  finish dir cmp
	 show line numbers
	 highlight
	 enter go to source
	 n,p mv across compared sections
	 slow for big file
	 split into function
	 add tests, styles
font  keep underlining when next font (how to end?)
c-g in  macro def?
list processes  enter goes to process (ie proced)
+ interface to vm:memory-interface  (crashes on :dynamic)
compare defparse "algo" w byacc
multiple revert  buffer history
    similar  cvs, sys trace tool that goes backwards
archive viewing,editing mode  part of dired
auto save directly to file  related files as vars
Describe Variable c-h g (g for global) (s for special?)
goto var def  meta-g v   goto special var?
dired  mv,cp adjust existing buffers, offer to mv,cp bak,ckp
       slow  eg /home/matt/Mail/archive/misc/  anything w many files
       recursive D
       /home/matt/src/nightshade/src/ed/*.lisp
           (file-write-date err in init-dired-buf)
               dired built for single entity pathname
                   dired w pattern does pattern
--
correct :line,% redisplay
    prhps redispl should check if modeline has changed?
recursive extended cmd
repeat last cmd  C-z z*
vc interfaces
	darcs, subversion, trac, git, hg... as required
    retrieve prompted versions
    annotate
    dired  show only  files under cvs, ~ files w status
www
    fetch,render in bg  (www slave(s)?)
dired  keep point on file column
       Dired Search could be Group Search
	   	   maybe dired buffers could define a group
       [Dired] Search/Find [Recurs]    + with Pattern
lisp find expressions like mh pick exps
   ;(or (name ".*\.lisp") (search "foo"))
   (or (name (many :char) ".lisp") (search "foo"))
   (or (name (* :c) ".lisp") (search "foo"))
   ;(or (name ".abc") (search "foo"))
   (or (name :c "abc") (search "foo"))
mail  attach file  suggest type, type completion
      auto address to .db
	  cleanup resend msg  eg should it add all the orig headers?
	  cleanup,finish mime parsing
		  other types of attachment encoding
	  exit recursive draft edits when send
native web browser
	start with http retriever
    need frames?  maybe like generaliz of emacs header lines
	need widgets?
	about:  goes to ~[ About ] [ Introduction ]
    generate parser defn from dtd,schema?
chars like £ (pound sign)  these (at least pound) work in emacs
	unicode?
	utf-8

clear out FIXes

introduce single window, stick echo area prompt to bottom of window,
  always prompting, prompt with current directory like shell (dir could be long),
  brighten prompt when in echo area, mv echo area to top, move modelines to
  top, rename echo area (prompts and echoes, "area" ~redundant)

	Welcome to Nightshade.  This is the Echo Area window.  The last line in
	the window is prompting for a command.  All system messages appear in
	this window.

	The command Help (bound to C-h) switches to the help prompt.  Entering
	t at the help prompt enters a short tutorial.  Entering i at the help
    prompt brings up full documentation.

	When the screen is split, for example when visiting the first file, the
	Echo Area window is set to a fixed size.  The command Extended Command
	(bound to M-x) switches to the Echo Area Window and moves to the
	prompt.

	Arbitrary Lisp expressions can be entered at the prompt instead of
	extended commands, by preceding the expression with a `*'.

		merge the programming language, command line, visual interface

mv forward in mark history (forward history cleared on marking)


** Bill and/or Rob.

Probably the ERROR for trying to modify a read-only buffer could/should be
an EDITOR-ERROR.  Maybe the error message should be an editor variable that
can be set for certain buffers or modes.

Make definition editing different.  Maybe only one command that offers some
appropriate default, requiring confirmation.  Maybe some way to rightly know to
edit the function named under a #'name instead of the function name in a
function position.  Think about whizzy, general definition location logging and
finding mechanism that is user extensible.

Think about regular expression searching.
   Importance: it would be used weekly by some and daily by others.

Make illegal setting window width and height, (or support this).

Think about example init file for randoms.  It should show most of the simple
through intermediate customizations one would want to do starting to use the
editor.
  setting variables
  file type hooks
  hooks
  transposing two keys
  changing modifiers

DEFMODE should take a keyword argument for the modeline name, so "Fill"
could be named "Auto Fill" but show "Fill" in the modeline (similarly with
"Spell" and "Save").
   Importance: low.
   Difficulty: low.

Get a real italic comment mode.
   Importance: some people want it, like Scott.
   Difficulty: hard to do right.

Line-wrap-character a user feature?  Per device?  Per device set from evar?
   Importance: a few people set this already for bitmap devices.
   Difficulty: low.
   Bill should just throw this in.

When MESSAGE'ing the line of a matching open paren, can something be done to
make the exact open paren more pronounced -- SUBSEQ'ing the line string?
   Importance: low
   Difficulty: one line frob to major echo area changes.

Do something about active region highlighting and blank lines.  Consider
changing redisplay to be able to hack some glyph onto the line, a virtual
newline or something.
   Importance: blank lines at the ends of the active region can be confusing.
   Difficulty: unknown difficult changes to redisplay.

Change redisplay on bitmaps to draw top down?  Currently line writes are queued
going down the window image but the queue is written backwards.
   Importance: low, two people commented on how it looks funny.
   Difficulty: unknown, but probably little.

Disallow tty I/O when the tty is in a bad state.  Since editor is sharing
Unix standard input with *terminal-io*, doing reads on this is bad among
other problems.
   Importance: necessary for non-experienced users.
   Difficulty: slight.  Error system wants to use *terminal-io* if you go
               into a break loop from the editor.
   Bill.

Make Lisp indentation respect user indentation even when in a form with known
special arguments?
   Importance: noticeable correctness.
   Difficulty: Lucid wrote this already with LOOP macro.
   Rob.
Make Lisp motion that exceeds the parsed region lose more gracefully by
informing the user, possibly offering to enlarge the parsing parameters.
   Importance: very deceptive as it is currently.
   Difficulty: ???
   Rob.
Lisp motion fails to handle correctly vertical bar syntax; for example,
      package:|foo|
   Importance: correctness, not too necessary
   Difficulty: ???
"Editor Evaluate Defun" does not handle multiple value returns correctly
... if we admit that this is often used to evaluate non-DEFUN top-level
forms.
   Importance: user convenience.
   Difficulty: low.

Super-confirm select buffer.  Super confirm means "make this be a legal
input".  Has no interaction with prompting function interface.  More
generally, make a *super-confirm-parse-function* that can be bound around
prompters.  One suggestion when prompting for a buffer is to make it, but
another suggestion is to find file some appropriate file.
   Importance: multiple people requested.
   Difficulty: low.
   Bill.
A super-confirm for a more facist "Find File" that disallowed creating buffers
when the file didn't exist could tell the command to really create the buffer.

Displayed-p shouldn't directly call update-window-image, or perhaps uwi should
be changed to check if the ticks and whatnot indicate recomputation is needed.
   Importance: minor efficiency hack and maybe a little cleaner.
   Difficulty: low.
   Bill.

Fix line-length for editor output streams.  The following example causes lines
to break incorrectly in "Eval" mode but not in "Typescript" mode:
   (defun dup (x n &aux r) (dolist (i n r) (push x r)))
   (dup 'a 100)     ;lines wrap due to faulty line breaking
   (dup 'aa 100)    ;lines wrap due to faulty line breaking
   (dup 'aaa 100)   ;now lines break correctly
   Importance: correctness.  It's not screwing anyone.
   Difficulty: depends on what the right thing is.

Termcap bug:
   setenv TERMCAP "foobar:li#65:tc=vt102:"
   set term = foobar
This causes an EOF unexpectedly on the string stream.  This is because the
the termcap parsing stuff wasn't written to go all the way back to the top
entry point to determine what file to use when the TERMCAP variable had an
indirection.  The code currently just goes to the beginning of the stream
and looks for the new tty name.

Make prompt text not part of input buffer.  Do some magical thing to solve
the problem of having special echo area commands that simply get around the
prompt text in the echo are buffer.
   Importance: low since problem is currently somewhat taken care of.
	       Possibly resolve problem when new editor environment stuff
	       goes in.
   Difficulty: Magical in origin.
   Rob.

Commonify everything.  Make everything portable that could be made so (file
system extensions, character att. finding, string ops, etc.) and document
our expectations of the non-portable stuff we lean on.  Provide portable
code for stuff done in assembler.
   Some known problems:
      %sp- functions aren't documented and don't have portable code for
         them.
      semantics of initial values versus declared type.
      :error-file to COMPILE-FILE calls.

   Importance: cleanliness and portability ease for those who want our
	       code.
   Difficulty: identify the problems and alter some code.
   Bill and Rob.

Fix things that keep text from getting gc'ed.  Buffer local things keep
pointer to buffer.
   Importance: could be important, maybe nothing is wrong.
   Difficulty: identifying problems.
   Bill or Rob.

Two reproducible window image builder bugs:
THIS IS NUMBER ONE:
I wrote this command:
   (defcommand "Fetch Input" (p)
     "Does \"Point to Here\" followed by \"Reenter Interactive Input\"."
     "Does \"Point to Here\" followed by \"Reenter Interactive Input\"."
     (declare (ignore p))
     (point-to-here-command nil)
     (reenter-interactive-input-command nil))
I made the following bindings:
   (bind-key "Fetch Input" #\hyper-leftdown :mode "Eval")
   (bind-key "Fetch Input" #\hyper-leftdown :mode "Typescript")
   (bind-key "Do Nothing" #\hyper-leftup :mode "Eval")
   (bind-key "Do Nothing" #\hyper-leftup :mode "Typescript")
In an interactive buffer I typed hyper-leftdown twice on the same line and
got the following error:
   Error in function HEMLOCK-INTERNALS::CACHED-REAL-LINE-LENGTH.
   Vector index, 14700, out of bounds.
This index is always the one you get no matter what line of input you try to
enter twice.
;;;
THIS IS NUMBER TWO:
Put point at the beginning of a small defun that has at least some interior
lines in addition to the "(defun ..." line and the last line of the routine.
Mark the defun and save the region.  Now, yank the defun, and note that the
beginning of the second instance starts at the end of the line the yanked copy
ends on.  Now type c-w.  You'll delete the yanked copy, and the lines that
should not have been touched at all end up with font marks.  Interestingly the
first line of the defun and the last don't get any font marks.
   Importance: well, they are reproducible, and they're pretty ugly.  No one
   	       has noticed these yet though.
   Difficulty: Rob and I didn't conjure up the bugs after a casual inspection.
   Bill AND Rob

Consider a GNU-style undo where action is undo-able.
   Importance: low, but people point it out as an inadequacy of the editor.
   Difficulty: possibly very hard.  Have to figure out what's necessary first.
   Bill and Rob


** Mailer

Find all message-info-msgs sets and refs, changing them from possible list
values to always be a simple-string value.  Maybe must leave a list (or make
another slot) if I need to indicate that I can't use the value as a msg-id.
The only problem is coming through SHOW-PROMPTED-MESSAGE.  This could pick or
something to really know if there were more than one message or not.

Write "Refile Message and Show Next".

Add more folder support and possibly something specific for Bovik groveling.
For example, rehashing the cached folder names and/or adding new ones from a
folder spec or root directory (allows adding the bovik folders).

Consistency problems:
   Expunging message should not JUST delete headers buffers and their
   associated message buffers.  There could be independent message buffers with
   invalid message id's.  Since these are independent, though, we might not
   want to gratuitously delete them.

   "Headers Delete Message" should check for message buffers when virtual
   message deletion is not used, deleting them I suppose.  Instead of just
   making headers buffers consistent.



** Spelling

This stuff is probably for Rob or Bill, but think about undergrad
dispatching before actually implementing it.

Two apostrophes precede a punctuation character, as in:
	``This is a very common occurrence in TeX.''
"Correct Buffer Spelling" complains that '' is an unknown word.  The problem
doesn't show up if the character preceding the apostrophes is alphabetic.

"Correct Last Misspelled Word" should try to transpose the space on the
ends of a word if there are more than one misspelling (adjacent?).  This
would have to be done at the command level trying to correct different
words formed from the buffer.

Fahlman would like to see a list of words that are treated as errors, even
though they may be in the dictionary.  These are considered common typos made
that actually are rarely-used words.  These would be flagged as errors for the
user to do a conscious double check on.

When the spelling correction stuff cannot find any possible corrections, it
could try inserting a space between letters that still form legal words,
checking the two new words are in the dictionary.
   Importance: possibly pretty useful, especially with "Spell" mode.
   Difficulty: low to medium.
   Bill, possibly undergrad after I looked at it.

Fix "Undo Last Spelling" correction interaction with auto-fill.  When this
command is invoked on a word that made auto-fill break the line, shit
happens.
   Importance: Rob noticed it.
   Difficulty: unknown.
   Bill or Rob.



** User and Implementors Manuals

User Manual wall chart appendix based on systems (e.g., dired, mailer, Lisp
editing, spelling, etc.), then modes (e.g., "Headers", "Message", and "Draft"),
then whatever seems appropriate.


** Simpler items

Create "Remote Load File" and make "Load File" use it the way "Compile File"
uses "Remote Compile File"

Make "Insert Scribe Directive" undo-able, and make the "command" insertion
stuff use the active region.  Also, clean up terminology with respect to using
command and environment.
   Importance: it would be nice.
   Difficulty: little

Add a feature that notes modified or new lines, probably down in
EDI::MODIFYING-BUFFER.  Then add interfaces for moving over these lines, moving
over text structures with these lines such as DEFUN's, paragraphs, etc.  Write
commands that display these in some way, compile them, etc.

Look at open paren highlighting and the Scribe bracket table stuff to make a
general bracket highlighter.  Possibly have to call function based on mode or
something since Lisp parens are found differently from Scribe brackets (Lisp
parse groveling versus counting open and close brackets).

Make hooks that are lists of function have list in the name, so users can know
easily whether to set this to a list or function.
   Importance: low.
   Difficulty: low, but pervasive.  must be careful.

Make FILTER-REGION not move all marks in the buffer to the end.  It should
affect each line, letting marks stay on a line, instead of deleting the whole
region and inserting a new one.
   Importance: low, but described behaviour is better than current behaviour.
   Difficulty: low.

Make some "Auto Save Access" variable, so users don't have to write fully
protected auto save files.  Possibly there could be some variable to that
represents default file writing protection.
   Importance: one person requested.
   Difficulty: easy.

We need Lisp-like movement in Text mode -- skipping parenthetic and quoted
expressions while ignoring some Lisp syntax stuff.  Either can write a few
commands that do what we expect, or we can get really clever with the
pre-command parse checking and bounds rules for Text mode.  May even be able to
get the right thing to happen with code fragments in documents.
   Importance: would be pretty convenient to have it work right all the time.
   Difficulty: will take some thinking and playing around.  Rob or Bill guidance.

Add modeline display of current eval server and current compile server, when
appropriate.  FIX where is appropriate?
   Importance: suggested by a couple people.  Low.
   Difficulty: none.
   	       Basically, just have to change string and function.

Warn when unable to rename a buffer according to its file.  This occurs
when writing files. (?)
   Importance: more user friendly.
   Difficulty: none.
   Anyone could do this.

Make nested prompts work.
   Importance: some day this might be useful.
   Difficulty: medium.
   Upper level undergrad could do this.

Make character searches deal with newlines.
   Importance: correctness.
   Difficulty: medium.
   Upper level undergrad.

Put argument type checks in the editor primitives.
   Importance: low, the compiler should do this from type declaration
	       (cool?!).
   Difficulty: work in a lot of places.
   Undergrad could do the things Rob or Bill say.

Add a "Preferred File Types" to work in coordination with "Ignore File Types".
   Importance: low, suggested by one user.
   Difficulty: minimal.



** The great rewrite and cleanup.

Compilation order.  Cleanup up defvars, defevars, proclaims, etc. for clean
compilation of the editor in a Lisp without one.  Rename ED and EDI packages
and start cleaning up compilation.  Defvars should go near pertinent code,
and proclaims should do the rest.  Do something about macros, rompsite, and
main.
   Importance: necessary for those taking our code and sets better example.
   Difficulty: few days of work.
   Bill.

Ed package cleanup -- exporting editor stuff, so users don't live in
ED package.
 Find primitives to export and describe in Command Implementor's Manual.
 Export existing command names in a separate file.
 DEFCOMMAND always interns in current package.
 Variables
  One global table.
  DEFEVAR only at top level.  Interns into current package.  WHAT ABOUT SITE-INIT?
  BIND-VARIABLE, a new form, will be used at top level or in setup
   functions to establish default values.
 Find all uses of FIND-PACKAGE etc. since these are
  suspect in the new package regime.
 Put DEFVAR's (esp. from Main.Lisp) in appropriate files, putting PROCLAIM's
   in a single file or in files with compiler warnings.
      Importance: really needs to be done along with environment stuff.
      Difficulty: pervasive changes to get right.
      Bill!

    eg account.lisp has to (in-package "ED") instd of (use-package "ED")

    add funcs,cmds in hi, exporting reqrd funcs,cmds from ed
    eg so in at-point.lisp
	 number-from-point is exported from hi and number-from-mark
           is only used in at-point.lisp
  	 word-at-point is defined in ed and used in hi (at-point.lisp)
	     so must ed::word-at-point (since rplcd use of w-a-p)
	     word-at-point s/b defined in hi
	     (word-at-point-command s/b exported from ed)
	     should word-at-point be exported from ed
		 eg for user init file

Generalized environments:
  Generalize notion of environment to first-class objects.
  can inherit stuff from other environments.  Shadowing for conflict
  resolution.  Transparent key bindings another sort of interaction.
  If we retain modes as a primitive concept, then how do they interact?
  If not, how do we get the effect?  Each buffer has an environment.
  This is normally the composition of the default environment and
  various mode environments.

  Turning modes on and off is simply adding and removing the mode's environment
  from the buffer's environment's inherit list.  The only sticky issue is the
  order of the inheritence.  We could assign each environment a precedence.

  I guess we could punt modes as a primitive concept.  The only thing this
  wouldn't provide that modes do is a namespace and the major/minor
  distinction.  Setting the major mode is just frobbing the lowest precedence
  environment in a buffer.  A major mode is distinct from a minor mode in that
  it inherits the global environment.  An interesting question is at which
  level precedences should be implemented.  We could have it be a property only
  of minor modes, which determines only the order in which a buffer inherits
  its minor modes, or we could make it a property of environments, and have it
  determine the total order of inheritance.  Probably the former is better: it
  simpler, and adequate.  Also, at the environment level, it is more powerful
  to be able to specify inheritance order on a per-case basis.

  Make mode-hooks be a mode-object slot rather than editor variables.  [a
  random cleanup]

  We change the (... &optional kind where) arguments to
  (... &optional where).  Where can be an environment such as
  *global-environment* (the default) or a buffer, or it can be a string, in
  which case it is interpreted as a mode name.

  Instead of having key binding transparentness be a property of modes or of
  commands, we make it a property of binding.  Each environment has separate
  key-tables for transparent and opaque bindings, and there is a
  Transparent-Bind-Key function that is used to make transparent key bindings.
  [... or something.  This would imply a delete-transparent-key-binding and
  prehaps other functions, so we might consider passing a transparent flag to
  the primitives.]

  *current-environment* is the current environment, which is normally eq to the
  current buffer.  Attributes and variables are implemented using deep-binding
  and caching.  Whenever there is any change to the inheritance structure or to
  variable or attribute bindings, then we just totally flush all the caches.
  The most frequent operation that would cause this to happen would be changing
  a mode in a buffer, which is rare enough so that there should be no problem.

  For variables, we just have a symbol-name X environment => binding cache.

  For attributes we have two caches: attribute X environment => value vector
  and attribute X environment X test-function => search vector.  The first
  translates an attribute and environment to a simple-vector that contains the
  current value for each character in that environment.  This is used for
  Character-Attribute and when the Find-Attribute cache misses.  When this
  cache misses, we fill the vector with a magic "unspecified" object, and then
  scan up the inheritance, filling in any bindings that are unspecified.  We
  could optimize this by noting in the character-attribute object when an
  attribute has no shadowings.  character-attribute hooks have to go away,
  since they depends on shallow-binding.

  Make editor variables be typed.  Have a :type defevar argument,
  variable-type function.  In implementation, create a test function for each
  variable so that we can efficiently check the type of each assigned value.
  This implies defevar should be a macro.  We could make specifying the test
  function be an explicit feature, but the same effect could always be obtained
  with a Satisfies type specfier.

  Split binding of evars from definition.
      Bind-Variable Symbol-Name Value &Optional Where
  Creates a binding.  If :Value is specified to defevar, then it creates a
  global binding of that value.  If no :Value is specified, then there is no
  global binding.  We could flush the :Mode and :Buffer options, and require an
  explicit Bind-Variable to be done in this case, or we could still allow them.
  It would probably be better to flush them, since it would break code that is
  doing run-time defevars to make buffer-local variables.  Perhaps we would
  flush only :Buffer, since it is clearly useless, while being able to give an
  initial mode binding may be useless.

  All variable attributes except for value are global.  Hooks are global.  The
  concept of a hook is somewhat dubious in the presence of non-global bindings.
  It might be semi-useful to invoke the hook on each new binding in addition to
  on each set.

     Importance: Next big step for the editor.
     Difficulty: Two months.
     Bill will do this.

Multiple font support:
 Figure what kind of multi-font stuff we want to do.
 Bogus to use integer constants for facecodes.  It is reasonable within the
 font mark, but the user interface should be keywords for facecodes.
   Importance: no documented font support currently.  Really need it.
   Difficulty: includes massively reworking redisplay data structures.
   Bill and Rob.



** Things to think about.

;;; These are things that have been thought of, but we don't know much more
;;; about them.

Some general facility for users to associate definition locations with kinds of
things and/or forms.

What's the right way to be in a comment in some Lisp file and have filling,
spelling, and whatever work out just right.  Possibly regions with environment
information.  Maybe with a whole new hierarchical text representation, this
would fall out.

Synchronization/exclusion issues:
    Currently there are non-modification primitives that are looking into a
    buffer assuming it will not change out from under the primitive.  We
    need to identify these places and exactly what the nature of this
    problem is (including whether it exists).  Probably we need to make
    non-trivial text examination primitives use without-interrupts so that
    they see a consistent state.

    Find other places where exclusion is needed:
        Redisplay?
        Typescript code?

Think about general "Save My Editor State".  Can generalize notion of
stateful things? -- Word abbrevs, keyboard macros, defindent, spelling
stuff, etc.  This could be the last thing we ever do to the editor.
   Importance: low.
   Difficulty: very.
   ???
	   saving an image should save the editor (broken at last attempt)

	   some state is already saved
		   mh caches folders
		   netnews caches group positions
		   keyboard macros (optional)
		   word abbrevs

		   this crosses into configuration
			   eg a call to defindent in .nightshade/ed.lisp

			   "Save My Editor Config"?

				   maybe first work on configuration interface


** New Eval Servers

Do something about slaves dieing in init files.  Lisps start up and first load
init.lisp.  When a slave does this, it goes into the debugger before connecting
to the editor.



** X problems.

Compute mininum width of a window group by taking the maximum of all the
windows' font-widths, each multiplied by minimum-window-columns.  Right now it
just uses the default font or current window.

Compute minimum window split correctly: look at current window's font-height
and new window's font-height, extra height pixels, whether each has a modeline,
and minimum-window-lines to determine if we can split the current window.

Server not implementing DRAW-IMAGE-GLYPHS correctly, so we don't have to do our
pixmap hack.




** more

(most recent last)

on pause     (format t "Paused.  `fg' returns Nightshade..."))

interrupt h-c sudo processes
e sys procs  sudo if proc ownd by root
	(ed::deliver-signal-to-subprocess :SIGINT (ed::value ed::process))

Search  highlight the matched string
		also highlight the rest of the matched line (according to the file type)
			maybe only if buffer open

random typeout should be at bottom (to be near echo area)
    maybe echo area s/b at top (near top of text, which is read from the top)
        and typeout should follow it

toggle truncate lines  and ~ shift window right,left over text

query replace (m-%) " file)" with ""  (hung)

finish text/enriched mode   related to internal doc format

full `format' doc

completion for c-h f and similar
    also for c-ce   like adding generic lisp completion
	                ie dabbrev expand should check for lisp function names

dabbrev check other buffers, histories

c-h f go to ed fun too
    ed::word-at-point works
    expect it should already, seems to do w *package* binding

apropos  functions

dired  w  copy marked files (if any else current file) to kill ring
	    (as a whitespace separated string of names)
       y  if any such entry on top of kill ring copy files into current dir
       ~>  copy marked/current file/s to other window (if in dired mode else other of that win...)
	     so open two panes and use a key to copy file b/w them

completion to kill one of these buffers when they all exist
  Objed "#(jef m    (
  Objed "#(jef m    (g
  Objed "#(jef m   (g"...

completion on kill buffer with many spcs in name  eg "a  z"

+ Find Files  (opens all files)

buffer name completion
    z a b
    zz a b
prompt: z a b    ; think after complete field ~popup here point should be after the z

.db partial match when finding name

how to size of object?
    maybe ~ instance-memory  (ref'd in `room' doc)

rub in random typeout go backwards

sort paragraphs, ~fields

mh error -- scan: no new messages in drafts
    when last sent
    also when c-xr folder when folder is empty

err w long lines?  eg open parse-tests/out-long
    saw similar much later due to after-change-hook
	again apr 2007

reclaiming search pattern functions on arb searches in code
    (added find-character, maybe means add find-string)

consider adding case sensitivity of symbols

regex (or equiv) buffer search
   Regx Isearch: .*a+bc?
   ; o for or; m for many; :c for :char; s should be a for any = (or (many ...) "")
   ~BNF Isearch: :s :c::m a:b:o c "":          ; w symbol reqs as strings/chars (the a in :m a:)
   ~BNF Isearch: :s :c::m a:b:o c:             ; and w single or as optnl
   ~BNF Isearch: (s :c)(m a)b(o c)             ; braces
   ~BNF Isearch: (:c){a}b[c]                   ; (some) {many} [or]
   ~BNF Isearch: :c)a}b[c                      ; (some) {many} [or] w implicit braces
   ~BNF Isearch: :)a}b[c                       ; (some) {many} [or] w implicit braces and : for :char
   Regx Isearch: \(.\|d\)*a+bc
   ~BNF Isearch: :s (or :c d)::m a:b:o c:
   Regx Isearch: \(.d\.\)*\(ab\)+bc
   ~BNF Isearch: :s :c d .::m ab:b:o c:
   Regx Isearch: \(.d\.\)*\(ab f\)+bc
   ~BNF Isearch: :s :c d .::m "ab f":b:o c:
   Regx Isearch: \(.d\.\)*\(ab \\\\f\)+bc?
   ~BNF Isearch: :s :c d .::m "ab \\f":b:o c:
   ~BNF Isearch: (s :c d .)(m "ab \\f")b(o c)  ; braces instead of :
   Regx Isearch: \(.d\.\)*\(ab\\\\f\)+bc?
   ~BNF Isearch: :s :c d .::m ab\\f:b:o c:
   ~BNF Isearch: (a :c d .)(m ab\\f)b(o c)     ; braces instead of :
   ~BNF Isearch: (a :c d .) (m ab\\f) b (o c)     ; readable by lisp reader
   xd.ab\fbc
   Regx Isearch: .
   ~BNF Isearch: :c
   Regx Isearch: \\
   ~BNF Isearch: \
   Regx Isearch: :
   ~BNF Isearch: ::  (:)  #\:
   Regx Isearch: (
   ~BNF Isearch: (
   ~BNF Isearch: (( (:ob) ((( () ()) (:) #\(	  ; braces instd of :
 are there better alternatives to these two?
 adding regexs feels like adding another language

diary movement  next and previous entries
calendar as timeline  (mayb just some way of linking events by time)

pop-up-display when another already up
    eg if many reminders occur in short time

Dired Toggle File Compression  posn fail when run twice in quick succession

multi-let, multilet, mullet, multi-bind, mbind, bind, mvb, mub, mulb,
  let+, let*
  mlet (similar macrolet, mayb too similar to let)
    for multiple-value-bind
    (let (((a b c) (f))) ...)   for   (m-v-b (a b c) (f) ...)
    (let ((x t) ((a b) (f))) ...)
    (let (var (x t) varb ((mula mulb) (func)) varc) ...)
        quite hard to read

lisp build scripts
    show build errors in interactive output

kill builder buffer  ~still linked to slave

c-h as prefix instead of command?
    named prefix ie print "Help (h for help): " instead of c-h
    with ~popup/action (as with h in help) which leaves prefix intact

c-m-\  break on "break" key, or some other, instead
       revert to indent region (now on meta-?)

  "·  ^\ quits.  Same as interrupt.  Also may dump a "core" file (which
     you likely have no use for) into your working directory."

     pdksh man
	 intr and quit
             The interrupt and quit terminal characters cause the current line
             to be deleted and a new prompt to be printed.

		maybe due to shell?

wrap isearch

processes are active, exit anyway?
   better: processes are active, ~ exit anyway; kill and exit; cancel?

show point in other windows

resize window
    ~ Shrink Win to Buffer
	call in Next Search Match

C-e eval of large fun fails when Editor Evaluate Buffer works
     eg insert-node in parse-scribe.lisp

auto spell mode
    could intro per-mode extra dict
    maybe also per mode skip words w certain chars eg - for lisp

vc interface
    could round off and test rcs

more,better lang modes
	c++, python, prolog, scheme, forth

folding

* longer term

~ generalized functions (as in clos)
    (~overloading?)
	check oo systems such as clos,smalltalk

	maybe an eg: call member on a string-table (currently call getstring)

	function extension?

	choose function according to name and type of one of args  ugh?

~run-time modification of structure (ie the definition of the structure)
    eg to change node insert function
    (defstruct (s) a)
    (symbol-function s)
    (symbol-structure s)
    related ring-ref s/b ~aref nth

files as a type of variable
    so map a var name to memory on disk
    instd of mapping a file name to the set of blocks

	like persistant memory system

tracer, meta, <word for thinking about thinking>, higher-order, inspect
   (name for tracing tool)
   how does this relate full lang which describes every possible state of prog?
	  ~<langs already do this>
	  leeds n-dimen lang thoughts

consider expression-level comment  '((a 1) {b 2) (c 3))  ; "{" comments (b 2)

consider editor variable hooks that modify the code, instead of the code checking the variable every time
	would need to change every function that references the variable
	one issue is then if variable values change often
		maybe editor vars are intended to change rarely
	hard to implement for compiled code? when changed recompile? (and fixup? pervasive change?)
	is this a performance issue at present?

* 0
** 1
*** 2
**** 3
***** 4
****** 5
******* 6
******** 7
