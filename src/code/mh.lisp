;;; Mail handler (MH) library.

(in-package "MH")

(export '(profile-component root-pathname folder-pathname
	  draft-folder draft-folder-pathname current-folder current-message
	  ;;
	  sequence-insert sequence-delete sequence-member-p sequence-strings
	  sequence-list
	  ;;
	  get-folder-table update-folder-table
	  coerce-folder-name strip-folder-name folder-existsp
	  create-folder delete-folder sort-folder pack-folder summarize-folder
	  list-folders print-folders
	  ;;
	  summarize-message delete-message mark-message mark-messages
	  move-messages show-messages delete-messages summarize-messages
	  ;;
	  make-drop new-mail-p incorporate))

;; FIX current message (sequence) handling


;;;; User profile variables.

(defvar *directory* "home:Mail/"
  "Pathname of mail directories.  Directory name must end in a /.")

(defvar *draft-folder* "drafts"
  "Name of draft folder.")

(defvar *maildrop* "/var/spool/mail/matt" ; FIX
  "Pathname of mail drop.")

(defvar *unseen-sequence* "in"
  "Name of sequence for new mail.")

(defvar *repl* "-cc all -nocc me -fcc archive/misc"
  "FIX reply control.")

;FIX rmmproc: /bin/rm

(defvar *alternate-mailboxes* '("m.mundell@tao-group.com"
				"matt@zen.co.za"
				"mundell@pop3.ukfsn.org"
				"mattm@comp.leeds.ac.uk"
				"mmundell@tao-group.com") ; FIX
  "Alternate addresses.")

(defvar *signature* "Matthew Mundell"  ; FIX
  "Signature")


;;;; Structure.

(defvar *folder-table* ()
  "String table naming all folders.")

(defstruct (folder-info (:constructor
			 make-folder-info
			 (pathname write-date highest &optional messages sequences)))
  "Information about a folder."
  pathname    ; Pathname of folder directory.
  write-date  ; Last time folder directory was modified, in universal format.
  (highest 0) ; Number of highest message in folder; 0 when empty.
  messages    ; List of messages in folder.
  sequences)  ; List of (sequence-name ((msg | (start . end))*)) lists.


;;;; Profile.

(defvar *profile-pathname* nil)

(defun profile-pathname ()
  "Returns the pathname of the MH profile."
  (or *profile-pathname*
      (setf *profile-pathname*
	    (merge-pathnames (or (cdr (assoc :mh ext:*environment-list*))
				 ".mh_profile")
			     (truename (user-homedir-pathname))))))

;;; Public.
;;;
(defun profile-component (name &optional (pathname (profile-pathname))
			                 (error-on-open t))
  "Returns the trimmed string value for the MH profile component name.  If
   the component is not present, nil is returned.  This may be used on MH
   context and sequence files as well due to their having the same format.
   Error-on-open indicates that errors generated by OPEN should not be ignored,
   which is the default.  When opening a sequence file, it is better to supply
   this as nil since the file may not exist or be readable in another user's
   MH folder, and returning nil meaning the sequence could not be found is just
   as useful."
  (with-open-stream (s (if error-on-open
			   (open pathname)
			   (ignore-errors (open pathname))))
    (if s
	(loop
	  (multiple-value-bind (line eofp) (read-line s nil :eof)
	    (when (equal line :eof) (return nil))
	    (let ((colon (position #\: (the simple-string line) :test #'char=)))
	      (or colon
		  (error "Bad record ~S in file ~S." line (namestring pathname)))
	      (when (string-equal name line :end2 colon)
		(return (string-trim '(#\space #\tab)
				     (subseq line (1+ colon))))))
	    (when eofp (return nil)))))))


;;;; Folder names.

(defvar *root-pathname* nil)

;;; Public.
;;;
(defun coerce-folder-name (folder)
  "Return string FOLDER, ensuring that it has a leading +."
  (if (char= (schar folder 0) #\+)
      folder
      (concatenate 'simple-string "+" folder)))

;;; Public.
;;;
(defun strip-folder-name (folder)
  "Return string FOLDER, stripping off any leading +."
  (if (char= (schar folder 0) #\+)
      (subseq folder 1)
      folder))

;;; Public.
;;;
(defun root-pathname ()
  "Return the pathname of the mail directory."
  (or *root-pathname*
      (setf *root-pathname*
	    (let ((pathname (merge-pathnames
			     (or (profile-component "path")
				 (error "Mail profile must contain a Path component."))
			     (user-homedir-pathname))))
	      (truename (if (directory-name-p pathname)
			    pathname
			    (pathname (concatenate 'simple-string
						   (namestring pathname)
						   "/"))))))))

;;; Public.
;;;
(defun folder-pathname (folder)
  "Return the pathname of FOLDER."
  (merge-pathnames (concat (strip-folder-name folder) "/")
		   (root-pathname)))

;;; Public.
;;;
(defun draft-folder ()
  "Return the name of the draft folder."
  (let ((drafts (profile-component "draft-folder")))
    (or drafts
	(error "There must be a draft-folder component in your profile."))
    drafts))

;;; Public.
;;;
(defun draft-folder-pathname ()
  "Return the pathname of the draft folder directory."
  (let ((drafts (profile-component "draft-folder")))
    (or drafts
	(error "There must be a draft-folder component in your profile."))
    (folder-pathname drafts)))

(defvar *context-pathname* nil)

(defun context-pathname ()
  "Returns the pathname of the context file."
  (or *context-pathname*
      (setf *context-pathname*
	    (merge-pathnames (or (profile-component "context") "context")
			     (root-pathname)))))

;;; Public.
;;;
(defun current-folder ()
  "Return the current folder from the context file."
  (profile-component "current-folder" (context-pathname)))

;;; Public.
;;;
(defun current-message (folder)
  "Returns the current message from the folder's sequence file."
  (declare (simple-string folder))
  (let ((folder (strip-folder-name folder)))
    (or (profile-component "cur"
			   (merge-pathnames ".mh_sequences"
					    (folder-pathname folder))
			   ())
	(let ((current (folder-info-highest (scan-folder folder))))
	  (mark-message folder current "cur" :add)
	  (string current)))))
;;
(defun %set-current-message (folder message)
  "Set the current message for FOLDER to MESSAGE."
  (update-sequence folder "cur" ())
  (mark-message folder (string message) "cur" :add)
  message)
;;
(defsetf current-message %set-current-message
  "Change the current message.")


;;;; Sequences.

(declaim (optimize (speed 2))) ; Native compile.

;;; Public.
;;;
(defun mark-message (folder msg sequence add-or-delete)
  "Add or delete MSG from the sequence named SEQUENCE in the
   \".mh_sequence\" file of FOLDER.  Add-or-delete is either :add or
   :delete."
  (let ((seq-list (sequence-list folder sequence))
	(folder-info (scan-folder folder)))
    (ecase add-or-delete
      (:add
       (update-sequence folder sequence (sequence-insert msg seq-list)))
      (:delete
       (when (sequence-member-p msg seq-list)
	 (update-sequence folder sequence
			 (sequence-delete msg seq-list)))))
    ;; Update the sequences in the cache of folder.
    (let ((dir (folder-pathname folder)))
      (in-directory dir
	(setf (folder-info-sequences folder-info)
	      (get-sequences))
	(setf (folder-info-write-date folder-info)
	      (file-write-date dir))))))

;;; Public.
;;;
(defun mark-messages (folder msgs sequence add-or-delete)
  "Add or delete MSGS from the sequence named SEQUENCE in the
   \".mh_sequence\" file of FOLDER.  ADD-OR-DELETE is either :add or
   :delete."
  (let ((seq-list (sequence-list folder sequence))
	(folder-info (scan-folder folder)))
    (ecase add-or-delete
      (:add
       (dolist (msg msgs)
	 (setq seq-list (sequence-insert msg seq-list))))
      (:delete
       (dolist (msg msgs)
	 (when (sequence-member-p msg seq-list)
	   (setq seq-list (sequence-delete msg seq-list))))))
    (update-sequence folder sequence seq-list)
    ;; Update the sequences in the cache of folder.
    (let ((dir (folder-pathname folder)))
      (in-directory dir
	(setf (folder-info-sequences folder-info)
	      (get-sequences))
	(setf (folder-info-write-date folder-info)
	      (file-write-date dir))))))

(defun update-sequence (folder name seq-list)
  "Write SEQ-LIST to FOLDER's \".mh_sequences\" file.  If SEQ-LIST is nil,
   remove the sequence from the file."
  (declare (simple-string folder))
  (let* ((folder (strip-folder-name folder))
	 (input (merge-pathnames ".mh_sequences"
				 (folder-pathname folder)))
	 (input-dir (pathname (directory-namestring input)))
	 (output (loop (let* ((sym (gensym)) ;; FIX pick-temporary-file-name
			      (f (merge-pathnames
				  ;; This must have a leading period and
				  ;; only one period, for rename-file
				  ;; merging.
				  (format nil ".mh_sequences-tem-~A" sym)
				  input-dir)))
			 (or (probe-file f) (return f)))))
	 (found nil))
    (fi (file-writable output)
	;; FIX was loud-message
	(error "Cannot write sequence temp file ~A.~%~
		Aborting output of ~S sequence."
	       name (namestring output))
	(progn
	  (with-open-file (in input :if-does-not-exist :create)
	    (with-open-file (out output :direction :output)
	      (loop
		(multiple-value-bind (line eofp) (read-line in nil :eof)
		  (when (eq line :eof)
		    (return nil))
		  (let ((colon (position #\: (the simple-string line)
					 :test #'char=)))
		    (or colon
			(error "Bad record ~S in file ~S."
			       line (namestring input)))
		    (cond ((and (not found) (string-equal name line
							  :end2 colon))
			   (sub-update-sequence
			    out (subseq line 0 colon) seq-list)
			   (setf found t))
			  (t (write-line line out))))
		  (when eofp (return))))
	      (unless found
		(fresh-line out)
		(sub-update-sequence out name seq-list))))
	  (rename-file output input)))))

(defun sub-update-sequence (stream name seq-list)
  (when seq-list
    (write-string name stream)
    (write-char #\: stream)
    (let ((*print-base* 10))
      (dolist (range seq-list)
	(write-char #\space stream)
	(let ((low (car range))
	      (high (cdr range)))
	  (declare (fixnum low high))
	  (cond ((= low high)
		 (prin1 low stream))
		(t (prin1 low stream)
		   (write-char #\- stream)
		   (prin1 high stream))))))
    (terpri stream)))

;;; SEQUENCE-< keeps SORT from consing rest args when FUNCALL'ing #'<.
;;;
(defun sequence-< (x y)
  "Return t if X is less than Y, else ()."
  (< x y))

;;; Public.
;;;
(defun sequence-insert (item seq-list)
  "Insert ITEM into sequence list SEQ-LIST.  Item can be a string (\"23\"),
   number (23), or a cons of two numbers ((23 . 23) or (3 . 5))."
  (let ((range (typecase item
		 (string (let ((id (parse-integer item)))
			   (cons id id)))
		 (cons item)
		 (number (cons item item)))))
    (cond (seq-list
	   (setf seq-list (sort (cons range seq-list)
				#'sequence-< :key #'car))
	   (coelesce-sequence-ranges seq-list))
	  (t (list range)))))

(defun coelesce-sequence-ranges (seq-list)
  (when seq-list
    (let* ((current seq-list)
	   (next (cdr seq-list))
	   (current-range (car current))
	   (current-end (cdr current-range)))
      (declare (fixnum current-end))
      (loop
	(unless next
	  (setf (cdr current-range) current-end)
	  (setf (cdr current) nil)
	  (return))
	(let* ((next-range (car next))
	       (next-start (car next-range))
	       (next-end (cdr next-range)))
	  (declare (fixnum next-start next-end))
	  (cond ((<= (1- next-start) current-end)
		 ;;
		 ;; Extend the current range since the next one overlaps.
		 (when (> next-end current-end)
		   (setf current-end next-end)))
		(t
		 ;;
		 ;; Update the current range since the next one doesn't
		 ;; overlap.
		 (setf (cdr current-range) current-end)
		 ;;
		 ;; Make the next range succeed current.  Then make it
		 ;; current.
		 (setf (cdr current) next)
		 (setf current next)
		 (setf current-range next-range)
		 (setf current-end next-end))))
	(setf next (cdr next))))
    seq-list))

;;; Public.
;;;
(defun sequence-delete (item seq-list)
  "Insert ITEM into sequence list SEQ-LIST.  Item can be a string (\"23\"),
   number (23), or a cons of two numbers ((23 . 23) or (3 . 5))."
  (let ((range (typecase item
		 (string (let ((id (parse-integer item)))
			   (cons id id)))
		 (cons item)
		 (number (cons item item)))))
    (when seq-list
      (do ((id (car range) (1+ id))
	   (end (cdr range)))
	  ((> id end))
	(setf seq-list (sub-sequence-delete id seq-list)))
      seq-list)))

(defun sub-sequence-delete (id seq-list)
  (do ((prev nil seq)
       (seq seq-list (cdr seq)))
      ((null seq))
    (let* ((range (car seq))
	   (low (car range))
	   (high (cdr range)))
      (cond ((> id high))
	    ((< id low)
	     (return))
	    ((= id low)
	     (cond ((/= low high)
		    (setf (car range) (1+ id)))
		   (prev
		    (setf (cdr prev) (cdr seq)))
		   (t (setf seq-list (cdr seq-list))))
	     (return))
	    ((= id high)
	     (setf (cdr range) (1- id))
	     (return))
	    ((< low id high)
	     (setf (cdr range) (1- id))
	     (setf (cdr seq) (cons (cons (1+ id) high) (cdr seq)))
	     (return)))))
  seq-list)

;;; Public.
;;;
(defun sequence-member-p (item seq-list)
  "Return whether ITEM is in sequence list SEQ-LIST.  Item can be a string
   (\"23\") or a number (23)."
  (let ((id (typecase item
	      (string (parse-integer item))
	      (number item))))
    (dolist (range seq-list nil)
      (let ((low (car range))
	    (high (cdr range)))
	(when (<= low id high) (return t))))))

;;; Public.
;;;
(defun sequence-strings (seq-list)
  "Return a list of strings representing the ranges and message id's in
   SEQ-LIST."
  (let ((result nil))
    (dolist (range seq-list)
      (let ((low (car range))
	    (high (cdr range)))
	(if (= low high)
	    (push (number-string low) result)
	    (push (format nil "~D-~D" low high) result))))
    (nreverse result)))

(defun parse-sequence (string)
  "Parse and return the list of messages in the STRING."
  (collect ((msgs))
    (dolist (msg (split string '(#\space #\newline)))
      (let ((sep (position #\- msg)))
	(msgs (if sep
		  (cons (subseq msg 0 sep)
			(subseq msg (1+ sep) (length msg)))
		  msg))))
    (msgs)))

(defun get-sequences ()
  "Parse and return the list of sequences from the .mh_sequences file in
   the current directory."
  (collect ((sequences))
    (when (probe-file ".mh_sequences")
      (with-open-file (stream ".mh_sequences" :direction :input)
	(loop
	  (multiple-value-bind (name text)
			       (read-field stream)
	    (or name (return))
	    (if (equal name :body) (error "Body boundary in .mh_sequence file."))
	    (sequences (cons name (parse-sequence text)))))
	(sequences)))))

(defun sequence-list (folder name)
  "Return a list representing the messages and ranges of id's for the
   sequence NAME in FOLDER.  Return a second value indicating whether the
   sequence was found."
  (declare (simple-string folder))
  (let ((assoc (assoc name (folder-info-sequences (scan-folder folder))
		      :test #'string=)))
    (if assoc
	;; FIX format required by editor
	(collect ((seqs))
	  (dolist (seq (cdr assoc))
	    (etypecase seq
	      (list
	       (seqs (cons (parse-integer (car seq))
			   (parse-integer (cdr seq)))))
	      (string
	       (let ((id (parse-integer seq)))
		 (seqs (cons id id))))))
	  (values (seqs) t))
	(values () ()))))

(defun update-sequences (folder-info)
  "Update the sequences in FOLDER-INFO and the .mh_sequences file in the
   current directory to match the messages in the current directory.  For
   example, adjust the sequences for any files that have moved out of the
   directory."
  (collect ((empty))
    (dolist (sequence (folder-info-sequences folder-info))
      (collect ((messages))
	(dolist (message (cdr sequence))
	  (if (listp message)
	      (let ((start (parse-integer (car message)))
		    (end (parse-integer (cdr message))))
		(loop for id from start to end do
		  (let ((msg (number-string id)))
		    (or (probe-file msg)
			(progn
			  (cond ((eq id start)) ; Skip the first.
				((eq (1- id) start)
				 ;; Split off the first message.
				 (messages (number-string (1- id))))
				((eq id end)
				 ;; Skip the final message.
				 (setq end (1- id))
				 (return))
				(t
				 ;; Split the range.
				 (messages (cons (number-string start)
						 (number-string (1- id))))))
			  (setq start (1+ id))))))
		(cond ((< start end)
		       (messages (cons (number-string start)
				       (number-string end))))
		      ((equal start end)
		       (messages start))))
	      (if (probe-file message) (messages message))))
	(if (messages)
	    (rplacd sequence (messages))
	    (empty sequence))))
    (dolist (sequence (empty))
      (setf (folder-info-sequences folder-info)
	    (delq sequence (folder-info-sequences folder-info)))))
  ;;
  ;; Replace sequences on disk.
  (with-open-file (stream ".mh_sequences" :direction :output
			  :if-exists :new-version)
    (dolist (sequence (folder-info-sequences folder-info))
      (format stream "~A:" (car sequence))
      (dolist (message (cdr sequence))
	(etypecase message
	  (string
	   (format stream " ~A" message))
	  (list
	   (format stream " ~A-~A" (car message) (cdr message)))))
      (terpri stream))))

(defun rename-in-sequences (folder folder-info old new)
  "Update sequences in FOLDER given that message OLD is now called NEW.
   The write-date in FOLDER-INFO must equal the folder directory for
   mark-message to use FOLDER-INFO."
  (dolist (sequence (folder-info-sequences folder-info))
    ;; FIX folder-info should hold sequence-list -compat format?
    (let ((seq-list (sequence-list folder (car sequence))))
      (when (sequence-member-p old seq-list)
	(mark-message folder old (car sequence) :delete)
	(mark-message folder new (car sequence) :add)))))

; FIX this is determined externally (tools:worldcom.lisp)
;(declaim (optimize (speed 0))) ; byte compile again.


;;;; Folders.

(defun ensure-folder-table ()
  "Ensure that *folder-table* exists."
  (or *folder-table* (add-directory ".")))

;;; Public.
;;;
(defun get-folder-table ()
  "Return the table of folder names."
  (ensure-folder-table)
  *folder-table*)

;;; Public.
;;;
(defun update-folder-table ()
  "Update *folder-table*."
  (setq *folder-table* ())
  (get-folder-table))

;;; Public.
;;;
(defun folder-existsp (folder)
  "Returns t if the directory for folder exists.  Folder is a simple-string
   specifying a folder name relative to the MH mail directory."
  (declare (simple-string folder))
  (let ((pf (probe-file (folder-pathname folder))))
    (and pf (directoryp pf))))

;;; Public.
;;;
(defun create-folder (folder)
  "Creates folder directory with default protection #o711 but considers the
   MH profile for the \"Folder-Protect\" component.  Folder is a
   simple-string specifying a folder name relative to the MH mail
   directory."
  (declare (simple-string folder))
  (let* ((folder (strip-folder-name folder))
	 (pathname (folder-pathname folder))
	 (ses-name (namestring pathname))
	 (length-1 (1- (length ses-name)))
	 (name (if (= (position #\/ ses-name :test #'char= :from-end t)
		      length-1)
		   (subseq ses-name 0 (1- (length ses-name)))
		   ses-name))
	 (protection (profile-component "folder-protect")))
    (when protection
      (setf protection
	    (parse-integer protection :radix 8 :junk-allowed t)))
    (multiple-value-bind (winp err)
			 (unix:unix-mkdir name (or protection #o711))
      (or winp
	  (error "Couldn't make directory ~S: ~A"
		 name
		 (unix:get-unix-error-msg err)))
      (setf (getstring folder (get-folder-table)) t))))

;;; Public.
;;;
(defun delete-folder (folder)
  "Delete FOLDER, return t and a list of skipped files on success else ()."
  ;; FIX error if folder current dir
  ;; FIX sort out new folder?
  ;; FIX if COMPAT m_delete current - m_mailpath(folder)
  ;; FIX check for profile entry atr- current - m_mailpath?
  (in-directory (folder-pathname folder)
    (let ((others 0)
	  (skipped))
      (do-files (file (folder-pathname folder)
		 :recurse t
		 :follow-links t
		 :backups t)
	(block nil
	  (let ((name (file-namestring file)))
	    (case (char name 0)
	      ((#\. #\, #\+ #\_ #\#)) ;; FIX some COMPAT,UCI
	      (t (or (parse-integer name :errorp ())
		     (string= name "cur")  ;; FIX COMPAT current
		     (string= name "@")  ;; FIX LINK
		     (string= name ",")  ;; FIX SBACKUP
		     (progn
		       (push name skipped)
		       (incf others)
		       (return-from nil)))))
	    (delete-file name))))
      ;; FIX rma folder   seems to clear all "atr- folder" fields
      (if (plusp others)
	  ()
	  (progn
	    (delete-dir (folder-pathname folder))
	    (delete-string (strip-folder-name folder) (get-folder-table))
	    (values t skipped))))))

;;; Public.
;;;
(defun list-folders (stream)
  "Print all folders to STREAM."
  (do-folders folder
    (write-line folder stream)))

;;; Public.
;;;
(defun print-folders (stream &optional (prefix ""))
  "Print all folders to STREAM."
  (do-folders folder
    (format stream "~A~A~%" prefix folder)))

(defun read-message (input output)
  "Write a single message from INPUT on OUTPUT."
  (loop
    for line = (read-line input ()) while line do
    ;; FIX should check for delimiter how?
    ;; FIX how to search in stream?
    (if (zerop (length line))
	(let ((line (read-line input ())))
	  (or line (return))
	  (and (>= (length line) 5)
	       (string= line "From " :end1 5)
	       (let ((pos (file-position input))
		     (next (read-field input)))
		 (prog1 (if next (fi (eq next :body)))
		   (file-position input pos)))
	       (return))))
    (write-line line output)))

(defun scan-message (input &optional file)
  "Return an alist of the fields in stream INPUT.  If date synthesis is
   required use the last modification time of FILE or the current time if
   FILE is ()."
  (let ((alist (read-fields input)))
    (when alist
      (let* ((date (cdr (assoc "Date" alist :test #'string=)))
	     (uni (if date
		      (or (parse-time date
				      :patterns
				      (append ext::*http-date-time-patterns*
					      ext::*default-date-time-patterns*))
			  ;; FIX parse-time failures
			  ;;(error "parse-time failed on ~A" date))
			  ())
		      (if file
			  (file-write-date file)
			  (get-universal-time)))))
	(push (cons "Universal-date" uni) alist))
      alist)))

(defun cache-folder (folder)
  "Add a description of FOLDER to *folder-table*, returning the
   description."
  (let ((dir (folder-pathname folder))
	(folder (strip-folder-name folder))
	(msgs)
	(highest 0))
    (in-directory dir
      (do-files (file dir
		 :recurse ()
		 :follow-links t
		 :backups ())
	(let ((name (file-namestring file)))
	  (case (char name 0)
	    ((#\. #\, #\+ #\_ #\#)) ;; FIX some COMPAT,UCI
	    (t
	     (let ((num (parse-integer name :errorp ())))
	       (when num
		 (if (> num highest) (setq highest num))
		 (push (cons name
			     (with-open-file (input file :direction :input)
			       (or (scan-message input file)
				   (error "Failed to scan message ~A in ~A"
					  name folder))))
		       msgs)))))))
      (let ((descr (make-folder-info dir
				     (file-write-date dir)
				     highest
				     msgs
				     (get-sequences))))
	(setf (getstring folder (get-folder-table)) descr)
	descr))))

(defun scan-folder (folder)
  "Return a folder-info structure describing FOLDER."
  (let* ((dir (folder-pathname folder))
	 (info (getstring (strip-folder-name folder) (get-folder-table))))
    (case info
      ((t)
       (cache-folder folder))
      ((())
       (error "Folder should be in *folder-table* already."))
      (t
       (let ((date (file-write-date dir)))
	 (or date (error "Failed to read modification time on ~A." dir))
	 (if (equal (folder-info-write-date info) date)
	     info
	     (cache-folder folder)))))))

;;; Public.
;;;
;;; FIX add [sub-]sorting by other fields, e.g. subject
;;;
(defun sort-folder (folder)
  "Sort the messages in FOLDER by date."
  (let* ((folder-info (scan-folder folder))
	 (dir (folder-pathname folder))
	 (order))
    ;; Prepare an ordered list of the available message numbers.
    (dolist (msg (folder-info-messages folder-info))
      (push (parse-integer (car msg)) order))
    (setq order (sort order #'<))
    ;; Sort the list of messages.
    (setf (folder-info-messages folder-info)
	  (sort (folder-info-messages folder-info) #'message-older))
    ;; Rename the files to match the sorted list.
    (in-directory dir
      (unwind-protect
	  (let ((tem-name (pick-temporary-file-name "tem-~D~C"))
		(tem-msg (1+ (folder-info-highest folder-info))))
	    (loop
	      for sorted = (folder-info-messages folder-info) then (cdr sorted)
	      for ordered = order then (cdr ordered)
	      while (and sorted ordered)
	      finally (setf (folder-info-highest folder-info)
			    (car (last order)))
	      do
	      (let ((smsg (caar sorted))
		    (omsg (number-string (car ordered))))
		(or (string= smsg omsg)
		    (progn
		      ;; FIX Ensure that the renaming happens completely, or is
		      ;;     reverted on failure.
		      ;; Swap the file names.
		      (rename-file omsg tem-name)
		      (rename-file smsg omsg)
		      (rename-file tem-name smsg)
		      ;; Ensure rename-in-s uses folder-info.
		      (setf (folder-info-write-date folder-info)
			    (file-write-date dir))
		      ;; Update sequences, including current message.
		      (rename-in-sequences folder folder-info
					   omsg tem-msg)
		      (rename-in-sequences folder folder-info
					   smsg omsg)
		      (rename-in-sequences folder folder-info
					   tem-msg smsg)
		      ;; Rename the entries in the sorted list.
		      (rplaca (assoc omsg sorted :test #'string=) smsg)
		      (rplaca (car sorted) omsg)))))
	    (if (probe-file tem-name) (delete-file tem-name)))
	;; Update cache and disk sequences.  ;; FIX still needed?
	(update-sequences folder-info)))))

;;; Public.
;;;
(defun pack-folder (folder)
  "Number the messages in FOLDER consecutively, starting from one."
  (let ((folder-info (scan-folder folder))
	(dir (folder-pathname folder)))
    ;; Sort the list of messages by message number.
    (setf (folder-info-messages folder-info)
	  (sort (folder-info-messages folder-info) #'message-<=))
    ;; Rename the files.
    (in-directory dir
      (unwind-protect
	  (let ((num 0))
	    (loop
	      for messages = (folder-info-messages folder-info)
	      then (cdr messages)
	      while messages
	      do
	      (incf num)
	      (let ((id (caar messages))
		    (new-id (number-string num)))
		(or (string= id new-id)
		    (progn
		      (rename-file id new-id)
		      ;; Ensure rename-in-s uses folder-info.
		      (setf (folder-info-write-date folder-info)
			    (file-write-date dir))
		      ;; Update sequences, including current message.
		      (rename-in-sequences folder folder-info
					   id new-id)
		      ;; Rename the entry in the cached message list.
		      (rplaca (car messages) new-id)))))
	    (setf (folder-info-highest folder-info) num))
	;; Update cache and disk sequences.  FIX still needed?
	(update-sequences folder-info)))))

(defun add-directory (directory)
  "Recursively add the folders in DIRECTORY (relative to *directory*) to
   *folder-table*."
  (let ((dir-len (length (namestring (truename *directory*))))
	(old-table *folder-table*)
	(done))
    (unwind-protect
	(progn
	  (setq *folder-table* (make-string-table))
	  (do-directories (pathname (merge-pathnames directory *directory*)
			   :follow-links t
			   :backups t ; Faster.
			   :recurse t)
 	    (when (directoryp (namestring pathname))
	      (setf (getstring (subseq (namestring pathname) dir-len)
			       *folder-table*)
		    t)))
	  (setq done t))
      (or done (setq *folder-table* old-table)))))


;;;; Fields.

(defvar *body-scan-length* 50
  "Maximun number of characters to scan from message body.")

(defun read-field (stream)
  "Read and return name and text of next field in STREAM."
  (let ((char (read-char stream nil)))
    (when char
      (if (member char '(#\newline #\- #\return))
	  ;; Header body separator.
	  (let ((body (make-string *body-scan-length* :initial-element #\ )))
	    (loop for ch = char then (read-char stream nil) while ch do
	      (if (char= ch #\newline) (return)))
	    (loop for len from 0 to (1- *body-scan-length*)
	      for char = (read-char stream nil)
	      while char do
	      (setf (char body len)
		    (cond ((member char '(#\tab #\newline #\return #\null)) #\space)
			  (t char))))
	    (values :body body))
	  ;; Field.
	  (let ((text))
	    (unread-char char stream)
	    ;; First line.
	    (let* ((line (read-line stream))
		   (pos (or (position #\: line)
			    (return-from read-field nil)))
		   (name (subseq line 0 pos))
		   (line-length (length line)))
	      (incf pos) ; :
	      (if (>= pos line-length)
		  (setq text "")
		  (progn
		    ;; FIX ensure pos stays within string
		    (loop for po from pos to (1- line-length)
		      for char = (char line po)
		      while (or (char= char #\space) (char= char #\tab)) do
		      (incf pos))
		    (setq text
			  (subseq line pos
				  (if (char= (char line (1- line-length))
					     #\return)
				      (1- line-length)
				      line-length)))
		    ;; More lines.
		    (loop for char = (read-char stream nil) while char do
		      (unread-char char stream)
		      (or (char= char #\space)
			  (char= char #\tab)
			  (return))
		      (let* ((line (read-line stream))
			     (pos 0)
			     (line-length (length line)))
			;; FIX ensure pos stays within string
			(loop for po from pos to (1- line-length)
			  for char = (char line po)
			  while (or (char= char #\space) (char= char #\tab)) do
			  (incf pos))
			;; FIX ^M check
			(setq text
			      (concat text
				      (string #\newline)
				      (subseq line pos
					      (if (char= (char line
							       (1- line-length))
							 #\return)
						  (1- line-length)
						  line-length))))))))
	      (values name text)))))))

(defun read-fields (stream)
  "Return an alist of the fields in the first message in STREAM.  The
   message body excerpt has key :body."
  (let ((alist))
    (loop
      (multiple-value-bind (name text)
			   (read-field stream)
	(or name (return))
	(push (cons (if (stringp name)
			(nstring-capitalize name)
			name)
		    text)
	      alist)
	(if (equal name :body) (return))))
    alist))

(defun strip-date (date)
  "Return a short date from DATE field.  Throw an error if the parse
   fails."
  ;;; Sun, 10 Dec 2006 15:49:51 +0000
  ;;; Wed,  6 Dec 2006 15:51:45 +0000
  ;;; 12 Oct 2006 05:26:43 -0000
  (multiple-value-bind (sec min hour day month)
		       (decode-universal-time
			(or (parse-time date
					:patterns
					(append ext::*http-date-time-patterns*
						ext::*default-date-time-patterns*))
			    (return-from strip-date ())))
    (declare (ignore sec min hour))
    (format () "~2,'0D-~A" day (short-month-name month))))

(defun file-date (file)
  "Return a short date from the write date of FILE."
  (multiple-value-bind (sec min hour date month)
		       (decode-universal-time
			(or (file-write-date file)
			    (return-from file-date ())))
    (declare (ignore sec min hour))
    (format () "~2,'0D-~A" date (short-month-name month))))

(defun strip-name (from)
  "Return a name from FROM field."
  (if from
      (let* ((from (string-left-trim '(#\space #\tab) from))
	     (left (position #\< from)))
	(if left
	    (if (> left 0)
		(let ((from (string-right-trim
			     '(#\space #\tab)
			     (subseq from
				     (if (char= (char from 0) #\") 1 0)
				     left))))
		  (if (char= (char from (1- (length from))) #\")
		      ;; "name" <a@b.c>
		      (string-right-trim '(#\space #\tab)
					 (subseq from 0 (1- (length from))))
		      ;; name <a@b.c>
		      from))
		;; <a@b.c>
		(let ((right (position #\> from)))
		  (subseq from (1+ left) right)))
	    ;; a@b.c
	    (string-right-trim '(#\space #\tab) from)))
      ""))


;;;; Iteration.

(defun collect-messages (folder &optional recurse)
  "Return a list of the message numbers in FOLDER."
  (let ((dir (folder-pathname folder))
	(msgs))
    (in-directory dir
      (do-files (file dir
		 :recurse recurse
		 :follow-links t
		 :backups ())
	(let ((name (file-namestring file)))
	  (case (char name 0)
	    ((#\. #\, #\+ #\_ #\#)) ;; FIX some COMPAT,UCI
	    (t (let ((msg (parse-integer name :errorp ())))
		 (if msg (push msg msgs))))))))
    msgs))

(defmacro do-folders (folder &body body)
  "Run BODY on every folder with FOLDER bound to the folder."
  ;; FIX folder.c dother also prints folders named in atr-cur- profile
  ;;     field
  (let ((two (gensym)))
    `(progn
       (ext::do-strings (,folder ,two (get-folder-table))
	 (declare (ignore ,two))
	 ,@body))))

(defmacro do-sequence ((message sequence) &body body)
  "Run BODY with each message in SEQUENCE bound to MESSAGE.  SEQUENCE is a
   list like that of the folder-info sequence slot."
  (let ((id (gensym)))
    `(dolist (,message ,sequence)
       (if (listp ,message)
	   (loop
	     for ,id from (parse-integer (car ,message))
	             to (parse-integer (cdr ,message))
	     do
	     (let ((,message (number-string ,id)))
	       ,@body))
	   (progn ,@body)))))

(defmacro do-messages ((message entry messages folder folder-info)
		       &body body)
  "For each message in MESSAGES run BODY with MESSAGE bound to the message
   name and ENTRY bound to the cache entry for the message.  MESSAGES can
   be a single message or a list or messages.  A message in MESSAGES can be
   a (start-id-string . end-id-string) range, the name of a sequence or a
   message id string."
  (let ((id (gensym))
	(sequence (gensym))
	(folder-messages (gensym))
	(sequences (gensym)))
    `(let ((,folder-messages (folder-info-messages ,folder-info))
	   (,sequences (folder-info-sequences ,folder-info)))
       (dolist (,message (if (listp ,messages) ,messages (list ,messages)))
	 ;; FIX hack to allow "4-7" temp'ly, maybe should be perm
	 (when (stringp ,message)
	   (let ((,id (position #\- ,message)))
	     (if ,id
		 (setq ,message
		       (cons (string (parse-integer ,message
						    :end ,id))
			     (string (parse-integer ,message
						    :start (1+ ,id))))))))
	 (if (listp ,message)
	     (loop
	       for ,id from (parse-integer (car ,message))
	               to (parse-integer (cdr ,message))
	       do
	       (let* ((,message (number-string ,id))
		      (,entry (cdr (assoc ,message ,folder-messages
					  :test #'string=))))
		 (or ,entry
		     (error "Failed to find range message ~A in ~A cache."
			    ,message ,folder))
		 ,@body))
	     (let ((,entry (cdr (assoc ,message ,folder-messages
				       :test #'string=))))
	       (if ,entry
		   (progn
		     ,@body)
		   (let ((,sequence (cdr (assoc ,message ,sequences
					     :test #'string=))))
		     (if ,sequence
			 (do-sequence (,message ,sequence)
			   (let ((,entry (cdr (assoc ,message ,folder-messages
						     :test #'string=))))
			     (or ,entry
				 (error
				  "Failed to find sequence message ~A in ~A cache."
				  ,message ,folder))
			     ,@body))
			 (error "Failed to find ~A in ~A."
				,message ,folder))))))))))


;;;; Summarizing.

(defun replace-newlines (string)
  "Replace newlines in STRING with spaces and return STRING."
  (loop for ch across string for i = 0 then (1+ i) do
    (if (char= ch #\newline) (setf (char string i) #\space)))
  string)

;;; Public.
;;;
(defun summarize-message (pathname stream &optional (width 80) current)
  "Summarize the message in PATHNAME on STREAM."
;; 293   10-Dec   837 Anacron           Anacron job 'cron.daily' on cspcz01   <</etc/cron.daily/logrotate: apac
  (with-open-file (input pathname :direction :input)
    (let ((alist (read-fields input)))
      (when alist
	(let ((from (cdr (assoc "From" alist :test #'string=)))
	      (body (cdr (assoc :body alist)))
	      (date (cdr (assoc "Date" alist :test #'string=))))
	  (dolist (box (cons *signature* *alternate-mailboxes*)
		       (setq from (strip-name from)))
	    (when (search box from)
	      (setq from (concat "To: "
				 (strip-name (cdr (assoc "To" alist
							 :test #'string=)))))
	      (return)))
	  (format stream
		  "~4<~A~>~:[ ~;+~]~:[ ~;-~] ~6<~A~>~:[*~; ~] ~5<~A~> ~@17<~A~> ~@37<~A~>"
		  (safe-subseq (file-namestring pathname) 0 4)
		  current
		  (cdr (assoc "Replied" alist :test #'string=))
		  (if date
		      (or (strip-date date) "FIX")
		      (file-date pathname))
		  date
		  (let ((size (file-size pathname)))
		    (cond ((> size 10238975) (format () "~DM" (truncate (/ (/ size 1024.0) 1024))))
			  ((> size 99999) (format () "~DK" (truncate (/ size 1024))))
			  (t size)))
		  (safe-subseq from 0 17)
		  ;; FIX This can leave trailing space if it is the last
		  ;;     output.
		  (safe-subseq (replace-newlines
				(or (cdr (assoc "Subject" alist
						:test #'string=))
				    ""))
			       0 37))
	  (let ((pre-width 77)) ; Length of string produced by format above.
	    (if (and body (> width pre-width))
		(let ((body (string-trim '(#\space #\tab)
					 (if (> (- width pre-width)
						(length body))
					     body
					     (subseq body
						     0 (- width pre-width))))))
		  (or (string= body "")
		      (format stream "  ~A" body))))))
	(terpri stream)))))

;;; Public.
;;;
(defun summarize-messages (folder messages stream &optional (width 80))
  "Summarize MESSAGES in FOLDER on STREAM."
  ;; FIX could add "next", "prev", ...
  (if (and (stringp (car messages)) (string= (car messages) "all"))
      (summarize-folder folder stream width)
      (let ((dir (folder-pathname folder))
	    (width (or width 80))
	    (folder-info (scan-folder folder)))
	(in-directory dir
	  (do-messages (message entry messages folder folder-info)
	    (summarize-message message stream width)))))) ;; FIX current

;;; Public.
;;;
(defun summarize-folder (folder stream &optional width)
  "Summarize FOLDER on STREAM."
  (let ((width (or width 80))
	(msgs (collect-messages folder)))
    (setq msgs (sort msgs #'<))
    (summarize-messages folder
			(iterate convert ((messages msgs))
			  (if (car messages)
			      (cons (number-string (car messages))
				    (convert (cdr messages)))))
			stream
			width)))


;;;; Messages.

(defun message-older (msg1 msg2)
  (let ((date1 (cdr (assoc "Universal-date" (cdr msg1) :test #'string=)))
	(date2 (cdr (assoc "Universal-date" (cdr msg2) :test #'string=))))
    (if date2
	(if date1
	    (if (<= date1 date2) t ())
	    ())
	t)))

(defun message-<= (msg1 msg2)
  "Return t if the id of MSG1 is <= the id of MSG2."
  (let ((id1 (parse-integer (car msg1)))
	(id2 (parse-integer (car msg2))))
    (<= id1 id2)))

(defun highest (folder-info)
  "Return an integer of the highest entry in folder-info, or 0 if the
   folder has a single entry."
  (let ((highest 0))
    (dolist (message (folder-info-messages folder-info))
      (let ((id (parse-integer (car message))))
	(if (> id highest)
	    (setq highest id))))
    highest))

;;; Public.
;;;
(defun move-messages (source dest &rest messages)
  "Move MESSAGES from folder SOURCE to folder DEST.  Assume DEST exists and
   SOURCE is readable."
  (fi (string= source dest)
      (let* ((source-info (scan-folder source))
	     (dest-info (scan-folder dest))
	     (source-messages (folder-info-messages source-info))
	     (dest-dir (namestring (folder-pathname dest)))
	     (source-current (current-message source)))
	(in-directory (folder-pathname source)
	  (unwind-protect
	      (progn
		(do-messages (message entry messages source source-info)
		  ;; FIX the rest of this block should be ~atomic
		  (let ((dest-id (incf (folder-info-highest dest-info))))
		    (rename-file message (format () "~A/~D" dest-dir dest-id))
		    ;; (`update-sequences' will adjust the sequences.)
		    ;; Move entry to the destination cache.
		    (setf (folder-info-messages source-info)
			  (setq source-messages
				(delq entry source-messages)))
		    (if (eq source-current (parse-integer message))
			;; Update the current message in the source.
			(setf (current-message source)
			      (highest source-info)))
		    (if (eq (parse-integer message)
			    (folder-info-highest source-info))
			;; Adjust the source highest.
			(setf (folder-info-highest source-info)
			      (highest source-info)))
		    (rplaca entry (number-string dest-id))
		    (setf (folder-info-messages dest-info)
			  ;; FIX should be sorted?
			  (cons entry (folder-info-messages dest-info)))))
		;; Update the folder cache dates.
		(setf (folder-info-write-date source-info)
		      (file-write-date (folder-pathname source)))
		(setf (folder-info-write-date dest-info)
		      (file-write-date (folder-pathname dest))))
	    ;; Update cache and disk sequences.
	    (update-sequences source-info))))))

;;; Public.
;;;
(defun show-messages (stream folder &rest messages)
  "Write MESSAGES from FOLDER onto STREAM."
  (let* ((folder-info (scan-folder folder)))
    (in-directory (folder-pathname folder)
      (do-messages (message entry messages folder folder-info)
	;; FIX is there a better way to write a file to a stream?
	(with-open-file (input message :direction :input)
	  (loop for line = (read-line input ()) while line do
	    (write-line line stream)))))))

(declaim (inline %delete-message))
(defun %delete-message (msg folder dir folder-info errorp)
  "Rename MSG with a , prefix.  Must be called with DIR current."
  (let* ((mlist (folder-info-messages folder-info))
	 (entry (assoc msg mlist :test #'string=)))
    (if entry
	(progn
	  ;; FIX rest should be ~atomic
	  (loop
	    for pro = (concat "," msg) then (concat "," pro)
	    while (probe-file pro)
	    finally (rename-file msg pro))
	  ;; Update the folder cache.
	  (setf (folder-info-messages folder-info)
		(delq entry mlist))
	  (if (eq (parse-integer msg) (folder-info-highest folder-info))
	      (setf (folder-info-highest folder-info)
		    (highest folder-info)))
	  (setf (folder-info-write-date folder-info)
		(file-write-date dir)))
	(if errorp (error "Failed to find ~A in ~A cache." msg folder)))))

;;; Public.
;;;
(defun delete-message (folder message &optional (errorp t))
  "Delete MESSAGE from FOLDER.  MESSAGES t indicates all messages.  With
   ERRORP true the given messages must exist, else an error is signalled."
  (let* ((folder-info (scan-folder folder))
	 (dir (folder-pathname folder))
	 (current-message (current-message folder)))
    (in-directory dir
      (unwind-protect
	  (%delete-message message folder dir folder-info errorp)
	(or (probe-file current-message)
	    (setf (current-message folder) (highest folder-info)))
	(update-sequences folder-info)))))

;;; Public.
;;;
(defun delete-messages (folder &optional (messages t) (errorp t))
  "Delete MESSAGES from FOLDER.  MESSAGES t indicates all messages.  With
   ERRORP true the given messages must exist, else an error is signalled."
  (let* ((messages (if (eq messages t) (collect-messages folder) messages))
	 (folder-info (scan-folder folder))
	 (dir (folder-pathname folder))
	 (current-message (current-message folder)))
    (in-directory dir
      (unwind-protect
	  (do-messages (message entry messages folder folder-info)
	    (%delete-message message folder dir folder-info errorp))
	(or (probe-file current-message)
	    (setf (current-message folder) (highest folder-info)))
	(update-sequences folder-info)))))


;;;; Drops.

(defstruct (drop)
  new-fun
  inc-fun)

(defstruct (local-drop
	    (:include drop
		      (new-fun #'new-local-mail-p)
		      (inc-fun #'incorporate-local))
	    (:constructor
	     make-local-drop
	     (&optional (location
			 (or (cdr (assoc :mail ext:*environment-list*))
			     (cdr (assoc :maildrop ext:*environment-list*))
			     (profile-component "MailDrop")
			     (merge-pathnames
			      (cdr (assoc :user ext:*environment-list*))
			      "/usr/spool/mail/"))))))
  location)

(defstruct (pop-drop (:include drop
			       (new-fun #'new-pop-mail-p)
			       (inc-fun #'incorporate-pop))
		     (:constructor %make-pop-drop
				   (type account port timeout)))
  type
  account
  port
  timeout)
;;
(defun make-pop-drop (type &key port timeout server user password)
  (%make-pop-drop type
		  (make-inet-account server user password)
		  (or port 110)  ; POP3 (POP2 109)
		  (or timeout 10)))

(defvar *drop-makers* '((:local . make-local-drop)
			(:pop . make-pop-drop))
  "List of type, maker associations for mail drops.")

;;; Public.
;;;
(defun make-drop (type &rest args)
  "Make a mail drop of TYPE."
  (let ((assoc (assoc type *drop-makers*)))
    (if assoc (apply (cdr assoc) args))))


;;;; New mail.

;;; Public.
;;;
(defun new-mail-p (drops)
  (dolist (drop drops)
    (if (funcall (drop-new-fun drop) drop)
	(return-from new-mail-p t)))
  ())

(defun new-local-mail-p (drop)
  (multiple-value-bind (success dev ino mode nlink uid gid rdev size)
		       (unix:unix-stat (namestring (local-drop-location drop)))
    (declare (ignore dev ino nlink uid gid rdev))
    (and success
	 (plusp (logand unix:s-ifreg mode))
	 (plusp size))))

(defun new-pop-mail-p (drop)
  (let* ((account (fill-from-netrc (pop-drop-account drop)))
	 (stream (pop-init account
			   (pop-drop-type drop)
			   (pop-drop-port drop)
			   (pop-drop-timeout drop))))
    (and stream
	 (let ((msg-count (pop-stat stream)))
	   (prog1 (if (and msg-count (plusp msg-count)) msg-count)
	     (inet-quit stream))))))


;;;; Incorporating mail.

;;; Public.
;;;
(defun incorporate (drops &optional folder stream)
  (let ((return))
    (dolist (drop drops)
      (if (funcall (drop-inc-fun drop) drop folder stream)
	  (setq return t)))
    return))

(defun incorporate-local (drop &optional folder log-stream)
  "Incorporate all mail from local DROP."
  (declare (ignore log-stream)) ; FIX Orig inc logs progress, for Inc New Mail.
  (let ((location (namestring (local-drop-location drop))))
    (multiple-value-bind (success dev ino mode nlink uid gid rdev size)
			 (unix:unix-stat location)
      (declare (ignore dev ino nlink uid gid rdev))
      (when (and success
		 (plusp (logand unix:s-ifreg mode))
		 (plusp size))
	(let* ((folder (or folder
			   (profile-component "inbox")
			   "inbox"))
	       (pathname (folder-pathname folder))
	       (lock (concat location ".lock")))
	  (ensure-directories-exist pathname)
	  ;; Lock the location.
	  (system:without-interrupts
	   (if (probe-file lock)
	       (error "Drop location ~A locked with ~A." location lock)
	       (with-open-file (lock-stream lock :if-exists :error
					    :if-does-not-exist :create))))
	  (unwind-protect
	      (let* ((folder-info (scan-folder folder))
		     (in-sequence (profile-component "unseen-sequence")))
		(in-directory pathname
		  ;; Read messages into files.
		  (with-open-file (in location :direction :input
				      :if-does-not-exist :error)
		    (let ((line (read-line in ())))
		      (or (and line
			       (> (length line) 5)
			       (string= line "From " :end1 5))
			  (error "Location must start with \"From \".")))
		    (loop
		      for new-id = (1+ (folder-info-highest folder-info))
		      then (1+ new-id)
		      while (peek-char () in ())
		      do
		      (let ((name (number-string new-id)))
			(with-open-file
			    (file-stream name
					 :direction :io
					 :if-does-not-exist :create
					 :if-exists :error)
			  (read-message in file-stream)
			  (file-position file-stream :start)
			  (let ((alist (scan-message file-stream)))
			    (when alist
			      ;; Update the folder cache.
			      (push (cons name alist)
				    ; FIX msgs should be sorted?
				    (folder-info-messages folder-info))
			      (setf (folder-info-highest folder-info)
				    new-id)
			      (setf (folder-info-write-date folder-info)
				    (file-write-date pathname))
			      ;; Update sequence.
			      (mark-messages folder (list name)
					     in-sequence :add))))))))
		(truncate-file location))
	    (delete-file lock)))
	t))))

(defun incorporate-pop (drop &optional folder log-stream)
  "Incorporate all mail from POP DROP."
  (declare (ignore log-stream)) ; FIX Orig inc logs progress, for Inc New Mail.
  (let* ((account (fill-from-netrc (pop-drop-account drop)))
	 (pop-stream (pop-init account
			       (pop-drop-type drop)
			       (pop-drop-port drop)
			       (pop-drop-timeout drop))))
    (when pop-stream
      (unwind-protect
	  (let ((msg-count (pop-stat pop-stream)))
	    (when (and msg-count (plusp msg-count))
	      (let* ((folder (or folder
				 (profile-component "inbox")
				 "inbox"))
		     (pathname (folder-pathname folder)))
		(ensure-directories-exist pathname)
		(let* ((folder-info (scan-folder folder))
		       (in-sequence (profile-component "unseen-sequence")))
		  (in-directory pathname
		    (loop
		      for pop-id from 1 to msg-count
		      for new-id = (1+ (folder-info-highest folder-info))
		                 then (1+ new-id)
		      do
		      (let ((name (number-string new-id)))
			(with-open-file
			    (file-stream name
					 :direction :io
					 :if-does-not-exist :create
					 :if-exists :error)
			  (pop-retr pop-stream pop-id file-stream)
			  (file-position file-stream :start)
			  (let ((alist (scan-message file-stream)))
			    (when alist
			      ;; Update the folder cache.
			      (push (cons name alist)
				    ; FIX msgs should be sorted?
				    (folder-info-messages folder-info))
			      (setf (folder-info-highest folder-info)
				    new-id)
			      (setf (folder-info-write-date folder-info)
				    (file-write-date pathname))
			      ;; Update sequence.
			      (mark-messages folder (list name)
					     in-sequence :add)
			      ;; Flush message.
			      (or (pop-dele pop-stream pop-id)
				  (error "Failed to flush ~A from POP."))))))))))
	      t))
	(inet-quit pop-stream)))))
