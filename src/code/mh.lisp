;;; Mail handler (MH) library.

(in-package "MH")

(export '(profile-component root-pathname folder-pathname
	  draft-folder draft-folder-pathname current-folder current-message
	  ;;
	  sequence-insert sequence-delete sequence-member-p sequence-strings
	  sequence-list
	  ;;
	  get-folder-table update-folder-table
	  coerce-folder-name strip-folder-name folder-existsp
	  create-folder delete-folder sort-folder pack-folder summarize-folder
	  list-folders print-folders
	  ;;
	  annotate-message delete-message get-part mark-message write-headers
	  write-message resend-message summarize-message
	  ;;
	  draft-forward draft-new draft-reply draft-resend
	  ;;
	  delete-messages deliver-messages mark-messages move-messages
	  pick-messages show-messages split-messages summarize-messages
	  ;;
	  make-drop new-mail-p incorporate))

;; FIX current message (sequence) handling

;; FIX always use get-field


;;;; User profile variables.

(defvar *directory* "home:Mail/"
  "Pathname of mail directories.  Directory name must end in a /.")

(defvar *draft-folder* "drafts"
  "Name of draft folder.")

(defvar *smtp-server* "localhost"
  "Name of SMTP server.")

(defvar *maildrop* "/var/spool/mail/matt" ; FIX
  "Pathname of mail drop.")

(defvar *unseen-sequence* "in"
  "Name of sequence for new mail.")

(defvar *reply-archive* "archive/misc"
  "Last resort folder in which to archive replies.")

(defun archive-for-reply (folder message)
  "Return the folder in which to archive a reply to MESSAGE from FOLDER."
  (declare (ignore message))
  (let ((folder (strip-folder-name folder)))
    (case= folder
      ("inbox" *reply-archive*)
      (t folder))))

(defvar *signature* "Matthew Mundell"  ; FIX
  "Signature")

(defvar *address* "matt@mundell.ukfsn.org"  ; FIX
  "Email address.  Last resort for address-for-reply-to and
   address-for-from.")

(defvar *alternate-addresses* '("m.mundell@tao-group.com"
				"matt@zen.co.za"
				"mundell@pop3.ukfsn.org"
				"mundell@ukfsn.org"
				"mattm@comp.leeds.ac.uk"
				"mmundell@tao-group.com") ; FIX
  "A list of alternate addresses, as strings.")

(defun address-for-reply-to (folder message)
  "Return the address for the reply-to field of a reply to MESSAGE from
   FOLDER."
  (declare (ignore message))
  (let ((folder (strip-folder-name folder)))
    (case= folder
      ("inbox" *address*)
      (t *address*))))

(defun address-for-from (folder message)
  "Return the address for the from field of a reply to MESSAGE from
   FOLDER."
  (declare (ignore message))
  (let ((folder (strip-folder-name folder)))
    (case= folder
      ("inbox" *address*)
      (t *address*))))


;;;; Structure.

(defvar *folder-table* ()
  "String table naming all folders.")

(defstruct (folder-info (:constructor
			 make-folder-info
			 (pathname write-date highest &optional messages sequences)))
  "Information about a folder."
  pathname    ; Pathname of folder directory.
  write-date  ; Last time folder directory was modified, in universal format.
  (highest 0) ; Number of highest message in folder; 0 when empty.
  messages    ; List of messages in folder.
  sequences)  ; List of (sequence-name ((msg | (start . end))*)) lists.


;;;; Date

(defun write-date-field (name stream &optional (date (get-universal-time)))
  (format stream "~A: " name)
  (format-universal-time stream date :style :rfc1123 :print-weekday ())
  (terpri stream))


;;;; Profile.

(defvar *profile-pathname* ())

(defun profile-pathname ()
  "Returns the pathname of the MH profile."
  (or *profile-pathname*
      (setf *profile-pathname*
	    (merge-pathnames (or (cdr (assoc :mh ext:*environment-list*))
				 ".mh_profile")
			     (truename (user-homedir-pathname))))))

;;; Public.
;;;
(defun profile-component (name &optional (pathname (profile-pathname))
			                 (error-on-open t))
  "Returns the trimmed string value for the MH profile component name.  If
   the component is not present, nil is returned.  This may be used on MH
   context and sequence files as well due to their having the same format.
   Error-on-open indicates that errors generated by OPEN should not be ignored,
   which is the default.  When opening a sequence file, it is better to supply
   this as nil since the file may not exist or be readable in another user's
   MH folder, and returning nil meaning the sequence could not be found is just
   as useful."
  (with-open-stream (s (if error-on-open
			   (open pathname)
			   (ignore-errors (open pathname))))
    (if s
	(loop
	  (multiple-value-bind (line eofp) (read-line s nil :eof)
	    (when (equal line :eof) (return nil))
	    (let ((colon (position #\: (the simple-string line) :test #'char=)))
	      (or colon
		  (error "Bad record ~S in file ~S." line (namestring pathname)))
	      (when (string-equal name line :end2 colon)
		(return (string-trim '(#\space #\tab)
				     (subseq line (1+ colon))))))
	    (when eofp (return nil)))))))


;;;; Folder names.

(defvar *root-pathname* nil)

;;; Public.
;;;
(defun coerce-folder-name (folder)
  "Return string FOLDER, ensuring that it has a leading +."
  (if (char= (schar folder 0) #\+)
      folder
      (concatenate 'simple-string "+" folder)))

;;; Public.
;;;
(defun strip-folder-name (folder)
  "Return string FOLDER, stripping off any leading +."
  (if (char= (schar folder 0) #\+)
      (subseq folder 1)
      folder))

;;; Public.
;;;
(defun root-pathname ()
  "Return the pathname of the mail directory."
  (or *root-pathname*
      (setf *root-pathname*
	    (let ((pathname (merge-pathnames
			     (or (profile-component "path")
				 (error "Mail profile must contain a Path component."))
			     (user-homedir-pathname))))
	      (truename (if (directory-name-p pathname)
			    pathname
			    (pathname (concatenate 'simple-string
						   (namestring pathname)
						   "/"))))))))

;;; Public.
;;;
(defun folder-pathname (folder)
  "Return the pathname of FOLDER."
  (merge-pathnames (concat (strip-folder-name folder) "/")
		   (root-pathname)))

;;; Public.
;;;
(defun draft-folder ()
  "Return the name of the draft folder."
  (let ((drafts (profile-component "draft-folder")))
    (or drafts
	(error "There must be a draft-folder component in your profile."))
    drafts))

;;; Public.
;;;
(defun draft-folder-pathname ()
  "Return the pathname of the draft folder directory."
  (let ((drafts (profile-component "draft-folder")))
    (or drafts
	(error "There must be a draft-folder component in your profile."))
    (folder-pathname drafts)))

(defvar *context-pathname* nil)

(defun context-pathname ()
  "Returns the pathname of the context file."
  (or *context-pathname*
      (setf *context-pathname*
	    (merge-pathnames (or (profile-component "context") "context")
			     (root-pathname)))))

;;; Public.
;;;
(defun current-folder ()
  "Return the current folder from the context file."
  (profile-component "current-folder" (context-pathname)))

;;; Public.
;;;
(defun current-message (folder)
  "Returns the current message from the folder's sequence file."
  (declare (simple-string folder))
  (let ((folder (strip-folder-name folder)))
    (or (profile-component "cur"
			   (merge-pathnames ".mh_sequences"
					    (folder-pathname folder))
			   ())
	(let ((current (folder-info-highest (scan-folder folder))))
	  (mark-message folder current "cur" :add)
	  (string current)))))
;;
(defun %set-current-message (folder message)
  "Set the current message for FOLDER to MESSAGE."
  (update-sequence folder "cur" ())
  (mark-message folder (string message) "cur" :add)
  message)
;;
(defsetf current-message %set-current-message
  "Change the current message.")


;;;; Sequences.

(declaim (optimize (speed 2))) ; Native compile.

;;; Public.
;;;
(defun mark-message (folder msg sequence add-or-delete)
  "Add or delete MSG from the sequence named SEQUENCE in the
   \".mh_sequence\" file of FOLDER.  Add-or-delete is either :add or
   :delete."
  (let ((seq-list (sequence-list folder sequence))
	(folder-info (scan-folder folder)))
    (ecase add-or-delete
      (:add
       (update-sequence folder sequence (sequence-insert msg seq-list)))
      (:delete
       (when (sequence-member-p msg seq-list)
	 (update-sequence folder sequence
			 (sequence-delete msg seq-list)))))
    ;; Update the sequences in the cache of folder.
    (let ((dir (folder-pathname folder)))
      (in-directory dir
	(setf (folder-info-sequences folder-info)
	      (get-sequences))
	(setf (folder-info-write-date folder-info)
	      (file-write-date dir))))))

;;; Public.
;;;
(defun mark-messages (folder msgs sequence add-or-delete)
  "Add or delete MSGS from the sequence named SEQUENCE in the
   \".mh_sequence\" file of FOLDER.  ADD-OR-DELETE is either :add or
   :delete."
  (let ((seq-list (sequence-list folder sequence))
	(folder-info (scan-folder folder)))
    (ecase add-or-delete
      (:add
       (dolist (msg msgs)
	 (setq seq-list (sequence-insert msg seq-list))))
      (:delete
       (dolist (msg msgs)
	 (when (sequence-member-p msg seq-list)
	   (setq seq-list (sequence-delete msg seq-list))))))
    (update-sequence folder sequence seq-list)
    ;; Update the sequences in the cache of folder.
    (let ((dir (folder-pathname folder)))
      (in-directory dir
	(setf (folder-info-sequences folder-info)
	      (get-sequences))
	(setf (folder-info-write-date folder-info)
	      (file-write-date dir))))))

(defun update-sequence (folder name seq-list)
  "Write SEQ-LIST to FOLDER's \".mh_sequences\" file.  If SEQ-LIST is nil,
   remove the sequence from the file."
  (declare (simple-string folder))
  (let* ((folder (strip-folder-name folder))
	 (input (merge-pathnames ".mh_sequences"
				 (folder-pathname folder)))
	 (input-dir (pathname (directory-namestring input)))
	 (output (loop (let* ((sym (gensym)) ;; FIX pick-temporary-file-name
			      (f (merge-pathnames
				  ;; This must have a leading period and
				  ;; only one period, for rename-file
				  ;; merging.
				  (format nil ".mh_sequences-tem-~A" sym)
				  input-dir)))
			 (or (probe-file f) (return f)))))
	 (found nil))
    (fi (file-writable output)
	;; FIX was loud-message
	(error "Cannot write sequence temp file ~A.~%~
		Aborting output of ~S sequence."
	       name (namestring output))
	(progn
	  (with-open-file (in input :if-does-not-exist :create)
	    (with-open-file (out output :direction :output)
	      (loop
		(multiple-value-bind (line eofp) (read-line in nil :eof)
		  (when (eq line :eof)
		    (return nil))
		  (let ((colon (position #\: (the simple-string line)
					 :test #'char=)))
		    (or colon
			(error "Bad record ~S in file ~S."
			       line (namestring input)))
		    (cond ((and (not found) (string-equal name line
							  :end2 colon))
			   (sub-update-sequence
			    out (subseq line 0 colon) seq-list)
			   (setf found t))
			  (t (write-line line out))))
		  (when eofp (return))))
	      (unless found
		(fresh-line out)
		(sub-update-sequence out name seq-list))))
	  (rename-file output input)))))

(defun sub-update-sequence (stream name seq-list)
  (when seq-list
    (write-string name stream)
    (write-char #\: stream)
    (let ((*print-base* 10))
      (dolist (range seq-list)
	(write-char #\space stream)
	(let ((low (car range))
	      (high (cdr range)))
	  (declare (fixnum low high))
	  (cond ((= low high)
		 (prin1 low stream))
		(t (prin1 low stream)
		   (write-char #\- stream)
		   (prin1 high stream))))))
    (terpri stream)))

;;; SEQUENCE-< keeps SORT from consing rest args when FUNCALL'ing #'<.
;;;
(defun sequence-< (x y)
  "Return t if X is less than Y, else ()."
  (< x y))

;;; Public.
;;;
(defun sequence-insert (item seq-list)
  "Insert ITEM into sequence list SEQ-LIST.  Item can be a string (\"23\"),
   number (23), or a cons of two numbers ((23 . 23) or (3 . 5))."
  (let ((range (typecase item
		 (string (let ((id (parse-integer item)))
			   (cons id id)))
		 (cons item)
		 (number (cons item item)))))
    (cond (seq-list
	   (setf seq-list (sort (cons range seq-list)
				#'sequence-< :key #'car))
	   (coelesce-sequence-ranges seq-list))
	  (t (list range)))))

(defun coelesce-sequence-ranges (seq-list)
  (when seq-list
    (let* ((current seq-list)
	   (next (cdr seq-list))
	   (current-range (car current))
	   (current-end (cdr current-range)))
      (declare (fixnum current-end))
      (loop
	(unless next
	  (setf (cdr current-range) current-end)
	  (setf (cdr current) nil)
	  (return))
	(let* ((next-range (car next))
	       (next-start (car next-range))
	       (next-end (cdr next-range)))
	  (declare (fixnum next-start next-end))
	  (cond ((<= (1- next-start) current-end)
		 ;;
		 ;; Extend the current range since the next one overlaps.
		 (when (> next-end current-end)
		   (setf current-end next-end)))
		(t
		 ;;
		 ;; Update the current range since the next one doesn't
		 ;; overlap.
		 (setf (cdr current-range) current-end)
		 ;;
		 ;; Make the next range succeed current.  Then make it
		 ;; current.
		 (setf (cdr current) next)
		 (setf current next)
		 (setf current-range next-range)
		 (setf current-end next-end))))
	(setf next (cdr next))))
    seq-list))

;;; Public.
;;;
(defun sequence-delete (item seq-list)
  "Insert ITEM into sequence list SEQ-LIST.  Item can be a string (\"23\"),
   number (23), or a cons of two numbers ((23 . 23) or (3 . 5))."
  (let ((range (typecase item
		 (string (let ((id (parse-integer item)))
			   (cons id id)))
		 (cons item)
		 (number (cons item item)))))
    (when seq-list
      (do ((id (car range) (1+ id))
	   (end (cdr range)))
	  ((> id end))
	(setf seq-list (sub-sequence-delete id seq-list)))
      seq-list)))

(defun sub-sequence-delete (id seq-list)
  (do ((prev nil seq)
       (seq seq-list (cdr seq)))
      ((null seq))
    (let* ((range (car seq))
	   (low (car range))
	   (high (cdr range)))
      (cond ((> id high))
	    ((< id low)
	     (return))
	    ((= id low)
	     (cond ((/= low high)
		    (setf (car range) (1+ id)))
		   (prev
		    (setf (cdr prev) (cdr seq)))
		   (t (setf seq-list (cdr seq-list))))
	     (return))
	    ((= id high)
	     (setf (cdr range) (1- id))
	     (return))
	    ((< low id high)
	     (setf (cdr range) (1- id))
	     (setf (cdr seq) (cons (cons (1+ id) high) (cdr seq)))
	     (return)))))
  seq-list)

;;; Public.
;;;
(defun sequence-member-p (item seq-list)
  "Return whether ITEM is in sequence list SEQ-LIST.  Item can be a string
   (\"23\") or a number (23)."
  (let ((id (typecase item
	      (string (parse-integer item))
	      (number item))))
    (dolist (range seq-list nil)
      (let ((low (car range))
	    (high (cdr range)))
	(when (<= low id high) (return t))))))

;;; Public.
;;;
(defun sequence-strings (seq-list)
  "Return a list of strings representing the ranges and message id's in
   SEQ-LIST."
  (let ((result nil))
    (dolist (range seq-list)
      (let ((low (car range))
	    (high (cdr range)))
	(if (= low high)
	    (push (number-string low) result)
	    (push (format nil "~D-~D" low high) result))))
    (nreverse result)))

(defun parse-sequence (string)
  "Parse and return the list of messages in the STRING."
  (collect ((msgs))
    (dolist (msg (split string '(#\space #\newline)))
      (let ((sep (position #\- msg)))
	(msgs (if sep
		  (cons (subseq msg 0 sep)
			(subseq msg (1+ sep) (length msg)))
		  msg))))
    (msgs)))

(defun get-sequences ()
  "Parse and return the list of sequences from the .mh_sequences file in
   the current directory."
  (collect ((sequences))
    (when (probe-file ".mh_sequences")
      (with-open-file (stream ".mh_sequences" :direction :input)
	(loop
	  (multiple-value-bind (name text)
			       (read-field stream)
	    (or name (return))
	    (if (equal name :body) (error "Body boundary in .mh_sequence file."))
	    (sequences (cons name (parse-sequence text)))))
	(sequences)))))

(defun sequence-list (folder name)
  "Return a list representing the messages and ranges of id's for the
   sequence NAME in FOLDER.  Return a second value indicating whether the
   sequence was found."
  (declare (simple-string folder))
  (let ((assoc (assoc name (folder-info-sequences (scan-folder folder))
		      :test #'string=)))
    (if assoc
	;; FIX format required by editor
	(collect ((seqs))
	  (dolist (seq (cdr assoc))
	    (etypecase seq
	      (list
	       (seqs (cons (parse-integer (car seq))
			   (parse-integer (cdr seq)))))
	      (string
	       (let ((id (parse-integer seq)))
		 (seqs (cons id id))))))
	  (values (seqs) t))
	(values () ()))))  ;; (values)?

(defun update-sequences (folder-info)
  "Update the sequences in FOLDER-INFO and the .mh_sequences file in the
   current directory to match the messages in the current directory.  For
   example, adjust the sequences for any files that have moved out of the
   directory."
  (collect ((empty))
    (dolist (sequence (folder-info-sequences folder-info))
      (collect ((messages))
	(dolist (message (cdr sequence))
	  (if (listp message)
	      (let ((start (parse-integer (car message)))
		    (end (parse-integer (cdr message))))
		(loop for id from start to end do
		  (let ((msg (number-string id)))
		    (or (probe-file msg)
			(progn
			  (cond ((eq id start)) ; Skip the first.
				((eq (1- id) start)
				 ;; Split off the first message.
				 (messages (number-string (1- id))))
				((eq id end)
				 ;; Skip the final message.
				 (setq end (1- id))
				 (return))
				(t
				 ;; Split the range.
				 (messages (cons (number-string start)
						 (number-string (1- id))))))
			  (setq start (1+ id))))))
		(cond ((< start end)
		       (messages (cons (number-string start)
				       (number-string end))))
		      ((equal start end)
		       (messages start))))
	      (if (probe-file message) (messages message))))
	(if (messages)
	    (rplacd sequence (messages))
	    (empty sequence))))
    (dolist (sequence (empty))
      (setf (folder-info-sequences folder-info)
	    (delq sequence (folder-info-sequences folder-info)))))
  ;;
  ;; Replace sequences on disk.
  (with-open-file (stream ".mh_sequences" :direction :output
			  :if-exists :new-version)
    (dolist (sequence (folder-info-sequences folder-info))
      (format stream "~A:" (car sequence))
      (dolist (message (cdr sequence))
	(etypecase message
	  (integer ;; FIX integers allowed?
	   (format stream " ~A" message))
	  (string
	   (format stream " ~A" message))
	  (list
	   (format stream " ~A-~A" (car message) (cdr message)))))
      (terpri stream))))

(defun rename-in-sequences (folder folder-info old new)
  "Update sequences in FOLDER given that message OLD is now called NEW.
   The write-date in FOLDER-INFO must equal the folder directory for
   mark-message to use FOLDER-INFO."
  (dolist (sequence (folder-info-sequences folder-info))
    ;; FIX folder-info should hold sequence-list -compat format?
    (let ((seq-list (sequence-list folder (car sequence))))
      (when (sequence-member-p old seq-list)
	(mark-message folder old (car sequence) :delete)
	(mark-message folder new (car sequence) :add)))))

; FIX this is determined externally (tools:worldcom.lisp)
;(declaim (optimize (speed 0))) ; byte compile again.


;;;; Folders.

(defun ensure-folder-table ()
  "Ensure that *folder-table* exists."
  (or *folder-table* (add-directory ".")))

;;; Public.
;;;
(defun get-folder-table ()
  "Return the table of folder names."
  (ensure-folder-table)
  *folder-table*)

;;; Public.
;;;
(defun update-folder-table ()
  "Update *folder-table*."
  (setq *folder-table* ())
  (get-folder-table))

;;; Public.
;;;
(defun folder-existsp (folder)
  "Returns t if the directory for folder exists.  Folder is a simple-string
   specifying a folder name relative to the MH mail directory."
  (declare (simple-string folder))
  (let ((pf (probe-file (folder-pathname folder))))
    (and pf (directoryp pf))))

;;; Public.
;;;
(defun create-folder (folder)
  "Creates folder directory with default protection #o711 but considers the
   MH profile for the \"Folder-Protect\" component.  Folder is a
   simple-string specifying a folder name relative to the MH mail
   directory."
  (declare (simple-string folder))
  (let* ((folder (strip-folder-name folder))
	 (pathname (folder-pathname folder))
	 (ses-name (namestring pathname))
	 (length-1 (1- (length ses-name)))
	 (name (if (= (position #\/ ses-name :test #'char= :from-end t)
		      length-1)
		   (subseq ses-name 0 (1- (length ses-name)))
		   ses-name))
	 (protection (profile-component "folder-protect")))
    (when protection
      (setf protection
	    (parse-integer protection :radix 8 :junk-allowed t)))
    (multiple-value-bind (winp err)
			 (unix:unix-mkdir name (or protection #o711))
      (or winp
	  (error "Failed to make directory ~S: ~A"
		 name
		 (unix:get-unix-error-msg err)))
      (setf (getstring folder (get-folder-table)) t))))

;;; Public.
;;;
(defun delete-folder (folder)
  "Delete FOLDER, return t and a list of skipped files on success else ()."
  ;; FIX error if folder current dir
  ;; FIX sort out new folder?
  ;; FIX if COMPAT m_delete current - m_mailpath(folder)
  ;; FIX check for profile entry atr- current - m_mailpath?
  (in-directory (folder-pathname folder)
    (let ((others 0)
	  (skipped))
      (do-files (file (folder-pathname folder)
		 :recurse t
		 :follow-links t
		 :backups t)
	(block nil
	  (let ((name (file-namestring file)))
	    (case (char name 0)
	      ((#\. #\, #\+ #\_ #\#)) ;; FIX some COMPAT,UCI
	      (t (or (parse-integer name :errorp ())
		     (string= name "cur")  ;; FIX COMPAT current
		     (string= name "@")  ;; FIX LINK
		     (string= name ",")  ;; FIX SBACKUP
		     (progn
		       (push name skipped)
		       (incf others)
		       (return-from nil)))))
	    (delete-file name))))
      ;; FIX rma folder   seems to clear all "atr- folder" fields
      (if (plusp others)
	  ()
	  (progn
	    (delete-dir (folder-pathname folder))
	    (delete-string (strip-folder-name folder) (get-folder-table))
	    (values t skipped))))))

;;; Public.
;;;
(defun list-folders (stream)
  "Print all folders to STREAM."
  (do-folders folder
    (write-line folder stream)))

;;; Public.
;;;
(defun print-folders (stream &optional (prefix ""))
  "Print all folders to STREAM."
  (do-folders folder
    (format stream "~A~A~%" prefix folder)))

(defun transfer-message (input output)
  "Write a single message from INPUT on OUTPUT."
  (loop
    for line = (read-line input ()) while line do
    ;; FIX should check for delimiter how?
    ;; FIX how to search in stream?
    (if (zerop (length line))
	(let ((line (read-line input ())))
	  (or line (return))
	  (and (>= (length line) 5)
	       (string= line "From " :end1 5)
	       (let ((pos (file-position input))
		     (next (read-field input)))
		 (prog1 (if next (fi (eq next :body)))
		   (file-position input pos)))
	       (return))))
    (write-line line output)))

(defun scan-message (input &optional file)
  "Return an alist of the fields in stream INPUT.  If date synthesis is
   required use the last modification time of FILE or the current time if
   FILE is ()."
  (let ((alist (read-fields input)))
    (when alist
      (let* ((date (cdr (assoc "Date" alist :test #'string=)))
	     (uni (if date
		      (or (parse-time date
				      :patterns
				      (append ext::*http-date-time-patterns*
					      ext::*default-date-time-patterns*))
			  ;; FIX parse-time failures
			  ;;(error "parse-time failed on ~A" date))
			  ())
		      (if file
			  (file-write-date file)
			  (get-universal-time)))))
	(push (cons "Universal-Date" uni) alist))
      alist)))

(defun cache-folder (folder)
  "Add a description of FOLDER to *folder-table*, returning the
   description."
  (let ((dir (folder-pathname folder))
	(folder (strip-folder-name folder))
	(msgs)
	(highest 0))
    (in-directory dir
      (do-files (file dir
		 :recurse ()
		 :follow-links t
		 :backups ())
	(let ((name (file-namestring file)))
	  (case (char name 0)
	    ((#\. #\, #\+ #\_ #\#)) ;; FIX some COMPAT,UCI
	    (t
	     (let ((num (parse-integer name :errorp ())))
	       (when num
		 (if (> num highest) (setq highest num))
		 (push (cons name
			     (with-open-file (input file :direction :input)
			       (or (scan-message input file)
				   (error "Failed to scan message ~A in ~A"
					  name folder))))
		       msgs)))))))
      (let ((descr (make-folder-info dir
				     (file-write-date dir)
				     highest
				     msgs
				     (get-sequences))))
	(setf (getstring folder (get-folder-table)) descr)
	descr))))

(defun scan-folder (folder)
  "Return a folder-info structure describing FOLDER."
  (let* ((dir (folder-pathname folder))
	 (info (getstring (strip-folder-name folder) (get-folder-table))))
    (case info
      ((t)
       (cache-folder folder))
      ((())
       (error "~A should be in *folder-table* already." folder))
      (t
       (let ((date (file-write-date dir)))
	 (or date (error "Failed to read modification time on ~A." dir))
#|
	 ;; FIX This is too slow, rely instead on the draft message
	 ;;     modifier updating the folder write date.
	 (if (equal dir (draft-folder-pathname))
	     ;; Scan the draft folder every time, as draft messages can be
	     ;; modified.
	     (cache-folder folder)
|#
	     ;; FIX assumes normal msgs always stay the same
	     ;;       eg might need to update if a msg has been annotated
	     (if (equal (folder-info-write-date info) date)
		 info
		 (cache-folder folder))
#|
	     )
|#
	 )))))

;;; Public.
;;;
;;; FIX add [sub-]sorting by other fields, e.g. subject
;;;
(defun sort-folder (folder)
  "Sort the messages in FOLDER by date."
  (let* ((folder-info (scan-folder folder))
	 (dir (folder-pathname folder))
	 (order))
    ;; Prepare an ordered list of the available message numbers.
    (dolist (msg (folder-info-messages folder-info))
      (push (parse-integer (car msg)) order))
    (setq order (sort order #'<))
    ;; Sort the list of messages.
    (setf (folder-info-messages folder-info)
	  (sort (folder-info-messages folder-info) #'message-older))
    ;; Rename the files to match the sorted list.
    (in-directory dir
      (unwind-protect
	  (let ((tem-name (pick-temporary-file-name "tem-~D~C"))
		(tem-msg (1+ (folder-info-highest folder-info))))
	    (loop
	      for sorted = (folder-info-messages folder-info) then (cdr sorted)
	      for ordered = order then (cdr ordered)
	      while (and sorted ordered)
	      finally (setf (folder-info-highest folder-info)
			    (car (last order)))
	      do
	      (let ((smsg (caar sorted))
		    (omsg (number-string (car ordered))))
		(or (string= smsg omsg)
		    (progn
		      ;; FIX Ensure that the renaming happens completely, or is
		      ;;     reverted on failure.
		      ;; Swap the file names.
		      (rename-file omsg tem-name)
		      (rename-file smsg omsg)
		      (rename-file tem-name smsg)
		      ;; Ensure rename-in-s uses folder-info.
		      (setf (folder-info-write-date folder-info)
			    (file-write-date dir))
		      ;; Update sequences, including current message.
		      (rename-in-sequences folder folder-info
					   omsg tem-msg)
		      (rename-in-sequences folder folder-info
					   smsg omsg)
		      (rename-in-sequences folder folder-info
					   tem-msg smsg)
		      ;; Rename the entries in the sorted list.
		      (rplaca (assoc omsg sorted :test #'string=) smsg)
		      (rplaca (car sorted) omsg)))))
	    (if (probe-file tem-name) (delete-file tem-name)))
	;; Update cache and disk sequences.  ;; FIX still needed?
	(update-sequences folder-info)))))

;;; Public.
;;;
(defun pack-folder (folder)
  "Number the messages in FOLDER consecutively, starting from one."
  (let ((folder-info (scan-folder folder))
	(dir (folder-pathname folder)))
    ;; Sort the list of messages by message number.
    (setf (folder-info-messages folder-info)
	  (sort (folder-info-messages folder-info) #'message-<=))
    ;; Rename the files.
    (in-directory dir
      (unwind-protect
	  (let ((num 0))
	    (loop
	      for messages = (folder-info-messages folder-info)
	      then (cdr messages)
	      while messages
	      do
	      (incf num)
	      (let ((id (caar messages))
		    (new-id (number-string num)))
		(or (string= id new-id)
		    (progn
		      (rename-file id new-id)
		      ;; Ensure rename-in-s uses folder-info.
		      (setf (folder-info-write-date folder-info)
			    (file-write-date dir))
		      ;; Update sequences, including current message.
		      (rename-in-sequences folder folder-info
					   id new-id)
		      ;; Rename the entry in the cached message list.
		      (rplaca (car messages) new-id)))))
	    (setf (folder-info-highest folder-info) num))
	;; Update cache and disk sequences.  FIX still needed?
	(update-sequences folder-info)))))

(defun add-directory (directory)
  "Recursively add the folders in DIRECTORY (relative to *directory*) to
   *folder-table*."
  (let ((dir-len (length (namestring (truename *directory*))))
	(old-table *folder-table*)
	(done))
    (unwind-protect
	(progn
	  (setq *folder-table* (make-string-table))
	  (do-directories (pathname (merge-pathnames directory *directory*)
			   :follow-links t
			   :backups t ; Faster.
			   :recurse t)
 	    (when (directoryp (namestring pathname))
	      (setf (getstring (subseq (namestring pathname) dir-len)
			       *folder-table*)
		    t)))
	  (setq done t))
      (or done (setq *folder-table* old-table)))))


;;;; Fields.

(defvar *body-scan-length* 50
  "Maximum number of characters to scan from message body.")

(defun read-field (stream)
  "Read and return name and text of next field in STREAM.  For the body
   field also return the position of the start of the body."
  (let ((char (read-char stream nil)))
    (when char
      (if (member char '(#\newline #\- #\return))
	  ;; Header body separator.
	  (let ((body (make-string *body-scan-length* :initial-element #\ )))
	    (loop for ch = char then (read-char stream nil) while ch do
	      (if (char= ch #\newline) (return)))
	    (let ((pos (file-position stream)))
	      (loop for len from 0 to (1- *body-scan-length*)
		for char = (read-char stream nil)
		while char do
		(setf (char body len)
		      (cond ((member char '(#\tab #\newline #\return #\null)) #\space)
			    (t char))))
	      (values :body body pos)))
	  ;; Field.
	  (let ((text))
	    (unread-char char stream)
	    ;; First line.
	    (let* ((line (read-line stream))
		   (pos (or (position #\: line)
			    (return-from read-field nil)))
		   (name (subseq line 0 pos))
		   (line-length (length line)))
	      (incf pos) ; :
	      (if (>= pos line-length)
		  (setq text "")
		  (progn
		    ;; FIX ensure pos stays within string
		    (loop for po from pos to (1- line-length)
		      for char = (char line po)
		      while (or (char= char #\space) (char= char #\tab)) do
		      (incf pos))
		    (setq text
			  (subseq line pos
				  (if (char= (char line (1- line-length))
					     #\return)
				      (1- line-length)
				      line-length)))
		    ;; More lines.
		    (loop for char = (read-char stream ()) while char do
		      (unread-char char stream)
		      (or (char= char #\space)
			  (char= char #\tab)
			  (return))
		      (let* ((line (read-line stream))
			     (line-length (length line)))
			;; Keep the leading space of these lines, so that
			;; it is written if this message is sent.
			;; FIX ^M check
			(setq text
			      (concat text
				      (string #\newline)
				      (subseq line 0
					      (if (char= (char line
							       (1- line-length))
							 #\return)
						  (1- line-length)
						  line-length))))))))
	      (values name text)))))))

(defun read-fields (stream)
  "Return an alist of the fields in the first message in STREAM.  The
   message body excerpt has key :body."
  (collect ((alist))
    (loop
      (multiple-value-bind (name text pos)
			   (read-field stream)
	(or name (return))
	(when (eq name :body)
	  (alist (list (if (stringp name)
			   (nstring-capitalize name)
			   name)
		       text
		       pos))
	  (return))
	(alist (cons (if (stringp name)
			 (nstring-capitalize name)
			 name)
		     text))))
    (alist)))

(defun strip-date (date)
  "Return a short date from DATE field.  Throw an error if the parse
   fails."
  ;;; Sun, 10 Dec 2006 15:49:51 +0000
  ;;; Wed,  6 Dec 2006 15:51:45 +0000
  ;;; 12 Oct 2006 05:26:43 -0000
  (multiple-value-bind (sec min hour day month)
		       (decode-universal-time
			(or (parse-time date
					:patterns
					(append ext::*http-date-time-patterns*
						ext::*default-date-time-patterns*))
			    (return-from strip-date ())))
    (declare (ignore sec min hour))
    (format () "~2,'0D-~A" day (short-month-name month))))

(defun file-date (file)
  "Return a short date from the write date of FILE."
  (multiple-value-bind (sec min hour date month)
		       (decode-universal-time
			(or (file-write-date file)
			    (return-from file-date ())))
    (declare (ignore sec min hour))
    (format () "~2,'0D-~A" date (short-month-name month))))

(defun strip-name (from)
  "Return a name from FROM field."
  (if from
      (let* ((from (string-left-trim '(#\space #\tab) from))
	     (left (position #\< from)))
	(if left
	    (if (> left 0)
		(let ((from (string-right-trim
			     '(#\space #\tab)
			     (subseq from
				     (if (char= (char from 0) #\") 1 0)
				     left))))
		  (if (char= (char from (1- (length from))) #\")
		      ;; "name" <a@b.c>
		      (string-right-trim '(#\space #\tab)
					 (subseq from 0 (1- (length from))))
		      ;; name <a@b.c>
		      from))
		;; <a@b.c>
		(let ((right (position #\> from)))
		  (subseq from (1+ left) right)))
	    ;; a@b.c
	    (string-right-trim '(#\space #\tab) from)))
      ""))


;;;; Iteration.

(defun collect-messages (folder &optional recurse)
  "Return a list of the message numbers in FOLDER."
  (let ((dir (folder-pathname folder))
	(msgs))
    (in-directory dir
      (do-files (file dir
		 :recurse recurse
		 :follow-links t
		 :backups ())
	(let ((name (file-namestring file)))
	  (case (char name 0)
	    ((#\. #\, #\+ #\_ #\#)) ;; FIX some COMPAT,UCI
	    (t (let ((msg (parse-integer name :errorp ())))
		 (if msg (push msg msgs))))))))
    msgs))

(defmacro do-folders (folder &body body)
  "Run BODY on every folder with FOLDER bound to the folder."
  ;; FIX folder.c dother also prints folders named in atr-cur- profile
  ;;     field
  (let ((two (gensym)))
    `(progn
       (ext::do-strings (,folder ,two (get-folder-table))
	 (declare (ignore ,two))
	 ,@body))))

(defmacro do-sequence ((message sequence) &body body)
  "Run BODY with each message in SEQUENCE bound to MESSAGE.  SEQUENCE is a
   list like that of the folder-info sequence slot."
  (let ((id (gensym)))
    `(dolist (,message ,sequence)
       (if (listp ,message)
	   (loop
	     for ,id from (parse-integer (car ,message))
	             to (parse-integer (cdr ,message))
	     do
	     (let ((,message (number-string ,id)))
	       ,@body))
	   (progn ,@body)))))

(defmacro do-messages ((message entry messages folder folder-info)
		       &body body)
  "For each message in MESSAGES run BODY with MESSAGE bound to the message
   name and ENTRY bound to the cache entry for the message.  MESSAGES can
   be a single message or a list or messages.  A message in MESSAGES can be
   a (start-id-string . end-id-string) range, the name of a sequence or a
   message id string.  If MESSAGES is () do all messages in folder."
  (let ((id (gensym))
	(sequence (gensym))
	(folder-messages (gensym))
	(sequences (gensym)))
    `(let ((,folder-messages (folder-info-messages ,folder-info))
	   (,sequences (folder-info-sequences ,folder-info)))
       (dolist (,message
		(if ,messages
		    (if (listp ,messages) ,messages (list ,messages))
		    (mapcar #'car ,folder-messages)))
	 ;; FIX hack to allow "4-7" temp'ly, maybe should be perm
	 (when (stringp ,message)
	   (let ((,id (position #\- ,message)))
	     (if ,id
		 (setq ,message
		       (cons (string (parse-integer ,message
						    :end ,id))
			     (string (parse-integer ,message
						    :start (1+ ,id))))))))
	 (if (listp ,message)
	     (loop
	       for ,id from (parse-integer (car ,message))
	               to (parse-integer (cdr ,message))
	       do
	       (let* ((,message (number-string ,id))
		      (,entry (assoc ,message ,folder-messages
				     :test #'string=)))
		 (or ,entry
		     (error "Failed to find range message ~A in ~A cache."
			    ,message ,folder))
		 ,@body))
	     (let ((,entry (assoc ,message ,folder-messages
				  :test #'string=)))
	       (if ,entry
		   (progn
		     ,@body)
		   (let ((,sequence (cdr (assoc ,message ,sequences
					     :test #'string=))))
		     (if ,sequence
			 (do-sequence (,message ,sequence)
			   (let ((,entry (assoc ,message ,folder-messages
						:test #'string=)))
			     (or ,entry
				 (error
				  "Failed to find sequence message ~A in ~A cache."
				  ,message ,folder))
			     ,@body))
			 (error "Failed to find ~A in ~A."
				,message ,folder))))))))))


;;;; Summarizing.

(defun replace-newlines (string)
  "Replace newlines in STRING with spaces and return STRING."
  (loop for ch across string for i = 0 then (1+ i) do
    (if (char= ch #\newline) (setf (char string i) #\space)))
  string)

;;; Public.
;;;
(defun summarize-message (pathname stream &optional (width 80) current)
  "Summarize the message in PATHNAME on STREAM."
;; 293   10-Dec   837 Anacron           Anacron job 'cron.daily' on cspcz01   <</etc/cron.daily/logrotate: apac
  (with-open-file (input pathname :direction :input)
    (let ((alist (read-fields input)))
      (when alist
	(let ((from (cdr (assoc "From" alist :test #'string=)))
	      (body (cadr (assoc :body alist)))
	      (date (cdr (assoc "Date" alist :test #'string=))))
	  (dolist (box (cons *signature* *alternate-addresses*)
		       (setq from (strip-name from)))
	    (when (search box from)
	      (setq from (concat "To: "
				 (strip-name (cdr (assoc "To" alist
							 :test #'string=)))))
	      (return)))
	  (format stream
		  "~4<~A~>~:[ ~;+~]~:[ ~;-~] ~6<~A~>~:[*~; ~] ~5<~A~> ~@17<~A~> ~@37<~A~>"
		  (safe-subseq (file-namestring pathname) 0 4)
		  current
		  (cdr (assoc "Replied" alist :test #'string=))
		  (if date
		      (or (strip-date date) "FIX")
		      (file-date pathname))
		  date
		  (let ((size (file-size pathname)))
		    (cond ((> size 10238975) (format () "~DM" (truncate (/ (/ size 1024.0) 1024))))
			  ((> size 99999) (format () "~DK" (truncate (/ size 1024))))
			  (t size)))
		  (safe-subseq from 0 17)
		  ;; FIX This can leave trailing space if it is the last
		  ;;     output.
		  (safe-subseq (replace-newlines
				(or (cdr (assoc "Subject" alist
						:test #'string=))
				    ""))
			       0 37))
	  (let ((pre-width 77)) ; Length of string produced by format above.
	    (if (and body (> width pre-width))
		(let ((body (string-trim '(#\space #\tab)
					 (if (> (- width pre-width)
						(length body))
					     body
					     (subseq body
						     0 (- width pre-width))))))
		  (or (string= body "")
		      (format stream "  ~A" body))))))
	(terpri stream)))))

;;; Public.
;;;
(defun summarize-messages (folder messages stream &optional (width 80))
  "Summarize MESSAGES in FOLDER on STREAM."
  ;; FIX could add "next", "prev", ...
  (if (and (stringp (car messages)) (string= (car messages) "all"))
      (summarize-folder folder stream width)
      (let ((dir (folder-pathname folder))
	    (width (or width 80))
	    (folder-info (scan-folder folder)))
	(in-directory dir
	  (do-messages (message entry messages folder folder-info)
	    (summarize-message message stream width)))))) ;; FIX current

;;; Public.
;;;
(defun summarize-folder (folder stream &optional width)
  "Summarize FOLDER on STREAM."
  (let ((width (or width 80))
	(msgs (collect-messages folder)))
    (setq msgs (sort msgs #'<))
    (summarize-messages folder
			(iterate convert ((messages msgs))
			  (if (car messages)
			      (cons (number-string (car messages))
				    (convert (cdr messages)))))
			stream
			width)))


;;;; Messages.

(defun message-older (msg1 msg2)
  (let ((date1 (cdr (assoc "Universal-Date" (cdr msg1) :test #'string=)))
	(date2 (cdr (assoc "Universal-Date" (cdr msg2) :test #'string=))))
    (if date2
	(if date1
	    (if (<= date1 date2) t ())
	    ())
	t)))

(defun message-<= (msg1 msg2)
  "Return t if the id of MSG1 is <= the id of MSG2."
  (let ((id1 (parse-integer (car msg1)))
	(id2 (parse-integer (car msg2))))
    (<= id1 id2)))

(defun highest (folder-info)
  "Return an integer of the highest entry in folder-info, or 0 if the
   folder has a single entry."
  (let ((highest 0))
    (dolist (message (folder-info-messages folder-info))
      (let ((id (parse-integer (car message))))
	(if (> id highest)
	    (setq highest id))))
    highest))

;;; Public.
;;;
(defun move-messages (source dest &rest messages)
  "Move MESSAGES from folder SOURCE to folder DEST.  Assume DEST exists and
   SOURCE is readable."
  (fi (string= source dest)
      (let* ((source-info (scan-folder source))
	     (dest-info (scan-folder dest))
	     (source-messages (folder-info-messages source-info))
	     (dest-dir (namestring (folder-pathname dest)))
	     (source-current (current-message source)))
	(in-directory (folder-pathname source)
	  (unwind-protect
	      (progn
		(do-messages (message entry messages source source-info)
		  ;; FIX the rest of this block should be ~atomic
		  (let ((dest-id (incf (folder-info-highest dest-info))))
		    (rename-file message (format () "~A/~D" dest-dir dest-id))
		    ;; (`update-sequences' will adjust the sequences.)
		    ;; Move entry to the destination cache.
		    (setf (folder-info-messages source-info)
			  (setq source-messages
				(delq entry source-messages)))
		    (if (eq source-current (parse-integer message))
			;; Update the current message in the source.
			(setf (current-message source)
			      (highest source-info)))
		    (if (eq (parse-integer message)
			    (folder-info-highest source-info))
			;; Adjust the source highest.
			(setf (folder-info-highest source-info)
			      (highest source-info)))
		    (rplaca entry (number-string dest-id))
		    (setf (folder-info-messages dest-info)
			  ;; FIX should be sorted?
			  (cons entry (folder-info-messages dest-info)))))
		;; Update the folder cache dates.
		(setf (folder-info-write-date source-info)
		      (file-write-date (folder-pathname source)))
		(setf (folder-info-write-date dest-info)
		      (file-write-date (folder-pathname dest))))
	    ;; Update cache and disk sequences.
	    (update-sequences source-info))))))

;;; Public.
;;;
(defun show-messages (stream folder &rest messages)
  "Write MESSAGES from FOLDER onto STREAM."
  (let* ((folder-info (scan-folder folder)))
    (in-directory (folder-pathname folder)
      (do-messages (message entry messages folder folder-info)
	;; FIX is there a better way to write a file to a stream?
	(with-open-file (input message :direction :input)
	  (loop for line = (read-line input ()) while line do
	    (write-line line stream)))))))

(declaim (inline %delete-message))
(defun %delete-message (msg folder dir folder-info errorp)
  "Rename MSG with a , prefix.  Must be called with DIR current."
  (let* ((mlist (folder-info-messages folder-info))
	 (entry (assoc msg mlist :test #'string=)))
    (if entry
	(progn
	  ;; FIX rest should be ~atomic
	  (loop
	    for pro = (concat "," msg) then (concat "," pro)
	    while (probe-file pro)
	    finally (rename-file msg pro))
	  ;; Update the folder cache.
	  (setf (folder-info-messages folder-info)
		(delq entry mlist))
	  (if (eq (parse-integer msg) (folder-info-highest folder-info))
	      (setf (folder-info-highest folder-info)
		    (highest folder-info)))
	  (setf (folder-info-write-date folder-info)
		(file-write-date dir)))
	(if errorp (error "Failed to find ~A in ~A cache." msg folder)))))

;;; Public.
;;;
(defun delete-message (folder message &optional (errorp t))
  "Delete MESSAGE from FOLDER.  MESSAGES t indicates all messages.  With
   ERRORP true the given messages must exist, else an error is signalled."
  (let* ((folder-info (scan-folder folder))
	 (dir (folder-pathname folder))
	 (current-message (current-message folder)))
    (in-directory dir
      (unwind-protect
	  (%delete-message message folder dir folder-info errorp)
	(or (probe-file current-message)
	    (setf (current-message folder) (highest folder-info)))
	(update-sequences folder-info)))))

;;; Public.
;;;
(defun delete-messages (folder &optional (messages t) (errorp t))
  "Delete MESSAGES from FOLDER.  MESSAGES t indicates all messages.  With
   ERRORP true the given messages must exist, else an error is signalled."
  (let* ((messages (if (eq messages t) (collect-messages folder) messages))
	 (folder-info (scan-folder folder))
	 (dir (folder-pathname folder))
	 (current-message (current-message folder)))
    (in-directory dir
      (unwind-protect
	  (do-messages (message entry messages folder folder-info)
	    (%delete-message message folder dir folder-info errorp))
	(or (probe-file current-message)
	    (setf (current-message folder) (highest folder-info)))
	(update-sequences folder-info)))))

(declaim (inline get-field get-body))

(defun get-field (entry field)
  (assoc field (cdr entry) :test #'string=))

(defun get-body (entry)
  (assoc :body (cdr entry)))

(declaim (special *entry*))

(defun cc (string)
  "Return true if STRING is a substring of the Cc field of *entry*."
  (search string (cdr (get-field *entry* "Cc"))))

(defun f-cc (string)
  "With case folding, return true if STRING is a substring of the Cc field
   of *entry*."
  (search (string-upcase string)
	  (string-upcase (cdr (or (get-field *entry* "Cc")
				  (return-from f-cc))))))

(defun from (string)
  "Return true if STRING is a substring of the From field of *entry*."
  (search string (cdr (get-field *entry* "From"))))

(defun f-from (string)
  "With case folding, return true if STRING is a substring of the From
   field of *entry*."
  ;; FIX (let ((*case-fold* t)) ...
  (search (string-upcase string)
	  (string-upcase (cdr (or (get-field *entry* "From")
				  (return-from f-from))))))

(defun to (string)
  "Return true if STRING is a substring of the To field of *entry*."
  (or (search string (cdr (get-field *entry* "Delivered-To")))
      (search string (cdr (get-field *entry* "To")))))

;; FIX finish rest of folding functions

; (defun f-to (string)
;   "With case folding, return true if STRING is a substring of the To field of *entry*."
;   (or (search string (cdr (get-field *entry* "Delivered-To")))
;       (search string (cdr (get-field *entry* "To")))))

(defun subject (string)
  "Return true if STRING is a substring of the Subject field of *entry*."
  (search string (cdr (get-field *entry* "Subject"))))

(defun f-subject (string)
  "With case folding, return true if STRING is a substring of the Subject
   field of *entry*."
  (search (string-upcase string)
	  (string-upcase (cdr (or (get-field *entry* "Subject")
				  (return-from f-subject))))))

(defun content (string)
  "Return true if STRING is a substring any part of message *entry*.
   Expect to be called in the directory in which *entry* resides."
  (with-open-file (input (car *entry*) :direction :input)
    (loop for line = (read-line input ()) while line do
      (if (search string line)
	  (return-from content t)))))

(defun date (string &optional (field "Date"))
  "Return true if STRING is a substring of FIELD in *entry*."
  (search string (cdr (get-field *entry* field))))

(defun f-date (string &optional (field "Date"))
  "With case folding, return true if STRING is a substring of FIELD in
   *entry*."
  (search string (cdr (get-field *entry* field))))

(defun before (date &optional (field "Date"))
  "Return true if string DATE is earlier than FIELD in *entry*.  Expect the
   current directory to be the one in which *entry* resides."
  (> (or (parse-time date) (return-from before))
     (or (parse-time (cdr (or (get-field *entry* field)
			      (return-from before))))
	 (return-from before))))

(defun after (date &optional (field "Date"))
  "Return true if string DATE is later than FIELD in *entry*.  Expect the
   current directory to be the one in which *entry* resides."
  (< (or (parse-time date) (return-from after))
     (or (parse-time (cdr (or (get-field *entry* field)
			      (return-from after))))
	 (return-from after))))

(defun -- (field string)
  "Return true if STRING is a substring of FIELD in *entry*."
  (search string (cdr (get-field *entry* field))))

(defun f--- (field string)
  "With case folding, return true if STRING is a substring of FIELD in
   *entry*."
  (search (string-upcase string)
	  (string-upcase (cdr (or (get-field *entry* field)
				  (return-from f---))))))

;;; Public.
;;;
(defun pick-messages (folder messages expression)
  "Return the list of message from MESSAGES in FOLDER that are described by
   EXPRESSION."
  (let ((folder-info (scan-folder folder)))
    (collect ((pick) (msgs))
      ;; Expand messages into a list of messages.
      (in-directory (folder-pathname folder)
	(do-messages (message entry messages folder folder-info)
		     (msgs message))
	(fi expression
	    (msgs)
	    (let ((folder-msgs (folder-info-messages folder-info)))
	      (in-package "MH")
	      (loop for message in (msgs) do
		(let ((*entry* (assoc message folder-msgs :test #'string=)))
		  (when *entry*
		    (if (eval expression) (pick (car *entry*))))))
	      (pick)))))))

;;; Public.
;;;
(defun split-messages (folder rules refiler)
  "Split the messages in FOLDER according to RULES using function REFILER.
   REFILER is called with a source folder, message and destination folder."
  (let* ((folder-info (scan-folder folder))
	 (folder (coerce-folder-name folder))
	 (msgs (folder-info-messages folder-info))
	 (messages (if msgs (mapcar #'car msgs))))
    (dolist (rule rules)
      (or messages (return))
      (loop for pick in (pick-messages folder messages (cadr rule)) do
	(setq messages (delete pick messages))
	(funcall refiler folder pick
		 (mh:coerce-folder-name (car rule)))))))

;; FIX when compiled:  XXX
; 	Function with declared result type NIL returned:
; 	   MH:DRAFT-NEW
;      when byte-compiled:
; 	Type-error in KERNEL::OBJECT-NOT-FUNCTION-ERROR-HANDLER:
; 	   95822313 is not of type FUNCTION
;
(eval-when (eval load)

;;; Public.
;;;
(defun draft-new (&optional (components-name "components") components)
  "Draft a new message, returning the number of the draft.  Insert in the
   message COMPONENTS if COMPONENTS is set, otherwise the contents of the
   file named COMPONENTS-NAME in the mail directory if the file exists,
   otherwise a simple set of headers."
  (let* ((folder-info (scan-folder (draft-folder)))
	 (new (1+ (highest folder-info)))
	 (dir (draft-folder-pathname))
	 (comppath (fi components
		       (merge-pathnames components-name *directory*))))
    ;; Create file.
    ;;
    (flet ((create-draft (dir name in)
	     (with-open-file (out
			      (merge-pathnames (string name) dir)
			      :direction :output)
	       (loop for line = (read-line in ()) while line do
		 (write-line line out)))))
      (cond (components
	     (with-input-from-string (in components)
	       (create-draft dir new in)))
	    ((probe-file comppath)
	     (with-open-file (in comppath :direction :input)
	       (create-draft dir new in)))
	    (t
	     (with-input-from-string (in #.(format () "To:~%~
						       cc:~%~
						       Subject:~%~
						       --------~%"))
	       (create-draft dir new in)))))
    ;; Update cache.
    ;;
    (setf (folder-info-highest folder-info) new)
    (setf (folder-info-messages folder-info)
	  ;; FIX should be sorted?
	  (cons
	   ;; Make a folder cache entry.
	   (let* ((msg (string new))
		  (pathname (merge-pathnames (string new) dir)))
	     (cons msg
		   (with-open-file (input pathname
					  :direction :input)
		     (or (scan-message input pathname)
			 (error "Failed to scan new draft (~A in ~A)"
				msg (draft-folder))))))
	   (folder-info-messages folder-info)))
    (setf (current-message (draft-folder)) new)
    ;; Update folder cache write date.
    (setf (folder-info-write-date folder-info) (file-write-date dir))
    ;; Update cache and disk sequences.
    (update-sequences folder-info)
    new))

;;; Public.
;;;
(defun draft-resend ()
  "Create a resend draft."
  (draft-new () (format () "Resent-To: ~%Resent-Cc: ~%")))

;;; Public.
;;;
(defun draft-forward (folder message)
  "Draft a forward of MESSAGE from FOLDER."
  (with-open-file (in
		   (merge-pathnames (string message)
				    (folder-pathname folder))
		   :direction :input)
    (with-open-file (out
		     (merge-pathnames (string (draft-new "forwcomps"))
				      (draft-folder-pathname))
		     :direction :output
		     :if-does-not-exist :error
		     :if-exists :append)
      (format out "~&~%------- Forwarded Message~%~%")
      (loop for line = (read-line in ()) while line do
	(write-line line out))
      (format out "~&------- End of Forwarded Message~%"))))

;;; Public.
;;;
(defun draft-reply (folder message &optional cc)
  "Draft a reply to MESSAGE from FOLDER.  CC can be :all, :others or ()."
  (let* ((folder-info (scan-folder folder))
	 (messages (folder-info-messages folder-info))
	 (entry (assoc (string message) messages :test #'string=)))
    (or entry (error "Failed to find ~A in ~A" message folder))
    ; To: UKFSN Renewals <support@ukfsn.org>
    ; cc: mundell@ukfsn.org
    ; Fcc: archive/misc
    ; Subject: Re: Your UKFSN account renewal
    ; In-reply-to: Message of Sun, 25 Feb 2007 04:53:35 +0000.
    ; 		<20070225045335.F24DEE6DAE@mail.ukfsn.org>
    ; From: Matthew Mundell <matt@mundell.ukfsn.org>
    ; Reply-To: matt@mundell.ukfsn.org
    ; --------
    (draft-new
     ()
     (format () "To: ~A~%~A~
		 Fcc: ~A~%~
		 Subject: Re: ~A~%~
		 In-reply-to: Message of ~A.
		 ~A~%~
		 From: ~A <~A>~%~
		 Reply-To: ~A~%~
		 --------~%"
	     (or (cdr (assoc "Reply-To" (cdr entry) :test #'string=))
		 (cdr (assoc "From" (cdr entry) :test #'string=)))
	     (ecase cc
	       ;; FIX wrap at some col width
	       (:all
		(let* ((cc (cdr (assoc "Cc" (cdr entry)
				       :test #'string=)))
		       (to (cdr (assoc "To" (cdr entry)
				       :test #'string=)))
		       (to (if to
			       (fi (loop for ad in
				     (cons *address* *alternate-addresses*)
				     do
				     (if (search ad to) (return t)))
				   (if cc
				       (concat ", " to)
				       to)))))
		  (if (or to cc)
		      (format () "Cc: ~A~A~%"
			      (or cc "")
			      (or to ""))
		      "")))
	       ;; FIX wrap at some col width
	       ;; FIX This will split up an address containing , or ;.
	       (:others
		(let* ((cc (cdr (assoc "Cc" (cdr entry)
				       :test #'string=)))
		       (cc (if cc
			       (let ((cc (split cc '(#\, #\;))))
				 (collect ((others))
				   (loop for from in cc do
				     (or (loop for ad in
					   (cons *address*
						 *alternate-addresses*)
					   do
					   (if (search ad from)
					       (return t)))
					 (others from)))
				   (others)))))
		       (to (cdr (assoc "To" (cdr entry)
				       :test #'string=)))
		       (to (if to
			       (fi (loop for ad in
				     (cons *address* *alternate-addresses*)
				     do
				     (if (search ad to) (return t)))
				   (if cc
				       (concat ", " to)
				       to)))))
		  (if (or to cc)
		      (format () "Cc: ~A~A~%"
			      (if cc (string-trim '(#\space)
						  (apply #'concatenate
							 'simple-string cc))
				  "")
			      (or to ""))
		      "")))
	       ((()) ""))
	     (archive-for-reply folder message)
	     (let ((subject (cdr (assoc "Subject" (cdr entry)
					:test #'string=))))
	       (if (and (> (length subject) 2)
			(string= (string-upcase subject) "RE:"
				 :end1 3))
		   (subseq subject
			   (if (and (> (length subject) 3)
				    (char= (char subject 3) #\ ))
			       4
			       3))
		   subject))
	     (cdr (assoc "Date" (cdr entry) :test #'string=))
	     (cdr (assoc "Message-Id" (cdr entry) :test #'string=))
	     *signature*
	     (address-for-from folder message)
	     (address-for-reply-to folder message)))))

) ; eval-when

(defun parse-address (string)
  "Return the first email address in STRING and the position in string at
   the end of the address."
  (let ((at-pos (position #\@ string)))
    (when at-pos
      (let* ((string (substitute #\space #\newline string))
	     (start (position #\space string
			      :from-end t :end at-pos))
	     (end (or (position #\space string :start at-pos)
		      (length string))))
	(if start (incf start) (setq start 0))
	(if (char= (char string start) #\<) (incf start))
	(if (char= (char string (1- end)) #\>) (decf end))
	(values (subseq string start end) end)))))

(defun finish-headers (stream from &optional msgid)
  "Write delivery-time fields to STREAM."
  (let ((time (get-universal-time)))
    (write-date-field "Date" stream time)
    (if msgid
	(format stream "Message-ID: <~D.~D@~A>~%"
		(unix:unix-getpid)
		time
		(machine-instance)))
    (format stream "Sender: ~A~%" from)))

;;; Public.
;;;
(defun deliver-messages (account messages &optional (folder (draft-folder)))
  "Deliver MESSAGES from FOLDER via ACCOUNT.  Return t on success, else ()
   and the error response."
  (let* ((folder-info (scan-folder folder))
	 (folder-messages (folder-info-messages folder-info))
	 (folder-pathname (folder-pathname folder)))
    (loop for message in messages do
      (let ((entry (assoc (string message) folder-messages :test #'string=))
	    (to))
	(or entry (error "Failed to find ~A in ~A" message folder))
	(if (get-field entry "Bcc") (error "Bcc"))
	(if (get-field entry "Resent-Bcc") (error "Resent-Bcc"))
	(let ((resent-to (get-field entry "Resent-to"))
	      (resent-cc (get-field entry "Resent-cc")))
	  (loop for string in
	    (if (or resent-to resent-cc)
		`(,resent-to ,resent-cc)
		`(,(cdr (assoc "Cc" (cdr entry) :test #'string=))
		  ,(cdr (assoc "To" (cdr entry) :test #'string=)))) do
	    (loop
	      (multiple-value-bind (address end)
				   (parse-address string)
		(or address (return))
		(push address to)
		(setq string (subseq string end)))))
	  (or to (error "Message must have a destination address."))
	  (let ((from (if (or resent-to resent-cc)
			  (or (parse-address (cdr (assoc "Resent-from"
							 (cdr entry)
							 :test #'string=)))
			      (error "Message must have a Resent-From address."))
			  (or (parse-address (cdr (assoc "From" (cdr entry)
							 :test #'string=)))
			      (error "Message must have a From address.")))))
	    (multiple-value-bind
		(success error)
		(internet:smtp-mail (stream to from account)
		  (let* ((pos)
			 (fcc-folder (cdr (get-field entry "Fcc")))
			 (fcc-folder-info (if fcc-folder (scan-folder fcc-folder)))
			 (fcc-message (if fcc-folder (1+ (highest fcc-folder-info))))
			 (fcc (when fcc-folder
				(ensure-directories-exist
				 (folder-pathname fcc-folder))
				(open (merge-pathnames
				       (string fcc-message)
				       (folder-pathname fcc-folder))
				      :direction :io
				      :if-does-not-exist :create
				      :if-exists :error)))
			 (stream (if fcc
				     (make-broadcast-stream stream fcc)
				     stream)))
		    (loop for fields = (cdr entry) then (cdr fields)
		      while fields do
		      (case= (caar fields)
			("Universal-Date" "Fcc")
			(:body (setq pos (caddar fields)))
			(t
			 (format stream "~A: " (caar fields))
			 (write-string (cdar fields) stream)
			 (terpri stream))))
		    (finish-headers stream from)
		    (terpri stream)
		    (with-open-file (in (merge-pathnames message folder-pathname)
					:direction :input)
		      (file-position in pos)
		      (loop for line = (read-line in ()) while line do
			(write-line line stream)))
		    (when fcc
		      (file-position fcc :start)
		      (let ((alist (scan-message fcc)))
			(when alist
			  ;; Update the fcc folder cache.
			  (push (cons (string fcc-message) alist)
				; FIX msgs should be sorted?
				;; FIX ok to push for first msg?
				(folder-info-messages fcc-folder-info))
			  (setf (folder-info-highest fcc-folder-info)
				fcc-message)
			  (setf (folder-info-write-date fcc-folder-info)
				(file-write-date (folder-pathname fcc-folder)))))
		      (close fcc))))
	      (if success
		  (delete-message folder message)
		  (return-from deliver-messages (values () error)))))))))
  t)

;;; Public.
;;;
(defun write-headers (folder message stream &optional (headers t))
  "Write headers of MESSAGE in FOLDER to STREAM.  Return t on success, else
   ()."
  (with-open-file (in (merge-pathnames message (folder-pathname folder))
		      :direction :input
		      :if-does-not-exist ())
    (when in
      (let* ((folder-info (scan-folder folder))
	     (folder-messages (folder-info-messages folder-info))
	     (entry (assoc (string message) folder-messages
			   :test #'string=)))
	(if (eq headers t)
	    (loop for fields = (cdr entry) then (cdr fields)
	      while fields do
	      (let ((field (caar fields)))
		(case= field
		  ((:body "Universal-Date"))
		  (t (format stream "~A: ~A~%"
			     field (cdar fields))))))
	    (loop for header in headers while header do
	      (let ((field (get-field entry header)))
		(if field
		    (format stream "~A: ~A~%" (car field) (cdr field))))))
	(terpri stream)))
    t))

#|
(defun parse-content-type (entry)
  (let ((field (cdr (get-field entry "Content-Type")))
	type subtype start params)
    (when field
      (string-trim '(#\space) field)
      (setq field (nsubstitute #\newline #\space field))
      (let ((pos 0) (len (length field)))
	(flet ((next (&optional (end-ok t))
		 (incf pos)
		 (if (eq pos len)
		     (return-from parse-content-type
				  (if end-ok
				      (values type subtype))))))
	  ;; Type.
	  (setq type
		(loop while (and (< pos len)
				 (alphanumericp (char field pos)))
		  finally return (string-downcase (subseq field 0 pos))
		  do (incf pos)))
	  (if (eq pos len)
	      (return-from parse-content-type
			   (values type subtype)))
	  ;; Subtype.
	  (when (char= (char field pos) #\/)
	    (next)
	    (loop while (char= (char field pos) #\space) do (next))
	    (if (char= (char field pos) #\()
		(error "FIX comment after /"))
	    (setq start pos)
	    (setq subtype
		  (loop while (and (< pos len)
				   (alphanumericp (char field pos)))
		    finally return (string-downcase (subseq field start pos))
		    do (incf pos)))
	    (if (eq pos len)
		(return-from parse-content-type
			     (values type subtype))))
	  (loop while (char= (char field pos) #\space) do (next))
	  (if (char= (char field pos) #\()
	      (error "FIX comment after subtype"))
	  ;; Parameters.
	  (loop while (char= (char field pos) #\;) do
	    (next) ;; FIX if end str before param then err
	    (loop while (char= (char field pos) #\space) do (next))
	    (if (char= (char field pos) #\()
		(error "FIX comment after ;"))

	    )))
      (values type subtype))))
|#

;;; Public.
;;;
;;; FIX This handles a minimal portion of the MIME part type.
;;;
(defun write-part (in out entry body-start ct-parser)
  "Write the MIME part of ENTRY from IN to OUT, using CT-PARSER to parse
   Content-Type fields.  BODY-START is the file position of the start of
   the body."
  (let ((field (cdr (get-field entry "Content-Type"))))
    (when field
      (string-trim '(#\space) field)
      (setq field (nsubstitute #\space #\newline field))
      ;; FIX ct-parser works around confinement of parsers
      ;;     to ed pkg
      (multiple-value-bind (type subtype params)
			   (with-input-from-string
			       (ct-stream field)
			     (funcall ct-parser ct-stream))
	(case= (string-downcase type)
	  ("text"
	   (file-position in body-start)
	   (lisp:transfer in out))
	  ("multipart"
	   (let ((enc (cdr (get-field entry
				      "Content-Transfer-Encoding"))))
	     (if enc
		 ;; FIX which encodings are really allowed?
		 (or (string= enc "7bit") (string= enc "8bit")
		     (error "Multipart encoding should be \"7bit\" or \"8bit\"."))))
	   #|
	   (format out "subtype: ~A~%" subtype)
	   (format out "params: ~A~%" params)
	   |#
	   (let (boundary)
	     (or (and params
		      (setq boundary
			    (cdr (assoc "boundary" params
					:test #'string=))))
		 (error "Multipart must have a \"boundary\" parameter."))
	     (let ((boundary-len (+ (length boundary) 2)))
	       (file-position in body-start)
	       (collect ((parts))
		 (let ((line (read-line in ()))
		       (alternative (string= subtype "alternative")))
		   (loop for endp = () do
		     (fi (and (>= (length line) boundary-len)
			      (char= (char line 0) #\-)
			      (char= (char line 1) #\-)
			      (string= line boundary
				       :start1 2
				       :end1 boundary-len))
			 ;; Skip to first.
			 (setq line (read-line in ()))
			 (fi (eq (length line) boundary-len)
			     (setq endp t)
			     ;; Parse a part.
			     ;; FIX this scans body too
			     (let* ((fields (read-fields in))
				    (displayp (and (eq (length fields) 1)
						   (eq (caar fields) :body)))
				    (type (cdr (get-field (cons :dummy fields)
							  "Content-Type")))
				    (pos (file-position out)))
			       (when type
				 (string-trim '(#\space) type)
				 (setq type (nsubstitute #\space #\newline type))
				 (multiple-value-bind (type subtype params)
						      (with-input-from-string
							  (ct-stream type)
							(funcall ct-parser ct-stream))
				   (case= type
				     ("text"
				      (case= subtype
					("html"
					 (format out
						 "#FIX HTML part~%"))
					("plain"
					 (setq displayp t))))
				     ("multipart"
				      (write-part in out (cons :dummy fields)
						  (caddr (get-body (cons :dummy fields)))
						  ct-parser))
				     (t
				      (format out "#~A/~A [~A]~@[ ~A~]~%"
					      type subtype
					      (or (cdr (get-field (cons :dummy fields)
								  "Content-Description"))
						  "")
					      params params)))))
			       #|
			       (loop for fields = fields then (cdr fields) while fields do
				 (or (eq (caar fields) :body)
				     (format out "~A: ~A~%" (caar fields) (cdar fields))))
			       |#
			       (file-position in (or (caddr (get-body (cons :dummy fields)))
						     (error "Expected message body.")))
			       (if displayp
				   (loop for line = (read-line in ()) while line do
				     (when (and (>= (length line) boundary-len)
						(char= (char line 0) #\-)
						(char= (char line 1) #\-)
						(string= line boundary
							 :start1 2
							 :end1 boundary-len))
				       (or (eq (length line) boundary-len)
					   (setq endp t))
				       (return))
				     (format out "~A~%" line))
				   (parts
				    (list pos
					  (with-output-to-string (part)
					    (loop for line = (read-line in ()) while line do
					      (when (and (>= (length line) boundary-len)
							 (char= (char line 0) #\-)
							 (char= (char line 1) #\-)
							 (string= line boundary
								  :start1 2
								  :end1 boundary-len))
						(or (eq (length line) boundary-len)
						    (setq endp t))
						(return))
					      (format part "~A~%" line)))
					  fields)))
			       (if alternative (setq endp t)))))
		     (when endp
		       (pushnew (cons :parts (parts)) (cdr entry))
		       (return))))))))
	  (t
	   (format out "FIX handle content type ~A~%" type)
	   (format out "subtype: ~A~%" subtype)
	   (format out "params: ~A~%" params)
	   (format out "encoding: ~A~%"
		   (cdr (get-field entry
				   "Content-Transfer-Encoding")))))))))

;;; Public.
;;;
(defun write-message (folder message stream &optional (headers t) ct-parser)
  "Write MESSAGE in FOLDER to STREAM.  Return t on success, else ()."
  (with-open-file (in (merge-pathnames message (folder-pathname folder))
		      :direction :input
		      :if-does-not-exist ())
    (when in
      (if (eq headers t)
	  (lisp:transfer in stream)
	  (let* ((folder-info (scan-folder folder))
		 (folder-messages (folder-info-messages folder-info))
		 (entry (assoc (string message) folder-messages
			       :test #'string=))
		 (body-start (caddr (get-body entry))))
	    (or body-start (return-from write-message))
	    ;; Write headers.
	    (loop for header in headers while header do
	      (let ((field (get-field entry header)))
		(if field
		    (format stream "~A: ~A~%" (car field) (cdr field)))))
	    (terpri stream)
	    ;; Transfer body.
	    (let ((content-type (get-field entry "Mime-Version")))
	      (fi content-type
		  (progn
		    (file-position in body-start)
		    (lisp:transfer in stream))
		  (progn
		    (or (string= (cdr content-type) "1.0")
			(error "Expected MIME version 1.0"))
		    (write-part in stream entry body-start ct-parser))))))
      t)))

;;; Public.
;;;
(defun get-part (folder message position)
  "Return the part at POSITION in written MESSAGE from FOLDER."
  (let* ((folder-info (scan-folder folder))
	 (messages (folder-info-messages folder-info))
	 (entry (assoc (string message) messages :test #'string=))
	 (part (assoc position (cdr (assoc :parts (cdr entry))))))
    (when part
      (let* ((part-fields (caddr part))
	     (encoding (cdr (assoc "Content-Transfer-Encoding" part-fields
				   :test #'string=))))
	(ecase= encoding
	  ("base64" (base64:base64-decode (cadr part))))))))

;;; Public.
;;;
;;; FIX guessing this should only write certain fields from message into
;;; the new draft (currently writes fields like message-id and
;;; delivered-to).
;;;
(defun resend-message (account message folder draft-message
			       &optional (draft-folder (draft-folder)))
  "Resend MESSAGE in FOLDER via ACCOUNT, as defined by DRAFT-MESSAGE in
   DRAFT-FOLDER."
  (let* ((new (string (draft-new (merge-pathnames
				  draft-message
				  (folder-pathname draft-folder)))))
	 (folder-info (scan-folder folder))
	 (folder-messages (folder-info-messages folder-info))
	 (folder-pathname (folder-pathname folder))
	 (entry (assoc (string message) folder-messages :test #'string=))
	 (draft-message (string draft-message))
	 (draft-messages (folder-info-messages
			  (scan-folder draft-folder))))
    ;; FIX new must added to folder cache?
    ;; Append the message to a copy of the draft, prepending any "Resent"
    ;; field in the message with "Prev-".
    (with-open-file (out (merge-pathnames new (folder-pathname draft-folder))
			 :direction :output
			 :if-exists :supersede)
      (loop for field in (cdr entry) while field do
	(let ((name (car field)))
	  (if (and (stringp name)
		   (> (length name) 7)
		   (string= name "Resent-" :end1 7))
	      (format out "Prev-Resent-~A: ~A~%"
		      (subseq name 7) (cdr field))
	      (case= name
		("Universal-Date")
		(:body ; FIX assumes body last
		 ;; Write the resent fields from the draft.
		 ;; FIX draft-message must be rescanned as ed has just modified the headers
		 ;; FIX    a general problem w drafts?
		 ;;           if msg has been mod'd should rescan
		 ;;               maybe check file-write-date
		 (let* ((entry (assoc draft-message draft-messages
				      :test #'string=)))
		   (loop for field in (cdr entry) while field do
		     (or (eq (car field) :body)
			 (string= (car field) "Universal-Date")
			 (format out "~A: ~A~%" (car field) (cdr field)))))
		 ;; Write the from and date resent fields.
		 (or (get-field entry "Resent-From")
		     (format out "Resent-From: ~A~%"
			     (address-for-from folder message)))
		 (or (get-field entry "Resent-Date")
		     (write-date-field "Resent-Date" out))
		 (terpri out)
		 ;; Write the body.
		 (with-open-file (in (merge-pathnames message
						      folder-pathname))
		   (file-position in (caddr field))
		   (loop for line = (read-line in ()) while line do
		     (write-line line out)))
		 (return))
		(t
		 (format out "~A: ~A~%" (car field) (cdr field))))))))
    ;; Send the newly created draft.
    (multiple-value-bind (success response)
			 (deliver-messages account (list new))
      (if success
	  (progn
	    ;; FIX Annotate message being resent (the original message).
	    (delete-message draft-folder draft-message)
	    t)
	  ;; FIX If fail delete new draft
	  (progn
	    (delete-message draft-folder draft-message)
	    (values success response))))))

;;; Public.
;;;
(defun annotate-message (folder message component &optional text (datep t))
  "Annotate MESSAGE from FOLDER with COMPONENT.  If DATEP add a date
   COMPONENT field.  If TEXT add a text component field (in addition to any
   date field."
  (or (plusp (length component)) (error "COMPONENT must have length."))
  (let* ((folder-info (scan-folder folder))
	 (messages (folder-info-messages folder-info))
	 (entry (assoc (string message) messages :test #'string=))
	 (tem (pick-temporary-file-name))
	 (in-pathname (merge-pathnames (car entry) (folder-pathname folder))))
    (with-open-file (out tem :direction :output)
      (if datep
	  (write-date-field component out))
      (when text
	(format out "~A: ~A~%" component text))
      (with-open-file (in in-pathname :direction :input)
	(loop for line = (read-line in ()) while line do
	  (write-line line out)))
      (rename-file out in-pathname))))


;;;; Drops.

(defstruct (drop)
  new-fun
  inc-fun)

(defstruct (local-drop
	    (:include drop
		      (new-fun #'new-local-mail-p)
		      (inc-fun #'incorporate-local))
	    (:constructor
	     make-local-drop
	     (&optional (location
			 (or (cdr (assoc :mail ext:*environment-list*))
			     (cdr (assoc :maildrop ext:*environment-list*))
			     (profile-component "MailDrop") ; FIX
			     (merge-pathnames
			      (cdr (assoc :user ext:*environment-list*))
			      "/usr/spool/mail/"))))))
  location)

(defstruct (pop-drop (:include drop
			       (new-fun #'new-pop-mail-p)
			       (inc-fun #'incorporate-pop))
		     (:constructor %make-pop-drop
				   (type account port timeout)))
  type
  account
  port
  timeout)
;;
(defun make-pop-drop (type &key port timeout server user password)
  (%make-pop-drop type
		  (make-inet-account server user password)
		  (or port 110)  ; POP3 (POP2 is 109)
		  (or timeout 10)))

(defvar *drop-makers* '((:local . make-local-drop)
			(:pop . make-pop-drop))
  "List of type, maker associations for mail drops.")

;;; Public.
;;;
(defun make-drop (type &rest args)
  "Make a mail drop of TYPE."
  (let ((assoc (assoc type *drop-makers*)))
    (if assoc (apply (cdr assoc) args))))


;;;; New mail.

;;; Public.
;;;
(defun new-mail-p (drops)
  (dolist (drop drops)
    (if (funcall (drop-new-fun drop) drop)
	(return-from new-mail-p t)))
  ())

(defun new-local-mail-p (drop)
  (multiple-value-bind (success dev ino mode nlink uid gid rdev size)
		       (unix:unix-stat (namestring (local-drop-location drop)))
    (declare (ignore dev ino nlink uid gid rdev))
    (and success
	 (plusp (logand unix:s-ifreg mode))
	 (plusp size))))

(defun new-pop-mail-p (drop)
  (let* ((account (fill-from-netrc (pop-drop-account drop)))
	 (stream (pop-init account
			   (pop-drop-type drop)
			   (pop-drop-port drop)
			   (pop-drop-timeout drop))))
    (and stream
	 (let ((msg-count (pop-stat stream)))
	   (prog1 (if (and msg-count (plusp msg-count)) msg-count)
	     (inet-quit stream))))))


;;;; Incorporating mail.

;;; Public.
;;;
(defun incorporate (drops &optional folder stream)
  (let ((return))
    (dolist (drop drops)
      (if (funcall (drop-inc-fun drop) drop folder stream)
	  (setq return t)))
    return))

(defun incorporate-local (drop &optional folder log-stream)
  "Incorporate all mail from local DROP."
  (declare (ignore log-stream)) ; FIX Orig inc logs progress, for Inc New Mail.
  (let ((location (namestring (local-drop-location drop))))
    (multiple-value-bind (success dev ino mode nlink uid gid rdev size)
			 (unix:unix-stat location)
      (declare (ignore dev ino nlink uid gid rdev))
      (when (and success
		 (plusp (logand unix:s-ifreg mode))
		 (plusp size))
	(let* ((folder (or folder
			   (profile-component "inbox")
			   "inbox"))
	       (pathname (folder-pathname folder))
	       (lock (concat location ".lock")))
	  (ensure-directories-exist pathname)
	  ;; Lock the location.
	  (system:without-interrupts
	   (if (probe-file lock)
	       (error "Drop location ~A locked with ~A." location lock)
	       (with-open-file (lock-stream lock :if-exists :error
					    :if-does-not-exist :create))))
	  (unwind-protect
	      (let* ((folder-info (scan-folder folder))
		     (in-sequence (profile-component "unseen-sequence")))
		(in-directory pathname
		  ;; Read messages into files.
		  (with-open-file (in location :direction :input
				      :if-does-not-exist :error)
		    (let ((line (read-line in ())))
		      (or (and line
			       (> (length line) 5)
			       (string= line "From " :end1 5))
			  (error "Location must start with \"From \".")))
		    (loop
		      for new-id = (1+ (folder-info-highest folder-info))
		      then (1+ new-id)
		      while (peek-char () in ())
		      do
		      (let ((name (number-string new-id)))
			(with-open-file
			    (file-stream name
					 :direction :io
					 :if-does-not-exist :create
					 :if-exists :error)
			  (transfer-message in file-stream)
			  (file-position file-stream :start)
			  (let ((alist (scan-message file-stream)))
			    (when alist
			      ;; Update the folder cache.
			      (push (cons name alist)
				    ; FIX msgs should be sorted?
				    (folder-info-messages folder-info))
			      (setf (folder-info-highest folder-info)
				    new-id)
			      (setf (folder-info-write-date folder-info)
				    (file-write-date pathname))
			      ;; Update sequence.
			      (mark-messages folder (list name)
					     in-sequence :add))))))))
		(truncate-file location))
	    (delete-file lock)))
	t))))

(defun incorporate-pop (drop &optional folder log-stream)
  "Incorporate all mail from POP DROP."
  (declare (ignore log-stream)) ; FIX Orig inc logs progress, for Inc New Mail.
  (let* ((account (fill-from-netrc (pop-drop-account drop)))
	 (pop-stream (pop-init account
			       (pop-drop-type drop)
			       (pop-drop-port drop)
			       (pop-drop-timeout drop))))
    (when pop-stream
      (unwind-protect
	  (let ((msg-count (pop-stat pop-stream)))
	    (when (and msg-count (plusp msg-count))
	      (let* ((folder (or folder
				 (profile-component "inbox")
				 "inbox"))
		     (pathname (folder-pathname folder)))
		(ensure-directories-exist pathname)
		(let* ((folder-info (scan-folder folder))
		       (in-sequence (profile-component "unseen-sequence")))
		  (in-directory pathname
		    (loop
		      for pop-id from 1 to msg-count
		      for new-id = (1+ (folder-info-highest folder-info))
		                 then (1+ new-id)
		      do
		      (let ((name (number-string new-id)))
			(with-open-file
			    (file-stream name
					 :direction :io
					 :if-does-not-exist :create
					 :if-exists :error)
			  (pop-retr pop-stream pop-id file-stream)
			  (file-position file-stream :start)
			  (let ((alist (scan-message file-stream)))
			    (when alist
			      ;; Update the folder cache.
			      (push (cons name alist)
				    ; FIX msgs should be sorted?
				    (folder-info-messages folder-info))
			      (setf (folder-info-highest folder-info)
				    new-id)
			      (setf (folder-info-write-date folder-info)
				    (file-write-date pathname))
			      ;; Update sequence.
			      (mark-messages folder (list name)
					     in-sequence :add)
			      ;; Flush message.
			      (or (pop-dele pop-stream pop-id)
				  (error "Failed to flush ~A from POP."))))))))))
	      t))
	(inet-quit pop-stream)))))
