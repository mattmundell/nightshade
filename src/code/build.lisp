;; Build system.
;;
;; FIX need finer file modification time than 1 sec

(in-package "BUILD")

(export '(*first-target* *phonies* *targets*
	  *source-directory* *build-directory* *builder-directory*
	  build build-target deftarget with-build))

#[ Installation

A pre-built system is available at

    http://www.mundell.ukfsn.org/nightshade/nightshade-1f.tar.bz2

for installation on GNU/Linux 32bit x86 systems.

This is a bzip2 tar file that includes all binary and source files and is
intended for installation to a directory such as /usr/local/.  The
following Unix shell commands expand the archive to /usr/local/.

    > cd /usr/local/
    > tar -xvf /path/to/dist/nightshade-1f.tar.bz2

The program is then in the bin/ directory, so

    > /usr/local/bin/nightshade

starts the command line, and

    > /usr/local/bin/nightshade -edit

or

    > /usr/local/bin/ne

starts the X editor.  The terminal version of the editor needs a termcap
file, as detailed in [Local Setup].

Installation also works fine to locations other than /usr/local/, such as a
temporary directory in a user's home directory.  It is easiest to preserve
the layout of the installed directories, as the system looks for startup
files relative to the location of the startup program.

After installation the site initialization file is at
lib/nightshade/site-init.lisp (/usr/local/lib/nightshade/site-init.lisp in
the example above).

[ Command Line Options  ]  Options for the startup program.
[ Window Managers       ]  Notes on setting up window managers.
[ Terminal Emulators    ]  A list of tested emulators.
[ Local Setup           ]  Alt keys, termcap location.
]#

#[ Local Setup

== Mapping AltGr to Alt ==

Under X

    setxkbmap -option ctrl:nocaps,altwin:meta_alt,caps:shift

or in desktop/window manager

  % GNOME

    keyboard > layout options > Alt/Win Key behaviour

    enable "Alt and Meta are on the Alt keys"

  % KDE

    similar

Under Linux terminal

    setkeycodes 100 Alt

== Specifying the Termcap File ==

When running under a terminal the editor requires a description of the
capabilities of the terminal.  [Terminal Initialization] describes how to
setup these capabilities.
]#

#|
== Snapshot ==

Single archive at

http://www.mundell.ukfsn.org/nightshade/snapshot/

Only updated when features are in some way ready, so may stay at the same
version for some time.
|#

;; FIX this node is about building the system, so should be w the tools: stuff
;;     (the tools stuff might eventually be implemented using the system in
;;      this file)

#[ System Building

There are two requirements to build the system: the source code and an
already working system (a builder).  Pre-built packages are available to
install as the builder, as described in [Installation].  These packages
include the source code.

The Nightshade program is a small C program which loads a large prepared
system image into memory and sets that image running.  This kind of image
is a "core".

Throughout this documentation the following terms are used:

  % Core file

    A core file is a file containing a suspended image of a Lisp system.
    The core file contains header information describing where the data in
    the rest of the file should be placed in memory.  There is a simple C
    program which reads a core file into memory at the correct locations
    and then jumps to a location determined by the contents of the core
    file.  The C code includes the X window system which may be called from
    Lisp.

  % Cold core file

    A cold core file contains enough of the Lisp system to make it possible
    to load in the rest of the code necessary to generate a full Common
    Lisp.  A cold core file is generated by the program `genesis'.

The build process involves

  - building the small C program,

  - compiling the Lisp sources with the builder,

  - building a minimal "kernel" core,

  - loading the compiled Lisp sources into the kernel core, and

  - saving the final core.

[ Build Tools                     ]  Overview of build utilities.
[ Compiling the C                 ]
[ Compiling Source and Kernel     ]
[ Building the Final Core         ]
[ Starting the Built System       ]
[ Debugging (build)               ]
[ Running System Tests            ]
[ Cleaning the Build Directory    ]
[ Cloning the Builder             ]  Switching builder to latest build.
[ Building a Distribution Archive ]

FIX

builds a full core.  Adding certain symbols to \verb|*features*| before
loading worldload.lisp suppresses loading of different parts of the
system.  These symbols are:

  % :no-compiler

    don't load the compiler.

  % :no-clx

    don't load CLX.

  % :no-ed

    don't load the editor.

  % :no-pcl

    don't load PCL.

  % :runtime

    build a runtime code, implies all of the above, and then some.

== System Setup ==

[ Command Line Options  ]  Options for the startup program.
[ Window Managers       ]  Notes on setting up window managers.
[ Terminal Emulators    ]  A list of tested emulators.
[ Local Setup           ]  Alt keys, termcap location.

== FIX from older System Building ==

My best recommendation is to go slowly.  Start
by building a system from the sources provided on the tape.  Make sure you
are comfortable doing that before you try modifying anything.

Some hints on building the system which you may find useful:

  - If you change the compiler, you will have to recompile all the sources before
    the change is reflected in a system.  Changing the compiler is probably the
    most dangerous change you can make, since an error here means that
    nothing will work.  In particular, this is the time you are going to need
    to get familiar with adb and the internal structure of the Lisp, since a
    serious error in the compiler will show up during the initialization of the
    cold core file.

  - Changing the miscops should be done with care.  They follow a fairly rigid
    convention and you should understand all the information provided in
    Internal Design of Common Lisp on the IBM RT PC before making any changes
    to miscops.  You will probably need to get familiar with adb to debug some of
    the changes.  Note that this requires building a new cold core file and a final
    core file before the change is reflected in the system.

  - Changing sources in the code directory should be fairly straight forward.  The
    only time this will cause trouble is if you change something that a lot of
    files depend on in which case you will have to recompile everything and build
    a new cold core file and a core file.

  - Changing the editor should have no adverse effect on system integrity.

  - If you make a fairly major change, it is a good idea to go through the complete
    process of building a core file at least two or three times.  If things are
    still working at the end of this, your change is probably correct and shouldn't
    cause any serious trouble.

  - Finally, always keep at least one backup copy of a good core image around.
    If you build a bad core file over an existing one and can't back up, it is
    possible that you may not be able to recover from a serious error.

FIX refer to layout after cmd to inflate src archive

  % makefile

    contains make definitions for compiling lisp.c and lispstart.s
    into the lisp program.

logs  compile-ed.log  compile-compiler.log  compile-lisp.log

As each file is compiled, the
name of the file is printed on the terminal.  For each file a .fasl will be
generated.  Also, a single error log will be generated in the file
code:compile-lisp.log.

To compile genesis do the following:

    (compile-file "/usr/lisp/clc/genesis.lisp")

Genesis is used to build a cold core file.  Compiling Genesis takes about five
minutes.
The first three lines set up search lists for the code, icode, and miscops
subdirectories.  The fourth line loads in the program Genesis which builds
the cold core file.  The last line calls Genesis on a list of the files that
are necessary to build the cold core file.  As each file is being processed,
its name is printed to the terminal.  Genesis generates two files:
/usr/lisp/ilisp.core and /usr/lisp/lisp.map.  Ilisp.core is the cold core
file and lisp.map is a file containing the location of all the functions
and miscops in the cold core file.  Lisp.map is useful for debugging the
cold core file.

The first line invokes the lisp startup program specifying the cold core
file just built as the core file to load.  This cold core file is set up
to do a significant amount of initialization and it is quite possible that
some bug will occur during this initialization process.  After about a
minute, you should get a prompt of the form:


CMU Common Lisp kernel core image 2.7(?).
[You are in the Lisp Package.]
*



The process of purification moves Lisp
objects into static and read-only space, leaving very little in dynamic
space.  Having the Lisp system in static and read-only space reduces the
amount of work the garbage collector has to do.  Only those objects needed
in the final core file are retained.  Finally, a new core file is generated
and is written to the file /usr/lisp/nlisp.core.  Also, the currently
running Lisp should go through the default initialization process, finally
prompting for input with an asterisk.  At this point you have successfully
built a new core file containing a complete Common Lisp implementation.

XXX

]#

#[ Build Tools

Building is controlled by the build control file at "src/Build.lisp", with
help from the tools in "src/tools/".  The targets in Build.lisp can be
built by evaluating forms such as

    (build:build "n:src/" "all")

and the editor includes commands that automatically build these targets.
FIX build commands expect build:*xxx-dir* (should work as installed)
    ed commands also check equiv vars

The "tools/" directory contains various lisp and C-shell utilities for
building Nightshade:

  % setup.lisp

    Some Lisp utilities used for compiling changed files in batch mode and
    collecting the error output.  Sort of a crude defsystem.  Loads into
    the "user" package.  See `with-compiler-log-file' and `comf'.

  % <system>com.lisp

    Each system has a "com.lisp" file in "tools/" which compiles that
    system.  For example, edcom.lisp compiles the editor.
]#

#[ Compiling the C

The file n:build/bin/Config controls the building of the C core loader
program.  This file is a link to an architecture dependant file in
n:src/lisp/.

== First time: Header ==

The C program requires the bin/internals.h header file.

Evaluating

    (build:build "n:src/" "header")

builds the header.  The editor command `Build Header' invokes this function
in a Builder slave.

This is required because there is a circular dependancy between
bin/internals.h and bin/nightshade.map that causes bootstrapping problems.
To get around this problem the "header" rule runs `genesis' with an empty
file list and the fake nightshade.nm file that comes with the distribution,
like:

    * (load "c:generic/new-genesis") ; compile before loading
    * (lisp::genesis () "n:build/bin/nightshade.nm" "/tmp/dummy"
                     "n:build/bin/nightshade.map" "n:build/bin/internals.h")

`genesis' generates a whole bunch of warnings and a correct internals.h.
Compiling the program afterwards, as below, produces a correct
nightshade.map.

== Every time the C code changes: Program ==

Evaluating

    (build:build "n:src/" "bin")

compiles the C program.  The editor command `Build Bin' invokes this
function with output to a buffer.  This simply runs

    $ make all

in n:build/bin/.
]#

#[ Compiling Source and Kernel

Evaluating

    (build:build "n:src/" "all")

compiles the Lisp code using the builder and creates the "kernel.core"
image.  The editor command `Build All' invokes this function with output to
a buffer.

This invokes the tools:build-world.lisp program, using the following Lisp
fragment

    (setf user::src "<source directory>")
    (setf user::target "<target directory>")
    (setf user::systems '(:lisp :compiler :ed :kernel))
    (load (open "target:tools/build-world.lisp"))
]#

#[ Building the Final Core

Evaluating

    (build:build "n:src/" "core")

creates the final core from the "kernel.core" image.  The editor command
`Build Core' invokes this function with output to a buffer.

This runs the worldload.lisp file from the "src/tools" directory.
]#

#[ Starting the Built System

FIX

similar to notes in [Installation]

config
  update site-init.lisp

run bin/nightshade
(relative to build dir, eg /home/ni/src/nightshade/build/bin/nightshade)
]#

#[ Building a Distribution Archive

Evaluating

    (build:build "n:src/" "dist")

builds a distribution archive from the current sources.  The editor command
`Build Distribution' invokes this function with output to a buffer.

The resulting tarball is located in n:../ and is named like

    nightshade-VERSION--DATE.tar.bz2

for example

    nightshade-1f+--2008-09-24-22h26.tar.bz2
]#

#[ Debugging (build)

FIX update this node

Debugging Lisp code is much easier with a fully functional Lisp.  However, it
is quite possible that a change made in the system can cause a bug to happen
while running the cold core file.  If this happens, it is best to use adb to
track down the problem.  Unfortunately, the core file (i.e., the
remains of a process normally created by Unix when a process dies) generated by
such a bug will be of no use.  To get some useful information, follow these
steps:

  1) Look at the file /usr/lisp/lisp.map and find the entry points for the
     miscop routines error0, error1, and error2.  These entry points are
     used to invoke the Lisp error system from the miscops.  Write down
     the numbers beside these names.  They are the addresses (in hex) of where
     the miscops are located when the cold core file is loaded into memory.

  2) Run adb on the lisp file, i.e.:

adb lisp

  3) Set a breakpoint at the lispstart entry point:

lispstart:b

  4) Start the lisp program running, telling it to use ilisp.core (I'm
     assuming you're in /usr/lisp):

:r -c ilisp.core

  5) After a while, you will hit the lispstart breakpoint.  The core file has been
     mapped into memory, but control is still in the C startup code.  At this point,
     you should enter breakpoints for all the error entry points described above.

  6) Continue running the program by typing :c.  Shortly after this, the C lisp
     program will give up control to Lisp proper.  Lisp will start doing its
     initialization and will probably hit one of the error break points.
     At that point you can look around at the state and try and discover
     what has gone wrong.  Note that the two files rg and st are useful at this
     point.  Also, you should look at the document Internal Design of Common
     Lisp on the IBM RT PC by David B. McDonald, Scott E. Fahlman, and Skef
     Wholey so that you know the internal data structures.
]#

#[ Cleaning the Build Directory

Evaluating

    (build:build "n:src/" "clean")

clears out any files created by the build process.  The editor command
`Clean All' invokes this function with output to a buffer.
]#

#[ Running System Tests

Evaluating

    (build:build "n:src/" "test")

runs the system tests.  The editor command `Build Test' invokes this
function with output to a buffer.

{command:Test Symbol}
{command:Editor Test Symbol}
]#

#[ Cloning the Builder

After installation the builder and build link to the same directory.  For
some development it is necessary to separate the two, so that the build can
be updated and tested while the builder remains the same.  Cloning the
builder does this.  If the builder and build are already separate then
cloning the builder updates the builder to a copy of the build, keeping the
old builder.

Evaluating

    (build:build "n:src/" "clone")

clones the builder.  The editor command `Build Clone' invokes this function
with output to a buffer.
]#

(defvar *source-directory* "n:src/"
  "Directory in which to find source.")

(defvar *build-directory* "n:build/"
  "Directory into which the system is being built.")

(defvar *builder-directory* "n:builder/"
  "Directory in which to find the builder.")

(defvar *targets* ()
  "String table of the targets in scope during a build.")

(defvar *phonies* ()
  "List of phony targets, set during a build.  A phony target is always
   rebuilt, even if there is a file with the name of the target and all
   requirements are older than this file.  Typically this will be targets
   such as \"all\" and \"clean\".")

(defvar *first-target* ()
  "The first target defined during a build.")

(defun build-targets (targs &optional force)
  "Build the targets $targs."
  (loop for target in targs do
    (etypecase target
      (list
       (loop for target2 in target do (build-target target2 force)))
      (string
       (build-target target force)))))

(defun build-target (target &optional force)
  "Build $target."
  (if (getstring target *targets*)
      (funcall (getstring target *targets*) force)))

;; FIX when symbols are case sensitive, update this to allow
;; (deftarget file (req1 req2) ...)
(defmacro deftarget (target (&rest requirements) &body body)
  "deftarget target (requirement*) body"
  (let ((fun-name (gensym)))
    `(progn
       (or *first-target* (setq *first-target* ,target))
       (defun ,fun-name (&optional force)
	 ,(fi requirements '(declare (ignore force)))
	 ,(if requirements
	      `(if (probe-file ,target)
		   (let ((date (file-write-date ,target))
			 (buildp))
		     (loop for req in (list ,@requirements) do
		       (etypecase req
			 (list
			  (loop for req2 in req do
			    (when (or force
				      (member ,target *phonies* :test #'equal)
				      (<= date (file-write-date req2)))
			      (build-target req2)
			      (setq buildp t))))
			 (string
			  (when (or force
				    (member ,target *phonies* :test #'equal)
				    (<= date (file-write-date req)))
			    (build-target req)
			    (setq buildp t)))))
		     (if buildp (progn ,@body)))
		   (progn
		     (build-targets (list ,@requirements) force)
		     (progn
		       ,@body)))
	      `(progn
		 ,@body)))
       (setf (getstring ,target *targets*) #',fun-name))))

(defun build (pathname target)
  "In directory $pathname build $target.  Targets are defined in Build.lisp
   in $pathname."
  (let ((*targets* (make-string-table))
	(*first-target*)
	(*phonies*)
	(pathname (or pathname (current-directory)))
	(package-name (symbol-name (gensym))))
    (in-directory pathname
      (let ((package (make-package package-name :nicknames () :use ())))
	(use-package '("LISP" "BUILD" "EXT") package-name)
	(defpackage package-name
	  (:documentation "Temporary package for a particular build."))
	(unwind-protect
	    (let ((*package* package))
	      (load "Build.lisp" :verbose ())
	      (build-target target))
	  (delete-package package))))))

(defmacro with-build (pathname &body body)
  "WITH-BUILD PATHNAME BODY.  Execute body in a build context for PATHNAME.
   Build rules are read from Build.lisp in PATHNAME."
  `(let ((*targets* (make-string-table))
	 (*first-target*)
	 (*phonies*)
	 (package-name (symbol-name (gensym))))
     (in-directory ,pathname
       (let ((package (make-package package-name
				    :nicknames () :use ())))
	 (use-package '("LISP" "BUILD" "EXT") package-name)
	 (defpackage package-name
	   (:documentation
	    "Temporary package for a particular build."))
	 (unwind-protect
	     (let ((*package* package))
	       (load "Build.lisp" :verbose ())
	       ,@body)
	   (delete-package package))))))
